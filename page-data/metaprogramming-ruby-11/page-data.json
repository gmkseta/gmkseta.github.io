{"componentChunkName":"component---src-templates-post-jsx","path":"/metaprogramming-ruby-11/","result":{"data":{"site":{"siteMetadata":{"title":"Seongjun Kim Blog"}},"markdownRemark":{"id":"b76117b8-cdf6-5fdb-a207-d3bada809e8d","excerpt":"이전 두 장에서 Rails의 모듈 설계와 그 설계가 시간이 지남에 따라 어떻게 변했는지 살펴봤다. 이 장에서는 Rails 역사의 더 극적인 변화에 대해 이야기 해보도록 하겠다. 결국 Rails 코드베이스에서 거의 완전히 폐기된 이라는 메서드가 어떻게 흥하고 망했는지 aliasmethodchain의 부흥 Include - Extend 트릭에서 흥미로운 코드…","html":"<ul>\n<li>이전 두 장에서 Rails의 모듈 설계와 그 설계가 시간이 지남에 따라 어떻게 변했는지 살펴봤다.</li>\n<li>이 장에서는 Rails 역사의 더 극적인 변화에 대해 이야기 해보도록 하겠다.</li>\n<li>결국 Rails 코드베이스에서 거의 완전히 폐기된 <code class=\"language-text\">alias_method_chain</code>이라는 메서드가 어떻게 흥하고 망했는지</li>\n</ul>\n<h2>alias<em>method</em>chain의 부흥</h2>\n<ul>\n<li>Include - Extend 트릭에서 흥미로운 코드 조각을 보여줬었다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveRecord</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Validations</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n      base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n      <span class=\"token comment\"># here</span>\n      base<span class=\"token punctuation\">.</span>class_eval <span class=\"token keyword\">do</span>\n        alias_method_chain <span class=\"token symbol\">:save</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:validation</span>\n        alias_method_chain <span class=\"token symbol\">:save!</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:validation</span>\n      <span class=\"token keyword\">end</span>\n      <span class=\"token comment\"># here</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>ActiveRecord::Base에 Validations 모듈이 포함되어 있으면 표시된 라인이 Base를 다시 열고 alias<em>method</em>chain을 호출한다.</li>\n</ul>\n<h3>alias<em>method</em>chain를 썻던 이유</h3>\n<ul>\n<li>Greeting 메서드를 정의하는 모듈이 있다고 가정한다. 다음 코드처럼 보일 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">Greetings</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">greet</span></span>\n    <span class=\"token string\">\"hello\"</span>\n  <span class=\"token keyword\">end</span> \n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">Greetings</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>greet  <span class=\"token comment\"># => \"hello\"</span></code></pre></div>\n<ul>\n<li>만약 Greetings를 선택적인 기능으로 감싸고 싶다고 가정해보자.</li>\n<li>예를들어 인사말이 더 열정적이였으면 좋겠다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">Greetings</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">greet_with_enthusiasm</span></span>\n    <span class=\"token string\">\"Hey, <span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>greet_without_enthusiasm<span class=\"token delimiter tag\">}</span></span>!\"</span>\n  <span class=\"token keyword\">end</span>\n  alias_method <span class=\"token symbol\">:greet_without_enthusiasm</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:greet</span>\n  alias_method <span class=\"token symbol\">:greet</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:greet_with_enthusiasm</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>greet  <span class=\"token comment\"># => \"Hey, hello!\"</span></code></pre></div>\n<ul>\n<li>\n<p>새로운 두 가지 메서드를 정의한다. </p>\n<ul>\n<li><code class=\"language-text\">greeting_without_enthusiasm</code>는 원래 Greeting의 별칭이다.</li>\n<li>두 번째는 <code class=\"language-text\">greeting_with_enthusiasm</code> 은 <code class=\"language-text\">greeting_without_enthusiasm</code>을 호출하고 그 위를 추가단어로 감싼다</li>\n</ul>\n</li>\n<li>이런식의 래핑하는 아이디어는 레일즈에서 일반적이다.</li>\n<li>method, method<em>with</em>feature 및 method<em>without</em>feature가 생긴다</li>\n<li>별칭을 여기저기 작성하는 대신 Rails에서는 이러한 작업을 수행하는 메타프로그래밍 방법을 제공했다.</li>\n<li>ActiveSupport 라이브러리의 일부였었다.</li>\n</ul>\n<h3>alias<em>method</em>chain의 구현</h3>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Module</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">alias_method_chain</span></span><span class=\"token punctuation\">(</span>target<span class=\"token punctuation\">,</span> feature<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\"># Strip out punctuation on predicates or bang methods since</span>\n    <span class=\"token comment\"># e.g. target?_without_feature is not a valid method name.</span>\n    aliased_target<span class=\"token punctuation\">,</span> punctuation <span class=\"token operator\">=</span> target<span class=\"token punctuation\">.</span>to_s<span class=\"token punctuation\">.</span>sub<span class=\"token punctuation\">(</span><span class=\"token regex\">/([?!=])$/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> $<span class=\"token number\">1</span>\n    <span class=\"token keyword\">yield</span><span class=\"token punctuation\">(</span>aliased_target<span class=\"token punctuation\">,</span> punctuation<span class=\"token punctuation\">)</span> <span class=\"token keyword\">if</span> block_given<span class=\"token operator\">?</span>\n    with_method <span class=\"token operator\">=</span> <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>aliased_target<span class=\"token delimiter tag\">}</span></span>_with_<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>feature<span class=\"token delimiter tag\">}</span></span><span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>punctuation<span class=\"token delimiter tag\">}</span></span>\"</span>\n    without_method <span class=\"token operator\">=</span> <span class=\"token string\">\"<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>aliased_target<span class=\"token delimiter tag\">}</span></span>_without_<span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>feature<span class=\"token delimiter tag\">}</span></span><span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span>punctuation<span class=\"token delimiter tag\">}</span></span>\"</span>\n    alias_method without_method<span class=\"token punctuation\">,</span> target\n    alias_method target<span class=\"token punctuation\">,</span> with_method\n    <span class=\"token keyword\">case</span>\n    <span class=\"token keyword\">when</span> public_method_defined<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>without_method<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">public</span> target\n    <span class=\"token keyword\">when</span> protected_method_defined<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>without_method<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">protected</span> target\n    <span class=\"token keyword\">when</span> private_method_defined<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span>without_method<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">private</span> target\n    <span class=\"token keyword\">end</span> \n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>대상의 메서드 이름과 추가 기능의 이름을 사용한다.</li>\n<li>target<em>without</em>feature / target<em>with</em>feature 라는 이름의 두가지 새 메서드 이름을 eval한다.</li>\n<li>\n<p>원래 대상을 target<em>without</em>feature으로 저장하고, target<em>with</em>feature의 별칭을 target으로 지정한다.</p>\n<ul>\n<li>target<em>with</em>feature라는 메서드가 동일한 모듈 어딘가에 있다고 가정함</li>\n</ul>\n</li>\n<li>마지막 스위치 케이스는 target<em>without</em>feature의 원래 대상과 동일한 접근 제한자를 설정함</li>\n</ul>\n<h3>ActiveRecord::Validation에서의 사용</h3>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n  base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n  <span class=\"token comment\"># ...</span>\n  base<span class=\"token punctuation\">.</span>class_eval <span class=\"token keyword\">do</span>\n    alias_method_chain <span class=\"token symbol\">:save</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:validation</span>\n    alias_method_chain <span class=\"token symbol\">:save!</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:validation</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>이 줄은 Validation을 포함시키는 ( ActiveRecord::Base ) 클래스를 다시 열고 save를 해킹한다</li>\n<li>유효성 검사를 자동으로 save 할때마다 추가할 수 있다.</li>\n<li>save<em>without</em>validation이라고 하면 유효성 검사를 안하고 저장 가능하다.</li>\n<li>이 모듈은 save<em>with</em>validation 및 save<em>with</em>validation!을 구현해야겠지?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveRecord</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Validations</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">save_with_validation</span></span><span class=\"token punctuation\">(</span>perform_validation <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> perform_validation <span class=\"token operator\">&amp;&amp;</span> valid<span class=\"token operator\">?</span> <span class=\"token operator\">||</span> <span class=\"token operator\">!</span>perform_validation\n        save_without_validation\n      <span class=\"token keyword\">else</span>\n        <span class=\"token boolean\">false</span>\n      <span class=\"token keyword\">end</span> \n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">save_with_validation</span></span><span class=\"token operator\">!</span>\n      <span class=\"token keyword\">if</span> valid<span class=\"token operator\">?</span>\n        save_without_validation<span class=\"token operator\">!</span>\n      <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">raise</span> <span class=\"token constant\">RecordInvalid</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">end</span> \n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">valid</span></span><span class=\"token operator\">?</span>\n      <span class=\"token comment\">#...</span></code></pre></div>\n<ul>\n<li>실제 유효성 검사는 <code class=\"language-text\">valid?</code> 에서 일어난다.</li>\n<li><code class=\"language-text\">Validation#save_with_validation</code>은 유효성 검사가 실패하거나 호출자가 유효성 검사를 명시적으로 비활성화 한 경우 false를 반환한다.</li>\n<li>그렇지 않으면 원래 save<em>without</em>validation을호출한다.</li>\n<li><code class=\"language-text\">!</code> 에서는 에러를 발생시킨다.</li>\n</ul>\n<h2>alias<em>method</em>chain의 끝</h2>\n<ul>\n<li>Rails 2에서의 많은 모듈이 alias<em>method</em>chain을 사용하여 include하는 메서드의 기능을 래핑했다.</li>\n<li>결과적으로 alias<em>method</em>chain은 Rails와 수 십개의 타사 라이브러리에서 모두 사용되었다.</li>\n<li>alias<em>method</em>chain는 그저 Around Alias의 캡슐화일 뿐이고 <a href=\"https://blog.seongjun.kr/metaprogramming-ruby-5\">예전 챕터</a>에서의 문제점을 그대로 갖고있다.</li>\n<li>설상가상으로 alias<em>method</em>chain많이 사용되면서 실제 메서드의 버전 추적이 어려워진다.</li>\n<li>그러나 alias<em>method</em>chain의 가장 치명적인 문제는 대부분의 경우 불필요하다는 것,</li>\n<li>객체 지향 적인 관점에서 기존 메서드 주위에 기능을 래핑하는 보다 우아하고 내장된 방법을 제공한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">Greetings</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">greet</span></span>\n   <span class=\"token string\">\"hello\"</span>\n  <span class=\"token keyword\">end</span> \n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">Greetings</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>greet  <span class=\"token comment\"># => \"hello\"</span>\n\n<span class=\"token keyword\">module</span> <span class=\"token constant\">EnthusiasticGreetings</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">greet</span></span>\n    <span class=\"token string\">\"Hey, <span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span><span class=\"token keyword\">super</span><span class=\"token delimiter tag\">}</span></span>!\"</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">EnthusiasticGreetings</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span>ancestors<span class=\"token punctuation\">[</span><span class=\"token number\">0.</span><span class=\"token number\">.2</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># => [MyClass, EnthusiasticGreetings, Object]</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>greet        <span class=\"token comment\"># => \"hello\"</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">EnthusiasticGreetings</code> 을 포함할 때 해당 모듈이 클래스의 조상 체인에 있는 클래스보다 더 높아진다.</li>\n<li>따라서 greet 함수는 모듈의 greet를 재정의한다.</li>\n<li><code class=\"language-text\">EnthusiasticGreetings</code> 같은 중개 모듈을 삽입하고 오버라이드 및 super를 호출할 수 있다</li>\n<li>하지만 만약 클래스가 Rails같은 라이브러리의 일부이며 소스코드에서 직접 작업하지 않고 해당 라이브러리를 확장하므로 모든 경우에 그럴 수 있는게 아니다</li>\n<li>이 제한으로 인해 alias<em>metho</em>chain을 쓰는 것</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">EnthusiasticGreetings</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">greet</span></span>\n    <span class=\"token string\">\"Hey, <span class=\"token interpolation\"><span class=\"token delimiter tag\">#{</span><span class=\"token keyword\">super</span><span class=\"token delimiter tag\">}</span></span>!\"</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">prepend</span> <span class=\"token constant\">EnthusiasticGreetings</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span>ancestors<span class=\"token punctuation\">[</span><span class=\"token number\">0.</span><span class=\"token number\">.2</span><span class=\"token punctuation\">]</span>  <span class=\"token comment\"># => [EnthusiasticGreetings, MyClass, Object]</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>greet        <span class=\"token comment\"># => \"Hey, hello!\"</span></code></pre></div>\n<ul>\n<li>Arounded Aliases에 대한 현대적인 대안인 prepended wrapper를 사용</li>\n<li>MyClass의 조상 체인에서 MyClass#greet보다 낮아서 재정의가 잘 된다.</li>\n</ul>\n<h2>교훈</h2>\n<ul>\n<li>이 책을 통해 메타프로그래밍이 얼마나 편리하고 우아하고 멋진지에 대해 배웠다</li>\n<li>하지만 alias<em>method</em>chain에 대한 이야기는 경고에 가깝다.</li>\n<li>메타프로그래밍 코드는 때때로 복잡해질 수 있으며 심지어 더 전통적이고 단순한 기술을 간과하게 만들 수 있다.</li>\n<li>메타프로그래밍을 피하고 평범한 구식 OOP을 사용할 수 있다.</li>\n<li>코드를 너무 똑똑하게 만드려는 유혹에 저항하라는 교훈</li>\n<li>메타프로그래밍보다 목표를 달성하는 더 간단한 방법이 있는지 자문해본다.</li>\n</ul>","frontmatter":{"title":"M Ruby - 11.alias_method_chain의 흥망성쇠","date":"May 25, 2021","update":"May 25, 2021","tags":["ruby","book"],"series":"Metaprogramming Ruby"},"fields":{"slug":"/metaprogramming-ruby-11/","readingTime":{"minutes":3.625}}},"seriesList":{"edges":[{"node":{"id":"34257cb7-20bf-52a1-a751-44435c07aa96","fields":{"slug":"/metaprogramming-ruby-1/"},"frontmatter":{"title":"M Ruby - 1"}}},{"node":{"id":"3ab153c7-ef8e-5540-a0ec-ee7551892012","fields":{"slug":"/metaprogramming-ruby-2/"},"frontmatter":{"title":"M Ruby - 2. The Object Model"}}},{"node":{"id":"ab0c5e49-f893-5aaf-8315-c183e6f9df3c","fields":{"slug":"/metaprogramming-ruby-3/"},"frontmatter":{"title":"M Ruby - 3. Methods"}}},{"node":{"id":"ba539d0b-e3b6-507e-90b2-12083666ad46","fields":{"slug":"/metaprogramming-ruby-4/"},"frontmatter":{"title":"M Ruby - 4. Blocks"}}},{"node":{"id":"10646ae4-ced4-5411-87f6-7011a8f5c108","fields":{"slug":"/metaprogramming-ruby-5/"},"frontmatter":{"title":"M Ruby - 5. Class Definitions"}}},{"node":{"id":"9d128593-da43-521b-832e-ff48a726844c","fields":{"slug":"/metaprogramming-ruby-6/"},"frontmatter":{"title":"M Ruby - 6. Code That Writes Code"}}},{"node":{"id":"02c9824b-fff1-5517-bcd6-eb7690b1fc5a","fields":{"slug":"/metaprogramming-ruby-9/"},"frontmatter":{"title":"M Ruby - 9. The Design of Active Record"}}},{"node":{"id":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","fields":{"slug":"/metaprogramming-ruby-10/"},"frontmatter":{"title":"M Ruby - 10. Active Support's Concern Module"}}},{"node":{"id":"b76117b8-cdf6-5fdb-a207-d3bada809e8d","fields":{"slug":"/metaprogramming-ruby-11/"},"frontmatter":{"title":"M Ruby - 11.alias_method_chain의 흥망성쇠"}}},{"node":{"id":"6d902f10-0216-599c-8523-7c663a9a2027","fields":{"slug":"/metaprogramming-ruby-12/"},"frontmatter":{"title":"M Ruby - 12. Attribute Methods의 진화"}}}]},"previous":{"fields":{"slug":"/metaprogramming-ruby-10/"},"frontmatter":{"title":"M Ruby - 10. Active Support's Concern Module"}},"next":{"fields":{"slug":"/metaprogramming-ruby-12/"},"frontmatter":{"title":"M Ruby - 12. Attribute Methods의 진화"}}},"pageContext":{"id":"b76117b8-cdf6-5fdb-a207-d3bada809e8d","series":"Metaprogramming Ruby","previousPostId":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","nextPostId":"6d902f10-0216-599c-8523-7c663a9a2027"}},"staticQueryHashes":[]}