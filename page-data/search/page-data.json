{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"처리율 제한 장치(rate limiter)란? 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다. 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다. 요청 횟수가 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)된다. 오픈 API나 외부에 특정 API를 제공하는 서비스의 경우 시간당 …","fields":{"slug":"/rate-limit/"},"frontmatter":{"date":"January 27, 2022","title":"처리율 제한 Rate Limit","tags":["redis","backend"]},"rawMarkdownBody":"\n## 처리율 제한 장치(rate limiter)란?\n\n- 클라이언트 또는 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치이다.\n- 특정 기간 내에 전송되는 클라이언트의 요청 횟수를 제한한다.\n- 요청 횟수가 임계치(threshold)를 넘어서면 추가로 도달한 모든 호출은 처리가 중단(block)된다.\n- 오픈 API나 외부에 특정 API를 제공하는 서비스의 경우 시간당 몇 회 호출이나 하루에 몇 회 호출 등의 제한을 걸어두곤 한다.\n\n## 왜 처리율 제한이 필요한가??\n\n- DoS(Denial of Service) 공격에 의한 자원 고갈을 방지할 수 있다. 과한 트래픽으로 부터 서비스를 보호한다.\n- 비용을 절감한다. 추가 요청에 대한 처리를 제한하면 서버를 많이 두지 않아도 되고, 우선순위가 높은 API에 더 많은 자원을 할당할 수 있다.\n- 초과하는 횟수에 따라 과금하는 비즈니스 모델로 활용이 가능하다.\n- 서버 과부하를 막는다. 봇애서 오는 트래픽이나 사용자의 잘못된 이용 패턴으로 유발된 트래픽을 걸러내는데 사용 가능\n\n## 처리율 제한 장치의 위치\n\n### 서버에서의 처리율 제한\n\n- 처리하고자 하는 조건에 따라 서버측에서 제한을 건다.\n\n### 미들웨어에서의 처리율 제한\n\n- 미들웨어에서 API 서버로 가는 요청을 통제한다.\n- 요청이 너무 많이오면 429 code (Too many requests)를 리턴해준다.\n  ![](2022-01-28-01-14-01.png)\n\n### 클라이언트에서의 처리율 제한 장치\n\n- 클라이언트의 요청은 쉽게 위변조가 가능해서 안정적으로 처리율 제한을 걸 수 없다.\n- 하지만 꼭 클라이언트가 어플이나 브라우저가 아닌 서버일 수 있음 (소비자)\n- 제공자는 그냥 거절하면 그만이지만 클라이언트에서는 다양한 방법을 사용 가능\n  - 다시 요청할 수 있을 때까지 대기\n  - 일정 시간 기다린 후 그때도 통과를 못한다면 타임아웃 처리\n  - 요청 취소\n\n## 처리율 제한 알고리즘\n\n### 1. Token Bucket\n\n- 토큰 버킷은 지정된 용량을 갖는 컨테이너이고, 이 버킷에는 설정된 양의 토큰이 주기적으로 채워진다.\n- 토큰이 꽉 차있으면 더 이상 토큰은 추가되지 않는다.\n- 요청이 들어오면 버킷에 토큰이 있는지 확인한다.\n  - 충분한 토큰이 있으면 하나의 토큰을 버리고 요청을 처리한다.\n  - 토큰이 없으면 요청은 버려진다.\n\n![](2022-01-28-01-53-33.png)\n\n- 가장 간단하고 보편적으로 쓰인다.\n- 통상적으로 엔드포인트마다 별도의 버킷을 둔다.\n  - IP별로 처리율을 제한하고 싶다면 IP주소마다 버킷을 하나씩 할당한다.\n  - 시스템의 처리율을 제한하고 싶다면 모든 요청이 하나의 버킷을 공유하도록 한다.\n- 버킷의 크기, 토큰 공급률을 인자로 받는다\n\n#### 장점\n\n- 구현이 쉽다.\n- 메모리 사용 측면에서도 효율적이다.\n- 짧은 시간에 집중되는 트래픽도 처리 가능하다. 버킷에 남은 토큰이 있기만 하면 요청은 시스템에 전달된다.\n\n#### 단점\n\n- 버킷의 크기와 토큰 공급률이라는 인자를 적절하게 튜닝하는게 까다롭다.\n\n### 2. Leaky Bucket\n\n- 요청이 도착하면 큐가 가득 차 있는지 본다. 빈 자리가 있는 경우에는 큐에 요청을 추가한다.\n- 큐가 가득 차 있는 경우에는 새 요청은 버린다.\n- 지정된 시간마다 큐에서 요청을 꺼내어 처리한다.\n\n![](2022-01-28-02-35-24.png)\n\n- 토큰 버킷 알고리즘과 비슷하지만 요청 처리율이 고정되어있다.\n- 보통 FIFO로 구현한다.\n- 버킷 크기, 처리율을 인자로 받는다.\n\n#### 장점\n\n- 큐의 크기가 제한되어 있어 사용량 측면에서 효율적이다.\n- 고정된 처리율을 갖고 있으므로 안정적인 출력이 가능하다.\n\n#### 단점\n\n- 단시간에 많은 트래픽이 몰리는 경우 큐에는 오래된 요청들이 쌓이게 되고, 그 요청들을 제때 처리 못하면 최신 요청들이 버려진다.\n- 버킷 크기, 처리율을 튜닝하기 까다롭다.\n\n### 3. Fixed Window Counter\n\n- 타임라인을 고정된 간격의 window로 나누고 각 window마다 counter 를 붙인다.\n- 요청이 접수될 때마다 이 counter값은 1씩 증가한다.\n- 이 counter 값이 threshold 에 도달하면 새로운 요청은 새 윈도가 열릴 때까지 버려진다.\n\n![](2022-01-28-03-00-13.png)\n![](2022-01-29-22-12-32.png)\n\n- 매 초마다 할당량 이상이 오면 초과분은 버려진다.\n- 이 알고리즘의 가장 큰 문제는 경계 시간대에 몰리면 window에 할당된 양보다 더 많은 요청이 처리될 수 있다.\n\n#### 장점\n\n- 메모리 효율이 좋다.\n- 이해하기 쉽다.\n- window가 닫히는 시점에 카운터를 초기화하는 방식은 특정한 트래픽 패턴을 처리하기에 적합하다.\n\n#### 단점\n\n- 경계에서 일시적으로 많은 트래픽이 몰리는 경우 기대했던 시스템의 처리 한도보다 많은 양의 요청을 처리해야한다.\n\n### 4. Sliding Window Log\n\n- 요청의 타임스탬프를 레디스의 sorted set같은 캐시에 보관한다.\n- 새 요청이 오면 만료된 타임스탬프는 제거한다.\n  - 만료된 타임스탬프는 그 값이 현재 윈도의 시작 시점보다 오래된 타임스탬프를 말한다.\n- 새 요청의 타임스탬프를 로그에 추가한다.\n- 로그의 크기가 허용치보다 같거나 작으면 요청을 시스템에 전달한다. 그렇지 않은 경우에는 처리를 거부한다.\n\n![](2022-01-29-22-14-39.png)\n\n- 3의 경계에 편향한 트래픽에서의 문제를 대응하기 위한 알고리즘이다.\n\n#### 장점\n\n- 어느 순간의 윈도를 보더라도 허용되는 요청의 개수는 시스템의 처리율 한도를 넘지 않는다.\n\n#### 단점\n\n- 각 요청에 대한 타임스탬프를 보관하기 때문에 메모리를 많이 사용한다.\n\n### 5. Sliding Window Counters\n\n* 현재 윈도에서의 요청 수 + 직전 윈도에서의 요청 수 * 이동 윈도와 겹치는 비율\n\n![](2022-01-30-00-05-46.png)\n\n* 고정 윈도 카운터 알고리즘과 슬라이딩 윈도를 결합한 알고리즘\n\n#### 장점\n\n* 이전 시간대의 평균 처리율에 따라 현재 윈도의 상태를 계산하므로 짧은 시간에 몰리는 트래픽에도 잘 대응한다.\n* 메모리 효율이 좋다.\n\n#### 단점\n\n* 직전시간대에 도착한 요청이 균등하게 분포되어 있다고 가정한 상태에서 추정치를 계산하므로 다소 느슨하다.\n* 하지만 그렇게 심각한 문제는 아님\n\n## Redis를 이용한 구현 생각해보기\n\n* 특정 기간에 n회 라는 제한\n* api가 여러개라면 api의 종류를 key로 넣는다.\n  * api:posts\n* 유저별로 개수를 제한한다면 user id 를 넣는다.\n  * api:posts:123 \n* 특정 기간의정보. \n  * 윈도를 어떻게 설정할 것이냐에 따라 키가 달라짐\n* 5분마다 n회라면?\n  * api:posts:123:202201271005\n  * api:posts:123:202201271010\n  * api:posts:123:202201271015\n* value 는 호출 수\n\n## References\n\n- https://engineering.linecorp.com/ko/blog/high-throughput-distributed-rate-limiter/\n- https://dev.to/swyx/networking-essentials-rate-limiting-and-traffic-shaping-43ii\n- https://hechao.li/2018/06/25/Rate-Limiter-Part1/\n"},{"excerpt":"단일 장애 지점(Single Point Of Failure)이란? 시스템 구성 요소 중에서, 동작하지 않으면 전체 시스템이 중단되는 요소를 말한다. 이중화가 되어있지 않은 요소라면 SPOF일 가능성이 높다. 장애회복성을 위해서 SPOF가 없어야한다. SPOF의 예시 단일 서버 하나의 API 서버에 하나의 DB 서버를 사용하고 있는 상황\n API 서버에 장…","fields":{"slug":"/single-point-of-failure/"},"frontmatter":{"date":"January 25, 2022","title":"단일 장애 지점(SPOF)이란? Single Point of Failure","tags":["infra"]},"rawMarkdownBody":"\n## 단일 장애 지점(Single Point Of Failure)이란?\n\n- 시스템 구성 요소 중에서, 동작하지 않으면 전체 시스템이 중단되는 요소를 말한다.\n- 이중화가 되어있지 않은 요소라면 SPOF일 가능성이 높다.\n- 장애회복성을 위해서 SPOF가 없어야한다.\n\n## SPOF의 예시\n\n- 단일 서버\n\n  - 하나의 API 서버에 하나의 DB 서버를 사용하고 있는 상황\n    ![](2022-01-25-19-23-17.png)\n\n### API 서버에 장애가 난다면?\n\n![](2022-01-25-19-48-49.png)\n\n- 다른 시스템 요소들과 관계 없이 전체 시스템이 먹통된다. \n\n### DB 서버에 장애가 난다면?\n\n![](2022-01-25-19-49-04.png)\n\n- 이 역시 SPOF이다.\n\n### Network의 Bandwidth 한계\n\n![](2022-01-25-21-20-39.png)\n\n- 10G 스위치에 10Gbps 이상의 데이터가 전달된다면, Capacity를 넘어가는 순간부터 패킷 드랍이 발생한다.\n- Switch도 이중화가 필요하다.\n\n### 서버에 연결된 인터넷 망이 장애가 난다면?\n\n- 단일 인터넷망을 사용하면 이 또한 SPOF이다.\n\n### 이 외에도 많은 단일화 되어있는 요소들이 SPOF이다.\n\n## SPOF방지\n\n- API서버를 늘려보자\n\n![](2022-01-25-19-47-11.png)\n\n- API 서버 한 대에 에러가 나도 서비스가 가능하다.\n- 하지만 여전히 DB서버는 SPOF이다.\n- DB서버 또한 이중화를 한다.\n\n![](2022-01-25-21-02-56.png)\n\n- 이 외에도 Switch, Route 등의 서버 외의 하드웨어 부분에 SPOF가 발생할 수 있다.\n\n\n- 이러한 SPOF의 방지와 서비스의 복원력에는 당연하게도 큰 비용이 뒤따른다.\n  - 서버 및 스토리지의 이중화\n\n## References\n\n- 위키피디아 - https://ko.wikipedia.org/wiki/%EB%8B%A8%EC%9D%BC_%EC%9E%A5%EC%95%A0%EC%A0%90\n\n- https://blog.gigamon.com/2018/08/31/understanding-single-points-of-failure/\n\n- https://searchdatacenter.techtarget.com/definition/Single-point-of-failure-SPOF\n\n  \n"},{"excerpt":"한 것, 배운 점, 잘한 점 TickTick에서 Focus To Do로 테스크관리 도구를 변경했다. 뽀모도르랑 같이 테스크를 관리할 수 있어서 좋은 것 같다. 카모 면접을 봤는데 메일에서는 코딩 인터뷰라고 해서 알고리즘만 겁나 풀었다... 하지만 직무면접이였다. 흔한 자기소개 하나 준비하지 못한 나는 ...... OMG.... 그래도 대답은 얼추 다 한 …","fields":{"slug":"/week-3-2022-retrospective/"},"frontmatter":{"date":"January 23, 2022","title":"3 주차 회고 [2022]","tags":["회고"]},"rawMarkdownBody":"\n## 한 것, 배운 점, 잘한 점\n\n- TickTick에서 Focus To Do로 테스크관리 도구를 변경했다. 뽀모도르랑 같이 테스크를 관리할 수 있어서 좋은 것 같다.\n- 카모 면접을 봤는데 메일에서는 코딩 인터뷰라고 해서 알고리즘만 겁나 풀었다...\n  - 하지만 직무면접이였다. 흔한 자기소개 하나 준비하지 못한 나는 ...... OMG....\n  - 그래도 대답은 얼추 다 한 것 같은데 준비가 안 된 상태라 아쉽다.\n- 스프링을 찔끔 손대보는 중이다. 생각보다 방대하다... \n\n\n## 개선할 점\n\n* 블로그 글도 쓰고 알고리즘도 더 해야겠다\n\n## 생각\n\n* 많은 경험을 했다고 생각했지만  아녔다.  자기 객관화가 이제 좀 되는 것 같다. \n\n"},{"excerpt":"Paste for Mac 클립보드의 히스토리를 관리할 수 있는 Paste 앱이다. 내가 기기에서 복사했던 () 기록, 이에 대한 분류 및 검색 기능을 제공한다.  MacOS / IOS 에서 사용 가능하며 구독형으로 21'01.13 기준으로 13,500₩/year 이다. 기능 클립보드 히스토리 기록  복사 () 를 했던 기록을 저장하고 설정해놓은 단축키( …","fields":{"slug":"/paste/"},"frontmatter":{"date":"January 13, 2022","title":"[추천] Paste 클립보드 히스토리 앱","tags":["추천"]},"rawMarkdownBody":"\n![Paste for Mac](https://pasteapp.io/_next/image?url=%2Fimages%2Fpaste-mac-icon.png&w=384&q=75)\n\n- 클립보드의 히스토리를 관리할 수 있는 [Paste](https://pasteapp.io/) 앱이다. 내가 기기에서 복사했던 (`ctrl+c`) 기록, 이에 대한 분류 및 검색 기능을 제공한다. \n- MacOS / IOS 에서 사용 가능하며 구독형으로 21'01.13 기준으로 **13,500₩/year** 이다.\n\n## 기능\n\n### 클립보드 히스토리 기록\n\n![](2022-01-13-18-09-07.png)\n\n- 복사 (`ctrl+c`) 를 했던 기록을 저장하고 설정해놓은 단축키( Default : `cmd+shift+v`) 를 누르면 사진과 같은 리스트가 표시된다. 리스트를 보고 원하는 기록을 선택하면 붙여넣기가 된다.\n- `cmd + 1..9` 으로 바로 붙여넣을 수도 있다. `shift + cmd + 1..9` 으로는 Plain Text로 붙여넣는다.\n\n![](2022-01-13-18-13-02.png)\n\n- 복사한 컨텐츠가 링크라면 자동으로 메타데이터를 긁어와서 미리보기를 보여주기도 한다. 또한 복사 기록에 대한 저장 기간도 설정할 수 있다.\n\n### 검색기능\n\n![](2022-01-13-18-16-34.png)\n\n- 돋보기 모양을 누르거나 Paste를 활성화한 후에 `cmd+f` 를 누르면 검색 기능을 사용할 수 있다.\n- 기본적으로 **내용에 대한** 검색도 가능하지만, 복사한 **컨텐츠의 형식**과 복사한 **어플리케이션으로**도 **검색**이 가능하다.\n\n#### ex\n\n![](2022-01-13-18-20-24.png)\n\n### Pin\n\n![](2022-01-13-18-21-43.png)\n\n- 사진의 오른쪽 위에 `+` 를 눌러서 pin board를 만들고 복사한 컨텐츠를 드래그해서 해당 pin board에 넣어둘 수 있다.\n- 자주 쓰는 코드나 텍스트 템플릿 등을 저장하고 쓰면 편하다!\n\n### Paste Stack\n\n![](2022-01-13-18-31-39.png)\n\n- 복사 붙여넣기를 특정 순서로 텍스트, 이미지, 링크 등 여러 항목을 동시에 붙여넣을 수 있는 기능이다. 사실 나는 불편해서 잘 안 쓰지만, 활용을 잘하면 좋을 것 같다.\n- 자세한 건 링크 참고 https://medium.com/pasteapp/copy-copy-copy-paste-paste-paste-56068d2150c2\n\n### IOS 및 Siri 지원\n\n- IOS 앱도 있고, 위젯을 사용하면 꽤나 편리하다.\n\n### macOs Monterey Shortcuts\n\n- 이건 사실 잘 모른다... 아직 빅서에서 업데이트를 안해서,....\n- 링크 참고! https://medium.com/pasteapp/paste-with-shortcuts-for-macos-monterey-f74b68bd7d91\n\n## 경험담\n\n## ![](2022-01-13-18-36-03.png)\n\n- 내가 이 앱을 설치한 건 19년 8월이었다. 여러 내용을 복사 붙여넣기 할 때 따로 `Typora`를 키거나 메모장을 켜서 잠시 복사한 내용을 저장해두다가 불편해서 관련 앱을 찾았다.\n\n![](2022-01-13-18-38-47.png)\n\n- 그때 당시에는 19,000원으로 한 2주 정도 Trial 기간을 줬는데 하루정도 쓰고 그냥 바로 결제했다. 내가 필요했던 기능을 너무 잘 제공해줬고 UI/UX 측면 다른 클립보드 히스토리 관리 앱들에 비해 압도적으로 편리했다.\n- 이 앱을 따라 한 무료 앱들이 매우 많았지만, 기능적으로나 성능적으로 원본 앱을 따라올 수 없었다.\n\n### 구독형으로 전환\n\n![](2022-01-13-18-51-28.png)\n\n- 20년 2월부터 Paste는 구독형으로 전환하였다.\n- 이전에 구매한 이들에게는 소정의 무료 기간을 줬지만, 반발이 꽤 심했다.. 구독으로 전환한다는 미디엄 글에 댓글이 다들 부정적인 의견이었고 삭제하고 다른 어플로 갈아탄다는 댓글이 대부분이었다.\n- 사실 이미 구매한 사람들은 업데이트하지 않으면 구독 없이 사용할 수 있었다.\n\n## My two cents\n\n일단 나는 소프트웨어를 사는 것에 있어서 최대한 돈을 아끼지 않으려고 한다. \n\n내 주변에서는 소프트웨어 혹은 게임을 돈 주고 구매하는 것에 대한 거부감을 갖고있는 사람이 많다.  개발자로써 조금 안타까운일이라고 생각한다.\n\n매번 어플을 살 땐 이 어플을 만들 때 든 개발자의 노고를 생각해보곤 한다. 이 어플을 만드는 개발자의 노동력의 대가로 생각했을 때 그 값이 맞을까? 라고 말이다.\n\n어떤 어플에 대한 아이디어에 필요성을 느끼곤 \"와 사이드 프로젝트로 할만한 주제인데?\" 하고 막상 검색해보면 너무나 잘 만든 앱이 있어서 기분 좋게 쓰곤 했기 때문이다. 아, 내가 만들었으면 몇 달은 걸렸을 텐데 하고 말이다.\n\n그래서 그런지 이 어플이 그 정도 값어치를 하는가? 에 대한 질문은 오히려 더 받아야 한다는 의견이었기도 하고, 구독형 전환 때문에 개발자들이 더 이 프로덕트에 집중하여 더 좋은 프로덕트로 개선이 된다면 좋다는 생각에 역시 바로 구독으로 전환하여 잘 사용하고 있다.\n\n## LINK\n\n* 공식 홈페이지 https://pasteapp.io/\n* App Store https://apps.apple.com/kr/app/paste-clipboard-manager/id967805235?l=en\n\n## Alternative\n\n* https://apps.apple.com/kr/app/upaste-clipboard-manager/id1503649026 - 무료\n* https://snark.github.io/jumpcut/ - 무료 OpenSource\n* https://apps.apple.com/app/copyclip-clipboard-history/id595191960 - 무료\n* https://apps.apple.com/app/copyclip-2-clipboard-manager/id1020812363 - 7.79$\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"excerpt":"한 것, 배운 점, 잘한 점 당마 과제로 가득 채운 한 주였다. 과제 내용 자체는 짧았다. 하지만 다 처음으로 돌아가서 하나하나 의문을 가지면서 짜려고 하다 보니 많이 늦어졌다. 뭔가 지난 몇 년을 다시 돌아보는 느낌인듯.. 개선할 점 알골을 풀어놓고 제출을 안 했다 solved.ac 54일 연속이 깨졌다 ㅜㅠ 생각 문득 불안해질 때가 있다.  어차피 먹…","fields":{"slug":"/week-1-2022-retrospective/"},"frontmatter":{"date":"January 08, 2022","title":"1 주차 회고 [2022]","tags":["회고"]},"rawMarkdownBody":"\n## 한 것, 배운 점, 잘한 점\n\n- 당마 과제로 가득 채운 한 주였다.\n  - 과제 내용 자체는 짧았다.\n  - 하지만 다 처음으로 돌아가서 하나하나 의문을 가지면서 짜려고 하다 보니 많이 늦어졌다.\n  - 뭔가 지난 몇 년을 다시 돌아보는 느낌인듯..\n\n\n## 개선할 점\n\n* 알골을 풀어놓고 제출을 안 했다 solved.ac 54일 연속이 깨졌다 ㅜㅠ\n\n## 생각\n\n* 문득 불안해질 때가 있다. \n* 어차피 먹고사는 건 문제없다고 되뇌고 집중을 유지해보자\n\n"},{"excerpt":"한 것, 배운 점, 잘한 점 프리랜서 포함 3년 반 다닌 회사를 퇴사를 했다. 고객사 프로젝트는 하고 있는 게 없어서 그냥 내가 하던 작업만 마무리하고 리드미 쓰고 인수인계 받으실 분에게 이틀잡고 인수인계 해드렸다. 앞으로 회사나 나나 잘 되었으면 좋겠다. ide를 전부다 intellij로 변경 중  단축키를 vscode keymap extension을 …","fields":{"slug":"/week-51-2021-retrospective/"},"frontmatter":{"date":"December 26, 2021","title":"51 주차 회고 [2021]","tags":["회고"]},"rawMarkdownBody":"\n## 한 것, 배운 점, 잘한 점\n\n- 프리랜서 포함 3년 반 다닌 회사를 퇴사를 했다.\n  - 고객사 프로젝트는 하고 있는 게 없어서 그냥 내가 하던 작업만 마무리하고 리드미 쓰고 인수인계 받으실 분에게 이틀잡고 인수인계 해드렸다.\n  - 앞으로 회사나 나나 잘 되었으면 좋겠다.\n\n- ide를 전부다 intellij로 변경 중 \n  - 단축키를 vscode keymap extension을 추가해서 쓸까 하다가도... vscode에서 atom keymap을 쓰다 습관이 고쳐지지 않았던 기억때문에 그냥 찾아보며 익숙해지는 중\n  - 역시 돈쓴 값어치를 한다\n  - 하지만 맥북 터질라함ㅜㅜ\n\n- 새로 배우는 것들과 먼 기억 속에서 지워져 새로운 느낌인 것들 다 배우는 재미가 있다.\n\n## 개선할 점\n\n- 잘 쉬었다 이제 달려어~~\n\n## 생각\n\n* 아쉽기도 하고 후련하기도 하고 참 복합적이다. 하지만 뒤돌아볼 시간이 아깝다. \n* 그동안 너무 정체되어있었다는 생각과 그래도 몇 년 전의 나보단 성장을 한 듯 한데? 하는 두 생각이 공존\n\n"},{"excerpt":"이전 글에서 HTTPS와 HTTP의 차이에 대해 알아봤다. HTTPS에서 보안 계층은 어떻게 동작하는지에 대해 좀 더 자세히 알아보자 SSL 인증서가 신뢰 할 수 있는 서버(사이트)임을 보장하는 방법 웹 브라우저가 서버에 접속할 때 서버는 먼저 인증서를 제공한다. 브라우저는 이 인증서를 발급한 CA가 자신이 갖고있는 CA의 리스트에 있는지를 확인한다. 있…","fields":{"slug":"/https-and-ssl-2/"},"frontmatter":{"date":"December 19, 2021","title":"HTTPS 와 SSL - 2","tags":["cs"]},"rawMarkdownBody":"\n* 이전 글에서 HTTPS와 HTTP의 차이에 대해 알아봤다.\n* HTTPS에서 보안 계층은 어떻게 동작하는지에 대해 좀 더 자세히 알아보자\n\n## SSL 인증서가 신뢰 할 수 있는 서버(사이트)임을 보장하는 방법\n\n1. 웹 브라우저가 서버에 접속할 때 서버는 먼저 인증서를 제공한다.\n2. 브라우저는 이 인증서를 발급한 CA가 자신이 갖고있는 CA의 리스트에 있는지를 확인한다.\n3. 있다면 해당 CA의 공개키를 이용해서 인증서를 복호화 한다.\n   * CA의 공개키로 복호화 가능 하다는 것은 해당 비공개 키로 암호화 된 것을 의미한다.\n4. 복호화에 성공하면 CA에 의해 발급된 인증서라는 것이 검토됨을 의미한다.\n\n### 그럼 사실 공개키만 있어도 복호화가 가능한거 아닌가?\n\n* 데이터를 보호하는 목적이 아니다 \n* 복호화 할 수 있다는 것은 그 데이터가 비공개키로 암호화 되었다는 것을 의미\n* 따라서 공개키가 데이터를 제공한 사람의 신원을 보장해주는 것\n* 이를 전자서명이라고 한다.\n\n## SSL의 동작 방식\n\n* 이전 글에서 간단하게 SSL은 암호화된 데이터를 전송하기 위해 공개키와 대칭키를 혼합해서 쓴다고 했다.\n  * 실제 데이터는 대칭키로 암호화 - ( 리소스가 적게 들어서 빠름 )\n  * 대칭키를 공개키 방식으로 암호화\n* 이에 대해 좀 더 자세히 알아보자\n\n### SSL Handshake\n\n1. Client Hello - 먼저 클라이언트가 서버에게 요청을 보낸다. 아래의 정보를 보낸다. \n\n   * 클라이언트에서 생성한 **랜덤 데이터**\n\n   * 클라이언트 사용 가능한 암호화 방식 목록 - 서로 지원하는 암호화 방식이 다를 수 있으므로 협상 해야함\n     * Cipher Suite 목록\n\n   * 세션 아이디 - 이미 SSL Handshake를 했다면 기존 세션을 사용한다. 이에 대한 식별자\n\n2. Server Hello - 위에 대한 응답을 준다.\n\n   * 서버에서 생성한 **랜덤 데이터**\n   * 서버가 선택한 암호화 방식\n     * 클라이언트의 암호화 방식 목록을 보고 서버에서도 사용할 수 있는 방식을 전달\n   * 인증서\n\n3. 클라이언트는 서버의 인증서를 확인하기위해 브라우저에 내장된 CA목록을 확인\n\n   * 목록에 있다면 내장된 CA의 공개키로 복호화, 성공 시 인증서가 보증된 것\n   * 없으면 경고\n   * **Pre-master secret**를 생성한다.\n   * 이후 이 **Pre-master secret**를  서버의 공개키로 암호화 해서 서버로 전송\n\n4. 서버는 클라이언트로부터 받은 정보로 **Session key**를 유도\n\n   *  **Pre-master secret** 복호화한다.\n   * **Client 랜덤 데이터, Server 랜덤 데이터** 와 함께 **Session Key**를 유도한다.\n   * 이 Session Key로 암호화된 데이터 통신을 한다.\n\n5. 핸드쉐이크 잘 되었다고 알리고 끝\n\n## Opinions\n\n* pre master secret, client random, server random, session 등 많은 키가 생성되고 사용되어서 많이 헷갈린다.\n* cloudflare 블로그에서 그림을 잘 그려놨다고 하던데 보러가야징\n\n\n\n\n\n\n\n## References\n\n- https://www.geeksforgeeks.org/secure-socket-layer-ssl/\n- https://opentutorials.org/course/228/4894\n- https://learningnetwork.cisco.com/s/question/0D53i00000Kt0q0/which-layer-of-the-osi-model-do-ssl-and-tls-belong-to\n- https://dokydoky.tistory.com/462\n"},{"excerpt":"한 것, 배운 점 요즘 TDD에 관해 공부하고 있다. 슬.. 퇴사각 잡아보는 중 잘한 점 꾸역꾸역 스터디 과제 다 했음 알골을 좀 덜 풀긴 했는데 하루도 놓친 적은 없다. 개선할 점 아 이거 써야지 하고 생각한 게 있지만 기억을 못했다 ㅜ 낭비되는 시간을 더 줄이자 생각 연말이지만 어차피 코로나 때문에 사람들 안 만나기도 하고, 더 집중해야겠다. 외로운 …","fields":{"slug":"/week-50-2021-retrospective/"},"frontmatter":{"date":"December 19, 2021","title":"50 주차 회고 [2021]","tags":["회고"]},"rawMarkdownBody":"\n## 한 것, 배운 점\n\n- 요즘 TDD에 관해 공부하고 있다.\n- 슬.. 퇴사각 잡아보는 중\n\n## 잘한 점\n\n- 꾸역꾸역 스터디 과제 다 했음\n- 알골을 좀 덜 풀긴 했는데 하루도 놓친 적은 없다.\n\n## 개선할 점\n\n- 아 이거 써야지 하고 생각한 게 있지만 기억을 못했다 ㅜ\n- 낭비되는 시간을 더 줄이자\n\n## 생각\n\n* 연말이지만 어차피 코로나 때문에 사람들 안 만나기도 하고, 더 집중해야겠다.\n* 외로운 싸움이 될 듯 흐그 ㅜㅠㅠㅜ\n\n\n\n"},{"excerpt":"https에 대해서 certbot 혹은 aws acm으로 SSL 인증서를 적용 시키는 것 외에 제대로 된 개념을 알고있지 못했다. 그냥 보안이 좋다더라? 정도밖에.. 이참에 알아보자 HTTP - HyperText Transfer Protocol 데이터를 주고받을 수 있는 프로토콜 ( 규칙 ) 클라이언트와 서버 사이에 이루어지는 요청와 응답 프로토콜 주로 …","fields":{"slug":"/https-and-ssl/"},"frontmatter":{"date":"December 12, 2021","title":"HTTPS 와 SSL","tags":["cs"]},"rawMarkdownBody":"\n- https에 대해서 certbot 혹은 aws acm으로 SSL 인증서를 적용 시키는 것 외에 제대로 된 개념을 알고있지 못했다.\n- 그냥 보안이 좋다더라? 정도밖에..\n- 이참에 알아보자\n\n# HTTP - HyperText Transfer Protocol\n\n- 데이터를 주고받을 수 있는 프로토콜 ( 규칙 )\n- 클라이언트와 서버 사이에 이루어지는 요청와 응답 프로토콜\n- 주로 TCP를 이용한다.\n  - ~~HTTP/3 부터는 UDP를 쓴다는데 왜 그런걸까? 글 거리 하나 추가...~~\n- 비연결성 프로토콜이다.\n- HTTP에서는 전송되는 정보가 암호화되지 않는다.\n- 서버와 클라이언트가 서로 주고받는 메시지를 감청당하기 쉬움\n- 기본 포트 80\n\n# HTTPS - HTTP + Secure\n\n- HTTP에서 보안이 강화된 버전\n- HTTPS에서는 SSL( Secure Sockets Layer ) 을 사용한다.\n- 클라이언트와 서버간의 메시지를 암호화 한다!\n- 기본 포트 443\n\n![](2021-12-13-01-53-32.png)\n\n* 그림과 같이 Application Layer와 Transport Layer 사이에 위치\n* Application Layer에서 받은 데이터를 암호화하여 TCP로 전달\n* TCP에서 받은 데이터는 복호화하여 Application에 전달한다\n* TCP에서는 SSL을 Application처럼, Application에선  SSL을 TCP처럼 인식한다.\n  * 기존 전달 방식 그대로 사용하게 됨\n\n보안 계층을 하나 둬서 암/복호화를 하여 안전하게 메시지를 전달한다.\n\n# SSL과 TLS\n\n- SSL - Secure Sockets Layer / TSL - Transport Layer Security\n- TSL의 과거명칭이 SSL이며 같은 말임 근데 SSL이 더 많이 쓰인다.\n- 데이터를 안전하게 전송하기 위한 암호화 통신 프로토콜\n\n암호화를 해서 안전하게 만든다는 것은 알겠다. 하지만 어떻게 암호화를 해서 안전하게 만든다는 것일까?\n\n## SSL에서 사용하는 암호화\n\n### 1. 대칭키 방식\n\n- 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식\n- 발신자와 수신자가 모두 공유키를 갖고있어야 한다.\n- 공유키가 노출되면 위험하다.\n- 적은 컴퓨터 자원을 사용, 효율적\n\n### 2. 공개키 암호화 방식\n\n- 개인 키 ( Private key, 비공개 키 ), 공개 키 ( Public key )를 이용한다.\n- 공개키로 암호화 하고 비공개키로 복호화 할 수 있다.\n- 공개키는 노출이 되어도 상관 없다.\n- 계산하는데 복잡하고 자원사용도가 높다.\n\n### 3. 공개키와 대칭키를 혼합해서 사용하는 SSL\n\n- 공개키 암호화 방식은 리소스를 많이 잡아먹는다고 했다.\n- 따라서 실제로 SSL에서는 대칭키와 공개키를 **혼합**하여 사용\n- 클라이언트와 서버가 주고받는 정보는 **대칭키** 방식으로 암호화\n- 위에서 **사용할 대칭키**는 **공개키 방식**으로 암호화해서 주고 받음\n\n### 4. 공개키 암호화 방식의 문제 - CA 그리고 SSL 인증서\n\n- 공개키가 진짜인지 가짜인지 증명할 수가 없다.\n- 도중에 해커가 공개키를 바꿔치기 했을 수도 있다.\n- 따라서 인증 기관 ( Certificate Authority - CA )이 발급한 공개키 증명서를 사용한다.\n  1. 인증 기관에 서버의 공개키를 제출한다\n  2. 인증 기관에서는 제출된 공개키에 인증기관의 비밀키로 디지털 서명을 하여 공개키 인증서를 만든다.\n  3. 서버는 이 공개키 인증서를 클라이언트에 보낸다.\n  4. 클라이언트는 인증기관의 공개키를 사용하여 인증서를 복호화 한다.\n- 각 인증기관의 리스트와 공개키들은 클라이언트의 브라우저에 이미 저장되어있다.\n- 따라서 클라이언트는 서버에서 보내준 공개키의 신뢰성을 보장할 수 있다.\n\n# opinion\n\n* HTTPS는 HTTP과 달리 보안계층을 하나 둬서 보안이 더 좋다.\n* 보안 계층(SSL)은 TCP와 HTTP (application) 사이에 위치한다.\n* SSL은 공개키와 대칭키를 혼합해서 사용한다.\n* 신뢰 가능한 공개키를 사용하기 위해서 CA에서 발급해준 인증서를 사용한다.\n* 생각보다 길어졌다 글을 좀 나누도록 하겠다.\n\n++ 사실 보안 계층이 OSI 7 계층에서 어디에 위치한걸까 고민했다. \n\n[조금 구글링을 해봤는데](https://learningnetwork.cisco.com/s/question/0D53i00000Kt0q0/which-layer-of-the-osi-model-do-ssl-and-tls-belong-to)  OSI 7계층이 명확하게 일치하는 모델은 아니라는 의견도 있었고\n\n[Session Layer](https://security.stackexchange.com/questions/25568/how-valid-is-this-statement-ssl-sit-between-application-layer-and-network-layer)라는 의견, [Presentation Layer](https://www.techtarget.com/searchnetworking/definition/OSI) Transport Layer 라는 의견 등 다양했다.\n\n명확히 어느 한 계층에 속해서 동작하는 것이 아닌 Application Layer와 Transport Layer 사이의 독립적인 계층을 만들어서 동작하는 것 이라고 이해하고 넘어갔다\n\n# References\n\n- https://www.geeksforgeeks.org/secure-socket-layer-ssl/\n- https://opentutorials.org/course/228/4894\n- https://learningnetwork.cisco.com/s/question/0D53i00000Kt0q0/which-layer-of-the-osi-model-do-ssl-and-tls-belong-to\n"},{"excerpt":"한 것, 배운 점 루비 메타프로그래밍 관련하여 예전에 적어놨던 글을 다시 정비하고 게시했다. 부족해서 가려둔 글이 많은데 언제 다 올리나 싶다 새벽 4시에 지금 49주차 회고를 쓰고 있다 출근 언제하지...  잘한 점 딱히 없는 듯 하다. 개선할 점 뭐 했나 싶다 스터디 과제 마감까지 직전에 다 끝냈다. 생각 깊게 알아가는 재미가 있다. 회고를 따로 분리…","fields":{"slug":"/week-49-2021-retrospective/"},"frontmatter":{"date":"December 12, 2021","title":"49 주차 회고 [2021]","tags":["회고"]},"rawMarkdownBody":"\n## 한 것, 배운 점\n\n- 루비 메타프로그래밍 관련하여 예전에 적어놨던 글을 다시 정비하고 게시했다.\n- 부족해서 가려둔 글이 많은데 언제 다 올리나 싶다\n- 새벽 4시에 지금 49주차 회고를 쓰고 있다 출근 언제하지... \n\n## 잘한 점\n\n- 딱히 없는 듯 하다.\n\n## 개선할 점\n\n- 뭐 했나 싶다 스터디 과제 마감까지 직전에 다 끝냈다.\n\n## 생각\n\n- 깊게 알아가는 재미가 있다.\n- 회고를 따로 분리해서 보관해야하나 고민이다. 쿼리에서 필터만 해서 안 보이게 할까 아니면 완전히 분리를 할까...\n- 퇴사 고민을 하고있다. 회사에 남아있는 것 보다 혼자서 공부하는 게 더 성장이 빠를 것 같다.\n  - 회사 사람들하고 스터디를 3개정도 하고있는데 이게 쫌 아쉽다.\n  - 알골, cs, 책 스터디 ( 리펙터링 )\n  - 알골은 유지 가능할 듯?\n\n"},{"excerpt":"ssh key를 비밀번호 없이 사용하는 경우가 많았다. 혹은 항상 쓰던 비밀번호를 썼다. 회사, 개인, 사이드플젝, 외주 등 각각 ssh-key를 따로 관리했는데 비밀번호를 안 쓰는 것에 죄책감을 느끼기 시작함 만약 노트북이 열린 채로 털리면 터미널 히스토리 보고 서버 접속 가능할 듯? 1password를 결제해서 쓰고 있는데 1password cli를 …","fields":{"slug":"/op-ssh/"},"frontmatter":{"date":"December 05, 2021","title":"1password + ssh key password","tags":["linux","terminal"]},"rawMarkdownBody":"\n- ssh key를 비밀번호 없이 사용하는 경우가 많았다. 혹은 항상 쓰던 비밀번호를 썼다.\n- 회사, 개인, 사이드플젝, 외주 등 각각 ssh-key를 따로 관리했는데 비밀번호를 안 쓰는 것에 죄책감을 느끼기 시작함\n- 만약 노트북이 열린 채로 털리면 터미널 히스토리 보고 서버 접속 가능할 듯?\n- 1password를 결제해서 쓰고 있는데 1password cli를 사용해서 어떻게 못 할까?\n\n라는 니즈에서 스크립트를 짜놓고 작년부터 썼는데 이제 글로 옮겨적기\n\n## 1password 란?\n\n- 1password는 패스워드를 관리하는 프로그램이다.\n- 패스워드 및 각종 신용카드 정보나 민감한 개인 정보들을 관리하고 쉽게 사용할 수 있다.\n- mac, window, android, iphone, 크롬 확장프로그램, cli에서도 사용 가능하다.\n- 모든 사이트의 비밀번호를 다르게 사용해도 1password를 사용해서 auto complete를 할 수 있다.\n\n## Need to be installed - expect, op\n\n- 1password cli ( op ), jq, expect 가 설치되어있어야 한다.\n\n### expect\n\n- **macos** - 맥에선 원래 expect가 설치 되어있다. ㅎㅎ\n- **ubuntu** - `sudo apt-get install expect`\n\n### 1password command line\n\n- [1password cli](https://1password.com/downloads/command-line/) 에서 설치!\n\n### jq\n\n- `brew install jq`\n\n## ssh-key 저장해두기\n\n1. 비밀번호를 굉장히 복잡하게 설정하거나 1password으로 만들어냅니다.\n\n2. `ssh-keygen` 을 통해 ssh-key를 하나 생성하고 비밀번호를 1.의 비밀번호로 설정합니다.\n\n3. 1password에 저장합니다.\n   - public key와 private key도 저장해두면 pc가 뿌셔져도 괜찮습니다.\n   - **tags를 꼭 ssh-key 로 해둡니다.**\n\n![](2021-12-05-20-09-58.png)\n\n## script\n\n- 아래 스크립트를 아무 곳에나 잘 위치 시키고 ( 나는 `~/.custom/op_ssh.sh` 로 해뒀음)\n- 실행 권한을 준다.\n\n  - `chmod +x 파일명.sh`\n\n- `alias` 를 설정한다.\n  - `alias op_ssh=~/.custom/op_ssh.sh`\n\n```sh\n#!/bin/bash\n\nif [ $# -eq 0 ]; then\n  echo \"ssh path 경로 없음\"\nelse\n  ssh_path=\"${1}\"\n  title=\"$(echo $ssh_path | tr '/' '\\n' | tail -n1)\"\n  uuid=$(op list items --tags ssh-key | jq --arg title \"$title\" '.[] | select(.overview.title == $title).uuid' | sed -e 's/^\"//' -e 's/\"$//')\n  if [ -z \"$uuid\" ]; then\n    echo \"Need 1password Sign In\"\n  else\n    password=$(op get item $uuid | jq '.details.sections[1].fields[] | select(.t == \"password\").v' | sed -e 's/^\"//' -e 's/\"$//')\n    expect <<EOL\n  spawn ssh-add $ssh_path\n  expect \"Enter passphrase for *\"\n  send \"$password\"\n  send \"\\n\"\n  expect \"Identity added: *\"\nEOL\n  fi\nfi\n\n```\n\n## 사용\n\n- op cli 로그인을 한다.\n- 로그인 하고자하는 키의 경로를 매개변수로 두고 커맨드 실행\n\n![](2021-12-05-20-31-19.png)\n\n## next?\n\n1. gist 올려두고 자동화\n\n2. 1password 비밀번호 입력도 불편하다, touch id로 안 되나?\n"},{"excerpt":"이번 주는 코테 준비로 가득 채운 한 주였다. 한 것, 배운 점 우리 프론트엔드 코드에서 관심사를 나눠놓는 방식이 과연 좋은 건가? 다른 방식은 없나?하고 많이 찾아봤다. https://itnext.io/what-are-front-end-service-layers-4dba95db21bb https://dev.to/mmcshinsky/a-simple-app…","fields":{"slug":"/week-48-2021-retrospective/"},"frontmatter":{"date":"December 04, 2021","title":"48 주차 회고 [2021]","tags":["회고"]},"rawMarkdownBody":"\n- 이번 주는 코테 준비로 가득 채운 한 주였다.\n\n## 한 것, 배운 점\n\n- 우리 프론트엔드 코드에서 관심사를 나눠놓는 방식이 과연 좋은 건가? 다른 방식은 없나?하고 많이 찾아봤다.\n  - https://itnext.io/what-are-front-end-service-layers-4dba95db21bb\n  - https://dev.to/mmcshinsky/a-simple-approach-to-managing-api-calls-1lo6\n- boj 문제 일주일동안 30문제정도 풀었다. 골드 1~3은 거의 시간초과로 못푼듯 ㅜ\n- 배민 커리어 코칭을 했다. 사실 정보를 얻는 것 보단 내가 하고있는 게 맞는지를 확인해보는 시간이었던 것 같다.\n\n## 잘한 점\n\n- 스터디 딱히 못 한 것 없이 잘 마무리했다. + 블로그 글을 작성함\n\n## 개선할 점\n\n- 디자인 패턴에 대해 더 공부해야겠다. GOF?\n\n- 네이버웹툰, 카카오웹툰 삭제해야겠다.\n\n  \n\n## 생각\n\n- 아직 혼자서 성장할 수 있는 여지가 많이 남아있었던 것 같다.\n- 급할 필요없다.\n"},{"excerpt":"당근메일 - 자신을 빠르게 성장시키는 '회고' 을 보고 주간 회고를 해봐야겠다고 마음먹었다. 일주일 단위로 하면 어느 정도 부담이 덜 하지 않을까? 매주 일요일 아침을 회고를 위한 시간으로 ! - 오늘은 일어나자마자 카페에서 가서 할 일 하느라... 적당히 한 것, 배운 점, 잘한 점이랑 개선할 점을 쓸까 한다. 사실 회사 일은 어느 정도까지 공개해도 되…","fields":{"slug":"/week-47-2021-retrospective/"},"frontmatter":{"date":"November 28, 2021","title":"47 주차 회고 [2021]","tags":["회고"]},"rawMarkdownBody":"\n- [당근메일 - **자신을 빠르게 성장시키는 '회고'**](https://stibee.com/api/v1.0/emails/share/KxPb9t2oAVziTFMbnZSyAOXiuE4Suw==) 을 보고 주간 회고를 해봐야겠다고 마음먹었다.\n- 일주일 단위로 하면 어느 정도 부담이 덜 하지 않을까?\n- 매주 일요일 아침을 회고를 위한 시간으로 ! - 오늘은 일어나자마자 카페에서 가서 할 일 하느라...\n- 적당히 한 것, 배운 점, 잘한 점이랑 개선할 점을 쓸까 한다.\n- 사실 회사 일은 어느 정도까지 공개해도 되는지 잘 모르겠다... 최대한 덜어내고 추상적으로 쓰는 방향으로\n\n## 한 것, 배운 점\n\n- ssh tunneling 으로 vpc안의 rds를 접근 해봤다\n- aws session manager를 통해 port forwarding을 해보고 proxy ec2안에서 socat으로 해당 포트와 rds 를 연결해봤음\n- 매번 ssh key의 비밀번호를 치기 힘들어서 만들어놓은 1password cli shell script가 더 귀찮아져서 swift 로 touch id를 써서 비밀번호 입력하는 소스를 짜보고 있다.\n- 스터디\n  - 매일 알고리즘을 풀었다.\n  - 객체지향의 사실과 오해 chapter 4까지 읽었다.\n  - CS study 운영체제 과제도 시간 내로 냈고 공부도 적당히 한 듯\n  - 데이터베이스 스터디 과제 시간 내로 잘 냄!\n- 블로그를 리뉴얼하고 레쥬메를 리뉴얼해보는 중!\n\n## 잘한 점\n\n- 이번 주는 스터디 딱히 못 한 것 없이 잘 마무리했다.\n- 힙서비 콘텐츠 챌린지를 통해 강제였지만 어쨌든 블로그 글을 작성함\n\n  - 아 이거 써야지 하고 메모만 해둔게 **33개** , quiver 메모는 **165개** .... 어지간히 안 했다...\n\n- 주말에 평소보다 일찍 일어나서 바로 나갔다. 집에 있으면 나태해진다.\n\n## 개선할 점\n\n- 손이 아파서 파라핀을 매일 하기로 했는데 한 번도 안 했다.,., ( 효과가 있는지는 모르겠음 )\n- 클라이밍을 최소 주 2회~3회 하기로 했는데 한 번밖에 못했다... 월욜에 하려다가 개발하는 게 막혀서 붙잡고 있다가 ㅜㅜ\n- 이력서를 써보기로 했는데 제대로 못 씀\n\n## 생각\n\n- 이직을 하던 안 하던 이력서를 분기마다 업데이트하고 시장에서 자신의 가치를 확인해보는 것이 좋다고 생각한다.\n- 과연 회사 입장에서 내가 매력적인 지원자가 맞을까?\n- 내가 여태까지 해 온 것을 복기해보고 모자란 것을 찾아본다. 내가 가고 있는 길이 맞는지를 한 번 돌아볼 필요가 있다.\n- 늘 이런 생각을 하고 돌아 볼 때마다 많이 모자란다고 느낀다.\n- 여태까지 너무 고여있던 것 아닌가 실패와 좌절을 겪어본 적 없으니 흐를 필요성을 못 느끼는 것 아닌가.\n"},{"excerpt":"새 블로그를  으로 배포하고 있다.  브랜치에 푸시가 되면 github action으로 빌드를 하고, gh-pages로 푸시를 한다. gh-pages으로 정적 페이지들이 올라가면 이를 블로그로 사용한다 ( ) 사용법은 대충 github action 만들고 세팅에서 사진처럼 설정하면 끝인데  문제 배포할 때 마다 Custom Domain 설정이 사라진다..…","fields":{"slug":"/gh-pages-cname/"},"frontmatter":{"date":"November 27, 2021","title":"gh-pages, custom domain(cname) 적용 안 될 때 (gatsby-gh-pages-action)","tags":["짧","팁","gatsby","github-action"]},"rawMarkdownBody":"\n새 블로그를 `gatsby-gh-pages-action` 으로 배포하고 있다.\n\n`main` 브랜치에 푸시가 되면 github action으로 빌드를 하고, gh-pages로 푸시를 한다.\n\ngh-pages으로 정적 페이지들이 올라가면 이를 블로그로 사용한다 ( `gmkseta.github.io`)\n\n사용법은 대충 github action 만들고 세팅에서 사진처럼 설정하면 끝인데\n\n```yaml\nname: CI\n\non:\n  push:\n    branches:\n      - main\n    paths-ignore:\n      - \"**/README.md\"\n\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          token: ${{ secrets.ACCESS_TOKEN }}\n          submodules: true\n\n      - uses: enriikke/gatsby-gh-pages-action@v2\n        with:\n          access-token: ${{ secrets.ACCESS_TOKEN }}\n          deploy-branch: gh-pages\n          skip-publish: false\n```\n\n![](2021-11-28-23-48-18.png)\n\n## 문제\n\n### 배포할 때 마다 Custom Domain 설정이 사라진다...?\n\n## 원인을 찾아보자.\n\n- github docs를 찾아봤더니 다음과 같은 글이 나왔다.\n\n![](2021-11-28-23-54-38.png)\n\n- 대충 읽어보자면 CNAME file에 저장이 된다는데....\n- 한번 gh-pages 브랜치를 살펴보자..\n\n![](2021-11-28-23-55-30.png)\n\n- 배포를 위해 빌드된 파일들이 들어가 있고, 잘 보니 CNAME 파일이 있다.\n\n![](2021-11-28-23-58-26.png)\n\n- 설정에서 Custom Domain을 추가하면 CNAME 파일이 생성되어 설정한 Custom Domain이 들어간다.\n\n- 하지만 gh-pages 브랜치는 배포용이어서 늘 강제푸시되는 브랜치이고....\n\n- main 브랜치에서는 CNAME이 없어서 설정은 빠지고, 설정해도 gh-pages브랜치만 반영이 된 것\n\n## 해결\n\n- main branch에 CNAME 파일 하나 추가 - 끗\n\n## References\n\n- https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/troubleshooting-custom-domains-and-github-pages#https-errors\n"},{"excerpt":"요즘 애플워치로 맥 비밀번호( Touch ID )를 대신 하는 재미가 있다. 1password 비밀번호가 상당히 긴데 다 안 치고 애플워치( Touch ID )로 쓰니 쾌감 터미널에서도 sudo를 사용할 때 비밀번호를 touch id로 하는 법은 없을까 하다 검색해봤다. 선 1줄요약 Mac에서 Touch ID로 암호 대신 sudo 인증하기 원래는  같이 …","fields":{"slug":"/sudo-with-touch-id/"},"frontmatter":{"date":"November 24, 2021","title":"터미널에서 비밀번호 말고 touch id로 sudo 쓰기","tags":["짧","macos","terminal"]},"rawMarkdownBody":"\n> - 요즘 애플워치로 맥 비밀번호( Touch ID )를 대신 하는 재미가 있다.\n> - 1password 비밀번호가 상당히 긴데 다 안 치고 애플워치( Touch ID )로 쓰니 쾌감\n> - 터미널에서도 sudo를 사용할 때 비밀번호를 touch id로 하는 법은 없을까 하다 검색해봤다.\n\n**선 1줄요약**\n\n```sh\ncurl -sL https://gist.githubusercontent.com/RichardBronosky/31660eb4b0f0ba5e673b9bc3c9148a70/raw/touchid_sudo.sh | bash\n```\n\n## Mac에서 Touch ID로 암호 대신 sudo 인증하기\n\n- 원래는 `sudo [command]` 같이 sudo 권한을 사용하려고 하면 비밀번호로 인증을 해야한다.\n\n![](2021-12-05-00-50-19.png)\n\n- 먼저 `/etc/pam.d/sudo` 파일을 수정해야하는데 읽기만 가능한 파일이라 변경해야한다.\n\n```sh\nsudo su\ncd /etc/pam.d\nchmod 755 sudo\n# or chmod u+w /etc/pam.d/sudo\n```\n\n- `sudo` 파일의 맨 윗 줄에 `auth sufficient pam_tid.so ` 을 추가한다.\n\n```sh\nvi sudo\n```\n\n```\n# sudo file\nauth       sufficient     pam_tid.so #  <<<< 이 부분을 추가합니다.\nauth       sufficient     pam_smartcard.so\nauth       required       pam_opendirectory.so\naccount    required       pam_permit.so\npassword   required       pam_deny.so\nsession    required       pam_permit.so\n```\n\n- 다시 읽기만 가능한 권한으로 변경해줍니다.\n\n```sh\nchmod 444 sudo\n# or chmod u-w sudo\n```\n\n끝!\n\n![](2021-12-05-01-12-12.png)\n\n<img src=\"2021-12-05-01-13-09.png\" style=\"zoom:50%;\" />\n\n* 애플워치에서도 잘 보입니다\n\n\n\n## Reference\n\n* https://apple.stackexchange.com/questions/259093/can-touch-id-for-the-mac-touch-bar-authenticate-sudo-users-and-admin-privileges/306324#306324\n"},{"excerpt":"예전에 누가 바이너리 세마포어와 뮤텍스의 차이가 뭐냐고 물었는데, 똑같은 거 아니냐 차이가 있나? 라고 답한 적이 있다. 요즘 os를 다시 공부하고 있는데 겸사겸사 알아보니 차이가 있더라... geeksforgeeks에서 본 글이 제일 잘 정리가 되어있어서 보고 한글로 다시 정리를 해보고 한번 생각을 해봤다. 바이너리 세마포어 - Binary Semaph…","fields":{"slug":"/26-difference-between-binary-semaphore-and-mutex/"},"frontmatter":{"date":"November 22, 2021","title":"Binary Semaphore vs Mutex","tags":["cs","os"]},"rawMarkdownBody":"\n예전에 누가 바이너리 세마포어와 뮤텍스의 차이가 뭐냐고 물었는데, 똑같은 거 아니냐 차이가 있나? 라고 답한 적이 있다.\n\n요즘 os를 다시 공부하고 있는데 겸사겸사 알아보니 차이가 있더라...\n\ngeeksforgeeks에서 본 글이 제일 잘 정리가 되어있어서 보고 한글로 다시 정리를 해보고 한번 생각을 해봤다.\n\n## 바이너리 세마포어 - Binary Semaphore\n\n- 값을 0과 1만 가지는 세마포어임\n- 상호 배제(mutual exclusion) 를 위해 신호 전달 메커니즘을 사용해서 잠금을 구현함\n- 세마포어가 0이면 잠겨있는 것이고, 1이면 잠금이 해제된 것\n\n## 뮤텍스 - Mutex\n\n- 상호 배제를 locking과 unlocking으로 제공\n- 하나의 스레드만 전체 버퍼와 함께 작업 가능\n\n## 둘의 차이는?\n\n| 바이너리 세마포어                                                                  | 뮤텍스                                                                |\n| ---------------------------------------------------------------------------------- | --------------------------------------------------------------------- |\n| 신호 전달 메커니즘 기반으로 동작                                                   | 잠금 메커니즘 기반으로 동작                                           |\n| 현재 스레드보다 우선순위가 높은 스레드가 바이너리 세마포어를 해제하고 잠글 수 있음 | 뮤텍스를 획득한 스레드는 크리티컬 섹션에서 나갈 때만 뮤텍스 해제 가능 |\n| 값은 `wait()` , `signal()` 에 따라 변경                                            | 값이 locked, unlocked 으로 수정                                       |\n| 여러 개의 스레드가 동시에 이진 세마포어를 획득 가능                                | 한 번에 하나의 스레드만 뮤텍스를 획득 가능                            |\n| 소유권이 없다                                                                      | 뮤텍스를 소유한 스레드만 잠금을 해제 가능하므로 소유권이 있음         |\n| 다른 스레드/프로세스가 잠금 해제가 가능하기 때문에 뮤텍스보다 빠르다.              | 획득한 스레드만 잠금 해제가 가능하므로 바이너리 세마포어보다 느리다.  |\n|                                                                                    |                                                                       |\n\n## 결론\n\n- 결국 둘은 메커니즘이 다르고 사용법, 소유권, 동작 방식이 다르다.\n- ~~하지만 아직도 좀 헷갈리는 것 같기도 하다. 검색해보면 mutex는 binary semaphore라고 써놓은 곳이 많았다. ㅠㅠ~~\n- 함수로써의 mutex가 아닌 상호배제라는 뜻으로 쓰인걸까...\n- 언뜻 보면 비슷해 보이지만 자세히 보면 다르다.\n\n### ETC...\n\n- 공부를 하다보니 내가 세마포어에 대해 제대로 알고있나 의심하게 되었다..\n- 세마포어는 여러 스레드/프로세스가 공유자원에 접근할 수 있게 하면서 어떻게 상호 배제를 지키는걸까?\n-\n\n### References\n\n- https://www.geeksforgeeks.org/difference-between-binary-semaphore-and-mutex/\n\n- https://jwprogramming.tistory.com/13\n"},{"excerpt":"Infrastructure as Code ( IaC ) 내가 IaC에 대해 알게된건 회사에서 aws의 강태호님과 미팅을 하게 되었을 때다. 기존에 회사에선 aws 인프라를 수동으로 관리하고 있었다 고객사의 프로젝트가 마무리되어서 인프라를 세팅해줄 때마다 aws console에 들어가서 수동으로 인프라를 세팅해줬다... 몇번 하다보니 귀찮아져서 문서화를 해…","fields":{"slug":"/23-InfraStructureAsCode/"},"frontmatter":{"date":"November 08, 2021","title":"Infrastructure as code","tags":[]},"rawMarkdownBody":"\n# Infrastructure as Code ( IaC )\n\n내가 IaC에 대해 알게된건 회사에서 aws의 강태호님과 미팅을 하게 되었을 때다.\n\n기존에 회사에선 aws 인프라를 수동으로 관리하고 있었다\n\n고객사의 프로젝트가 마무리되어서 인프라를 세팅해줄 때마다 aws console에 들어가서 수동으로 인프라를 세팅해줬다...\n\n몇번 하다보니 귀찮아져서 문서화를 해두고 사내 위키에 올려둔 뒤 가끔 다른 개발자 분들이 어려워 하실때 만 도와주러 갔다.\n\n하지만 이 방법도 내가 시간을 안쓸 뿐이지 다른 분들이 쓰게 만드는 해결책이였다.\n\nIaC에 대해 알게되고 테라폼 강의를 인프런에서 봤다. 거기서 강사님이 이런말을 한게 기억난다.\n\n> IaC의 제일 좋은 도입 시기는 IaC라는 것에 대해 아는 순간이다.\n\n그때 강의를 들을때나 지금이나 그리고 미래에도 이 말에 대해 전적으로 동의한다.\n\n## Infrastructure as Code(IaC) - 코드로 인프라를 관리\n\n수동 프로세스가 아닌 코드를 통해 인프라를 관리하고 [프로비저닝][1]하는 것을 말한다.\n\n즉 인프라 구성, 관리를 마치 소프트웨어를 프로그래밍하는 것 처럼 처리한다.\n\n버전 관리도 중요하다, 다른 소프트웨어 코드들 처럼 버전 관리 시스템을 이용해서 관리해야한다.\n\n## 수동으로 인프라를 관리했을 때의 단점\n\n- 서론에서 제 경험을 말했듯이 보통 메뉴얼을 만들고 관리를 할텐데 aws console이 업데이트되어 UI가 바뀐다면?\n  - 문서도 다시 업데이트를 해줘야함..\n- 기존에 구성되어있는 인프라에 대해 다른사람이 건드릴 일이 있다면?\n  - 문서화가 잘 되어있지 않다면 어디에 어떤 리소스가 있는지 하나하나 찾아봐야함\n- 똑같은 형태 혹은 비슷한 형태의 인프라를 재구성할 때 손으로 일일히 다시 ..\n  - 반복되는 노가다\n\n## 이를 해결해주는 IaC의 이점\n\n- 원래 인프라를 수동으로 [프로비저닝][1]하는 것은 시간이 많이 드는 일, 코드로 한 번 작성 해놓고나면 자동화가 된다.\n\n  - aws console이 업데이트가 되던 말던 코드는 그대로 사용 가능\n\n- IaC는 인프라의 구성 사양을 코드화하고 문서화함으로써 따로 인프라 구성 및 변경에 대한 문서화를 하지 않아도 된다\n\n  - 어디에 어떤 리소스가 있는지 코드를 통해 확인이 가능함\n  - 우리가 수동으로 직접 구성했을 때 누락하거나 잘못 설정하는 실수하는 경우를 방지\n\n- 일관성이 향상된다.\n- 복제가 쉽다.\n\n## IaC 도구들\n\n1. Terraform, Aws CloudFormation, Aws CDK\n\n2. Ansible, Chef, Puppet, Saltstack\n\n1과 2의 차이가 살짝 있다. 서로 다른 목적으로 만들어졌다\n\nTerraform과 CloudFormation ( 1번 )은 프로비저닝 도구이며, 2번은 구성 관리 도구이다.\n\n1번은 인프라를 처음부터 설정하고 구성하는 것 이고 2번은 이미 구성된 인프라를 업데이트한다.\n\n몇몇 기능들이 중복되는게 있긴 하지만 보통 1번과 2번을 같이 사용한다.\n\nTerraform으로 ec2를 띄우고 ansible로 해당 ec2에 필요한 패키지를 설치한다던지 하는 방식으로 말이다.\n\n~~나는 2 - terraform, cdk, ansible밖에 사용경험이 없어서 잘못 분류했을 수도 있다..~~\n\n[1]: https://ko.wikipedia.org/wiki/%ED%94%84%EB%A1%9C%EB%B9%84%EC%A0%80%EB%8B%9D \"프로비저닝\"\n"},{"excerpt":"대규모 시스템에서 메타크로그래밍을 사용할 때 어떤일이 발생하는지 여전히 궁금하다!! 이를 살펴보기 위해 Rails의 가장 인기 있는 기능중 하나인 attribute method에 대해 살펴본다. 참고로 모든 라인을 이해하려고 하지 말고 아이디어 만을 이해하려고 하자 Attribute Methods의 사용 위 처럼 데이터베이스에 tasks라는 테이블을 만든…","fields":{"slug":"/metaprogramming-ruby-12/"},"frontmatter":{"date":"May 31, 2021","title":"M Ruby - 12. Attribute Methods의 진화","tags":["ruby","book"]},"rawMarkdownBody":"\n* 대규모 시스템에서 메타크로그래밍을 사용할 때 어떤일이 발생하는지 여전히 궁금하다!!\n* 이를 살펴보기 위해 Rails의 가장 인기 있는 기능중 하나인 attribute method에 대해 살펴본다.\n* 참고로 모든 라인을 이해하려고 하지 말고 아이디어 만을 이해하려고 하자\n\n## Attribute Methods의 사용\n\n```ruby\nrequire 'active_record'\nActiveRecord::Base.establish_connection :adapter => \"sqlite3\",\n                                        :database => \"dbfile\"\nActiveRecord::Base.connection.create_table :tasks do |t|\n  t.string   :description\n  t.boolean  :completed\nend\n```\n\n* 위 처럼 데이터베이스에 tasks라는 테이블을 만든다면\n\n```ruby\nclass Task < ActiveRecord::Base; end\ntask = Task.new\ntask.description = 'Clean up garage'\ntask.completed = true\ntask.save\ntask.description    # => \"Clean up garage\"\ntask.completed?     # => true\n```\n\n* `ActiveRecord::Base` 에서 상속하는 빈 Task 클래스를 정의할 수 있고, 해당 클래스의 객체를 사용하여 데이터베이스와 상호작용이 가능하다.\n* 2개의 쓰기 accessor( 이하 접근자 )\n  *  description = , completed = \n* 1개의 읽기 접근자\n  * description\n* 1개의 쿼리 접근자\n  * completed?\n* 4개의 접근자 모두 정의한 것이 아닌 Active Record에서 generated된 것이다.\n* 이러한 자동 생성 접근자를 attributes methods라고 한다.\n\n## 복잡한 역사\n\n### Rails 1: 간단한 시작\n\n* 첫 버전에서는 단지 몇 줄의 코드\n\n```ruby\nmodule ActiveRecord\n  class Base\n    def initialize(attributes = nil)\n      @attributes = attributes_from_column_definition\n      # ...\n    end\n    def attribute_names\n      @attributes.keys.sort\n    end\n    alias_method :respond_to_without_attributes?, :respond_to?\n    def respond_to?(method)\n      @@dynamic_methods ||= attribute_names +\n                        attribute_names.collect { |attr| attr + \"=\" } +\n                        attribute_names.collect { |attr| attr + \"?\" }\n      @@dynamic_methods.include?(method.to_s) ? true : \n      respond_to_without_attributes?(method)\n    end\n    def method_missing(method_id, *arguments)\n      method_name = method_id.id2name\n      if method_name =~ read_method? && @attributes.include?($1)\n        return read_attribute($1)\n      elsif method_name =~ write_method?\n        write_attribute($1, arguments[0])\n      elsif method_name =~ query_method?\n        return query_attribute($1)\n      else super\n      end \n    end\n    def read_method?()  /^([a-zA-Z][-_\\w]*)[^=?]*$/ end\n    def write_method?() /^([a-zA-Z][-_\\w]*)=.*$/    end\n    def query_method?() /^([a-zA-Z][-_\\w]*)\\?$/     end\n    def read_attribute(attr_name)         # ...\n    def write_attribute(attr_name, value) #...\n    def query_attribute(attr_name)        # ...\n```\n\n* 생성자를 먼저 살펴보자\n  * `@attributes` 변수는 데이터베이스의 속성 이름으로 채워진다.\n* method_missing을 보자\n  * 해당 속성의 이름은 Ghost Method의 이름이 된다.\n  * description= 과 같은 메서드를 호출할 때 method_missing은 속성의 이름과, write_method의 정규식에 일치한 다는 것을 알 수 있다.\n  * 따라서 write_attribute(\"description\")을 호출하게 된다. 다른 것 들도 비슷한 프로세스이다.\n* 3장에서 봤을때 method_missing과 함께 respond_to? 를 재정의 하는 것이 좋은 아이디어라는 것을 배웠다 \n  * 예를 들어 `my_task.description` 이 호출 가능하면 `my_task.respond_to?(:description)` 이 true를 반환해야한다.\n  * 재정의된 respond_to? 는 nil guard를 사용하여  `@@dynamic_methods` 에 한 번만 계산하고 클래스 변수에 저장한다.\n\n### Rails 2: 성능에 초첨맞추기\n\n* method_missing에 대한 설명을 기억하는가?\n* 존재하지 않는 메서드를 호출하면 Ruby는 해당 메서드를 찾기위해 조상 체인으로 타고 올라간다.\n* 메서드를 찾지 못하고 BasicObject에 도달하면 맨 아래에서 다시 시작하여 method_missing을 호출한다.\n* 일반적으로 Ruby가 전체 조상 체인을 한 번 이상 걸어야 하기 때문에 일반 메서드보다 느리다.\n* 대부분 성능 차이는 무시할 수 있지만 attributes method는 매우 자주 호출 된다.\n* define_method를 사용하고 method_missing을 모두 제거하여 고스트메서드를 동적 메서드로 대체함으로써 이 성능 문제 해결이 가능하다.\n* 흥미롭게도 그들은 Ghost Method와 Dynamic Method를 모두 포함하는 혼합 솔루션을 택했다.\n\n```ruby\nmodule ActiveRecord\n  module AttributeMethods\n    def method_missing(method_id, *args, &block)\n      method_name = method_id.to_s\n      if self.class.private_method_defined?(method_name)\n        raise NoMethodError.new(\"Attempt to call private method\", method_name, args)\n      end\n      # If we haven't generated any methods yet, generate them, then\n      # see if we've created the method we're looking for.\n      if !self.class.generated_methods?\n        self.class.define_attribute_methods\n        if self.class.generated_methods.include?(method_name)\n          return self.send(method_id, *args, &block)\n        end\n      end\n# ...\n    end\n    def read_attribute(attr_name)         # ...\n    def write_attribute(attr_name, value) # ...\n    def query_attribute(attr_name)        # ...\n```\n\n* `Task#description=` 같은 메서드를 처음 호출하면 호출이 method_hissing으로 전달 된다.\n* 작업을 수행 전 private method 호출은 에러를 발생시킨다.\n* 그 다음 `define_attribute_methods` 을 호출한다. \n* 다음에 description= 또는 다른 접근자를 호출할 때 호출은 method_missing에 의해 처리되지 않는다.\n* 대신 고스트메서드가 아닌 실제 메서드를 호출한다.\n* method_missing은 dynamic dispatch를 사용하여 이를 호출하고 결과를 받을 수 있다.\n* 이 프로세스는 `generated_methods?`로 인해 한 번만 발생하고 건너뛴다.\n\n```ruby\ndef define_attribute_methods\n  return if generated_methods?\n  columns_hash.each do |name, column|\n    unless instance_method_already_implemented?(name)\n      if self.serialized_attributes[name]\n        define_read_method_for_serialized_attribute(name)\n      elsif create_time_zone_conversion_attribute?(name, column)\n        define_read_method_for_time_zone_conversion(name)\n      else\n        define_read_method(name.to_sym, name, column)\n      end \n    end\n    unless instance_method_already_implemented?(\"#{name}=\")\n      if create_time_zone_conversion_attribute?(name, column)\n        define_write_method_for_time_zone_conversion(name)\n      else\n        define_write_method(name.to_sym)\n      end \n    end\n    unless instance_method_already_implemented?(\"#{name}?\")\n      define_question_method(name)\n    end \n  end\nend\n```\n\n* `instance_method_already_implemented?` 속성 이름의 메서드가 이미 존재하면 이 코드는 다음 속성으로 건너뛴다.\n* `define_read_method`, `define_write_method` 와 같이 실제 작업을 수행하는 다른 메서드에 위임하는 것 외에는 거의 뭔가를 하지 않는다.\n\n```ruby\ndef define_write_method(attr_name)\n  evaluate_attribute_method attr_name,\n     \"def #{attr_name}=(new_value);write_attribute('#{attr_name}', new_value);end\",\n     \"#{attr_name}=\"\nend\ndef evaluate_attribute_method(attr_name, method_definition, method_name=attr_name)\n  unless method_name.to_s == primary_key.to_s\n    generated_methods << method_name\n  end\n  begin\n    class_eval(method_definition, __FILE__, __LINE__)\n  rescue SyntaxError => err\n    generated_methods.delete(attr_name)\n    if logger\n      logger.warn \"Exception occurred during reader method compilation.\"\n      logger.warn \"Maybe #{attr_name} is not a valid Ruby identifier?\"\n      logger.warn err.message\n    end \n  end\nend\n```\n\n* `define_write_method` 는 class eval을 통해서 String Code를 빌드한다.\n* `description=` 을 호출하면 evaluate_attribute_method가 다음 문자열을 eval한다.\n\n```ruby\ndef description=(new_value);write_attribute('description', new_value);end\n```\n\n* 속성에 처음 접근할 때 해당 속성은 고스트 메서드이다.\n* method_missing을 통해 실제 메서드로 전환한다.\n* 모든 열에 대한 읽기, 쓰기, 쿼리 접근자를 동적으로 정의한다.\n* 하지만 모든 속성 접근자에 적용되지는 않는다.\n\n#### 동적으로 유지되는 속성\n\n* ActiveRecord를 통해 속성 접근자를 정의하고 싶지 않은 경우가 있다.\n* 계산된 필드 같이 데이터베이스 열이 지원하지 않는 속성을 생각해보자\n\n```ruby\nmy_query = \"tasks.*, (description like '%garage%') as heavy_job\"\ntask = Task.find(:first, :select => my_query)\ntask.heavy_job?  # => true\n```\n\n* heavy_job 같은 속성은 객체마다 다를 수 있기 때문에 액세스하기 위해 동적 메서드를 생성할 필요가 없다.\n\n```ruby\nmodule ActiveRecord\n  module AttributeMethods\n    def method_missing(method_id, *args, &block)\n      # ...\n      if self.class.primary_key.to_s == method_name\n        id\n      elsif md = self.class.match_attribute_method?(method_name)\n        attribute_name, method_type = md.pre_match, md.to_s\n        if @attributes.include?(attribute_name)\n          __send__(\"attribute#{method_type}\", attribute_name, *args, &block)\n        else\n          super \n        end\n      elsif @attributes.include?(method_name)\n        read_attribute(method_name)\n      else super\n      end \n    end\n    private\n      # Handle *? for method_missing.\n      def attribute?(attribute_name)\n        query_attribute(attribute_name)\n      end\n      # Handle *= for method_missing.\n      def attribute=(attribute_name, value)\n        write_attribute(attribute_name, value)\n      end\n```\n\n* method_missing 의 후반부를 보면 객체의 식별자에 액세스 하는 경우는 해당 값을 반환한다.\n* 속성 접근자를 호출하는 경우는 동적 디스패치 또는 read_attribute에 대한 직접 호출을 사용하여 접근자를 호출한다\n* 그렇지 않으면 super를 사용하여 상위 체인으로 호출을 보낸다\n\n### Rails 3,4 : 더 특별한 클래스\n\n* 1에서는 수 십줄의 코드\n* 2에서는 자체 파일과 수백 줄의 코드\n* 3에서는 테스트를 포함하지 않은 9개의 소스 코드 파일\n\n* Rails가 커짐에 따라 속성 메서드와 관련된 작은 트릭 및 성능 최적화, 코너 케이스를 발견했다.\n* Rails 4에서는 더 나아가 속성 접근자를 정의할때 이를 UnboundMethod로 변환하여 메서드 캐시에 저장한다.\n\n```ruby\nmodule ActiveRecord\n  module AttributeMethods\n    module Read\n      extend ActiveSupport::Concern\n      module ClassMethods\n        if Module.methods_transplantable?\n          def define_method_attribute(name)\n            method = ReaderMethodCache[name]\n            generated_attribute_methods.module_eval { define_method name, method }\n          end \n        else\n          def define_method_attribute(name)\n            # ...\n          end \n        end\n```\n\n* define_method_attribute 라는 메서드를 정의한다.\n* concern으로 인해 궁극적으로는 ActiveRecord::Base의 클래스 메서드가 된다.\n* Module.methods_transplantable?에 따라 다르게 정의된다.\n  * UnboundMethod를 다른 클래스 객체에 바인딩할 수 있나? - ruby 2.0 이상일 경우\n* define_method_attribute는 메서드 캐시에서 UnboundMethod를 검색하고 메서드를 define_method로 현재 모듈에 바인딩한다.\n* 메서드 캐시는 ReaderMethodCache라는 상수에 저장된다.\n* generated_attribute_methods 은 클린 룸을 제공,\n\n```ruby\nmodule ActiveRecord\n  module AttributeMethods\n    module Read\n      ReaderMethodCache = Class.new(AttributeMethodCache) {\n        private\n        # We want to generate the methods via module_eval rather than\n        # define_method, because define_method is slower on dispatch.\n        # Evaluating many similar methods may use more memory as the instruction\n        # sequences are duplicated and cached (in MRI).  define_method may\n        # be slower on dispatch, but if you're careful about the closure\n        # created, then define_method will consume much less memory.\n        #\n        # But sometimes the database might return columns with\n        # characters that are not allowed in normal method names (like\n        # 'my_column(omg)'. So to work around this we first define with\n        # the __temp__ identifier, and then use alias method to rename\n        # it to what we want.\n        #\n        # We are also defining a constant to hold the frozen string of\n        # the attribute name. Using a constant means that we do not have\n        # to allocate an object on each call to the attribute method.\n        # Making it frozen means that it doesn't get duped when used to\n        # key the @attributes_cache in read_attribute\n        def method_body(method_name, const_name)\n          <<-EOMETHOD\n          def #{method_name}\n            name = ::ActiveRecord::AttributeMethods::AttrNames::ATTR_#{const_name}\n            read_attribute(name) { |n| missing_attribute(n, caller) }\n          end\n          EOMETHOD\n        end\n}.new\n```\n\n* ReaderMethodCache는 AttributeMethodCache의 하위 클래스인 익명 클래스의 인스턴스이다.\n* 이 클래스는 String of Code를 반환하는 단일 메서드를 정의한다.\n\n```ruby\nmodule ActiveRecord\n  module AttributeMethods\n    AttrNames = Module.new {\n      def self.set_name_cache(name, value)\n        const_name = \"ATTR_#{name}\"\n        unless const_defined? const_name\n          const_set const_name, value.dup.freeze\n        end \n      end\n      }    \n    class AttributeMethodCache\n      def initialize\n        @module = Module.new\n        @method_cache = ThreadSafe::Cache.new\n      end\n      def [](name)\n        @method_cache.compute_if_absent(name) do\n          safe_name = name.unpack('h*').first\n          temp_method = \"__temp__#{safe_name}\"\n          ActiveRecord::AttributeMethods::AttrNames.set_name_cache safe_name, name\n          @module.module_eval method_body(temp_method, safe_name),\n                              __FILE__, __LINE__\n          @module.instance_method temp_method\n        end \n      end\n      private\n      def method_body; raise NotImplementedError; end\n    end\n```\n\n* AttrNames를 보자, set_name_cache라는 단일 메서드가 있는 모듈이다.\n  * 이름과 값이 주어지면 메서드는 그 값으로 관습적으로 명명된 상수를 정의한다.\n    * \"description\" => \"ATTR_description\" \n  * AttrNames는 클린 룸과 유사하다.\n  * 속성의 이름을 나타내는 상수를 저장하기 위해서만 존재한다.\n* AttributeMethodCache를 보자 [] 메서드는 속성의 이름을 사용하고 해당 속성에 대한 접근자를 UnboundMethod로 반환\n  * 속성 접근자는 Ruby 메서드지만 모든 속성 이름이 유효한 Ruby 메서드 이름은 아니다.\n    * 속성의 이름을 16진수 시퀀스로 디코딩하고 기존의 안전한 메서드 이름을 만들어 문제를 해결한다.\n  * 접근자에 대한 안전한 이름이 있으면 method_body를 호출하여 접근자의 본문을 정의하는 코드 문자열을 가져오고\n  * 단순히 @module이라는 이름의 클린룸 내부에 접근자를 정의한다.\n  * 마지막으로 클린룸에서 새로 생성된 접근자 메서드를 가져와 UnboundMethod로 반환한다.\n* 후속 호출에서 AttributeMethodCache#[]은 더 이상 메서드를 저장할 필요가 없다.\n* eotls @method_cache.compute_if_absent가 결과를 저장하고 반환한다\n* 동일한 접근자가 여러 클래스에 정의된 경우 시간을 단축한다.\n* ReaderMethodCache에서 method_body를 재정의하고 일기 접근자에 대한 코드 문자열을 반환함으로써 일반 AttributeMethodCache를 읽기 접근자를 위한 캐시로 바꾼다.\n* WriterMethodCache도 있다.\n\n## 교훈\n\n* 코드에서 몇 가지 특수한 경우를 다뤄야하나?\n  * 극단적인 경우에는 처음부터 완벽하고 되돌리지 않아도 되는 코드를 작성하기 위해 항상 노력할 수 있다.\n    * Do It Right First Time . \n  * 하지만 다른 경우에는 당장의 명백한 문제를 해결하는 간단한 코드를 작성하고 나중에 더 특별한 경우를 발견하면 더 포괄적으로 만들 수 있다.\n    * 이 접근 방식을 진화적 설계 라고 부르겠다.\n* 이 두 가지 접근 방식 간의 올바른 균형을 맞추는 게 중요하다.\n* Rails1 에서는 간단하고 단순한 솔루션, 2에서는 사용자의 요구사항에 따른 최적화 처럼 진화적인 설계의 좋은 예시이다.\n* 다음을 포함하여 여러 대안이 있었다.\n  * 고스트 메서드에만 의존하여 접근자를 동적으로 정의하지 않는다.\n  * initialize 메소드에서 개체를 생성할 때 접근자를 정의한다.\n  * 다른 속성이 아닌 액세스 중인 속성에 대해서만 접근자를 정의한다.\n  * 항상 계산된 필드에 대한 접근자를 포함하여 각 개체에 대한 모든 접근자를 정의한다.\n  * String of Code 대신 define_method를 사용하여 접근자를 정의한다.\n* 몇 가지 대안의 디자인을 시도한 다음 실제 시스템에서 코드를 프로파일리하여 성능의 병목 현상이 발생한 위치를 찾은 다음 최적화하는 것을 쉽게 상상할 수 있다.\n* 이전 예제는 최적화에 중점을 뒀지만 동일한 원칙이 모든 측변에 적용된다.\n* private 메서드를 호출하기위해 method_missing을 쓰는 것을 막는 코드를 생각해보자\n  * 모든 경우를 다 잡는건 어렵다.\n  * 합리적인 수의 특별한 경우를 다루고 더 많은 특별한 경우가 보이면 코드를 변경하는 것이 더 쉽다.\n* Rails의 접근 방식은 진화적 설계에 치우져져 있다.\n  * 루비는 메타프로그래밍을 사용할 때 유연한 언어이므로 코드를 쉽게 발전시킬 수 있다.\n  * 완벽한 메타프로그래밍 코드를 미리 작성하는 것은 어렵다. 모든 경우를 찾기 힘드니까.\n* 한 문장으로 요약하자면 코드를 최대한 단순하게 유지하고 필요한 만큼 복잡도를 추가하라 라는 뜻\n* 시작할 때 일반적인 경우에 코드를 올바르게 만들고 나중에 특별한 경우를 더 추가할 수 있을 정도로 간단하게 만들라. \n* 이것은 대부분의 코드에 대한 좋은 경험 법칙이지만 메타프로그래밍이 관련된 경우 특히 관련이 있다!\n\n\n\n"},{"excerpt":"이전 두 장에서 Rails의 모듈 설계와 그 설계가 시간이 지남에 따라 어떻게 변했는지 살펴봤다. 이 장에서는 Rails 역사의 더 극적인 변화에 대해 이야기 해보도록 하겠다. 결국 Rails 코드베이스에서 거의 완전히 폐기된 이라는 메서드가 어떻게 흥하고 망했는지 aliasmethodchain의 부흥 Include - Extend 트릭에서 흥미로운 코드…","fields":{"slug":"/metaprogramming-ruby-11/"},"frontmatter":{"date":"May 25, 2021","title":"M Ruby - 11.alias_method_chain의 흥망성쇠","tags":["ruby","book"]},"rawMarkdownBody":"\n* 이전 두 장에서 Rails의 모듈 설계와 그 설계가 시간이 지남에 따라 어떻게 변했는지 살펴봤다.\n* 이 장에서는 Rails 역사의 더 극적인 변화에 대해 이야기 해보도록 하겠다.\n* 결국 Rails 코드베이스에서 거의 완전히 폐기된 `alias_method_chain`이라는 메서드가 어떻게 흥하고 망했는지\n\n## alias_method_chain의 부흥\n\n* Include - Extend 트릭에서 흥미로운 코드 조각을 보여줬었다.\n\n```ruby\nmodule ActiveRecord\n  module Validations\n    def self.included(base)\n      base.extend ClassMethods\n      # here\n      base.class_eval do\n        alias_method_chain :save, :validation\n        alias_method_chain :save!, :validation\n      end\n      # here\nend\n```\n\n* ActiveRecord::Base에 Validations 모듈이 포함되어 있으면 표시된 라인이 Base를 다시 열고 alias_method_chain을 호출한다.\n\n### alias_method_chain를 썻던 이유\n\n* Greeting 메서드를 정의하는 모듈이 있다고 가정한다. 다음 코드처럼 보일 수 있다.\n\n```ruby\nmodule Greetings\n  def greet\n    \"hello\"\n  end \nend\nclass MyClass\n  include Greetings\nend\nMyClass.new.greet  # => \"hello\"\n```\n\n* 만약 Greetings를 선택적인 기능으로 감싸고 싶다고 가정해보자.\n* 예를들어 인사말이 더 열정적이였으면 좋겠다\n\n```ruby\nclass MyClass\n  include Greetings\n  def greet_with_enthusiasm\n    \"Hey, #{greet_without_enthusiasm}!\"\n  end\n  alias_method :greet_without_enthusiasm, :greet\n  alias_method :greet, :greet_with_enthusiasm\nend\nMyClass.new.greet  # => \"Hey, hello!\"\n```\n\n* 새로운 두 가지 메서드를 정의한다. \n  * `greeting_without_enthusiasm`는 원래 Greeting의 별칭이다.\n    * 두 번째는 `greeting_with_enthusiasm` 은 `greeting_without_enthusiasm`을 호출하고 그 위를 추가단어로 감싼다\n* 이런식의 래핑하는 아이디어는 레일즈에서 일반적이다.\n* method, method_with_feature 및 method_without_feature가 생긴다\n* 별칭을 여기저기 작성하는 대신 Rails에서는 이러한 작업을 수행하는 메타프로그래밍 방법을 제공했다.\n* ActiveSupport 라이브러리의 일부였었다.\n\n### alias_method_chain의 구현\n\n```ruby\nclass Module\n  def alias_method_chain(target, feature)\n    # Strip out punctuation on predicates or bang methods since\n    # e.g. target?_without_feature is not a valid method name.\n    aliased_target, punctuation = target.to_s.sub(/([?!=])$/, ''), $1\n    yield(aliased_target, punctuation) if block_given?\n    with_method = \"#{aliased_target}_with_#{feature}#{punctuation}\"\n    without_method = \"#{aliased_target}_without_#{feature}#{punctuation}\"\n    alias_method without_method, target\n    alias_method target, with_method\n    case\n    when public_method_defined?(without_method)\n      public target\n    when protected_method_defined?(without_method)\n      protected target\n    when private_method_defined?(without_method)\n      private target\n    end \n  end\nend\n```\n\n* 대상의 메서드 이름과 추가 기능의 이름을 사용한다.\n* target_without_feature / target_with_feature 라는 이름의 두가지 새 메서드 이름을 eval한다.\n* 원래 대상을 target_without_feature으로 저장하고, target_with_feature의 별칭을 target으로 지정한다.\n  * target_with_feature라는 메서드가 동일한 모듈 어딘가에 있다고 가정함\n* 마지막 스위치 케이스는 target_without_feature의 원래 대상과 동일한 접근 제한자를 설정함\n\n### ActiveRecord::Validation에서의 사용\n\n```ruby\ndef self.included(base)\n  base.extend ClassMethods\n  # ...\n  base.class_eval do\n    alias_method_chain :save, :validation\n    alias_method_chain :save!, :validation\n  end\n# ...\nend\n```\n\n* 이 줄은 Validation을 포함시키는 ( ActiveRecord::Base ) 클래스를 다시 열고 save를 해킹한다\n* 유효성 검사를 자동으로 save 할때마다 추가할 수 있다.\n* save_without_validation이라고 하면 유효성 검사를 안하고 저장 가능하다.\n* 이 모듈은 save_with_validation 및 save_with_validation!을 구현해야겠지?\n\n```ruby\nmodule ActiveRecord\n  module Validations\n    def save_with_validation(perform_validation = true)\n      if perform_validation && valid? || !perform_validation\n        save_without_validation\n      else\n        false\n      end \n    end\n    def save_with_validation!\n      if valid?\n        save_without_validation!\n      else\n        raise RecordInvalid.new(self)\n      end \n    end\n    def valid?\n      #...\n```\n\n* 실제 유효성 검사는 `valid?` 에서 일어난다.\n* `Validation#save_with_validation`은 유효성 검사가 실패하거나 호출자가 유효성 검사를 명시적으로 비활성화 한 경우 false를 반환한다.\n* 그렇지 않으면 원래 save_without_validation을호출한다.\n* `!` 에서는 에러를 발생시킨다.\n\n## alias_method_chain의 끝\n\n* Rails 2에서의 많은 모듈이 alias_method_chain을 사용하여 include하는 메서드의 기능을 래핑했다.\n* 결과적으로 alias_method_chain은 Rails와 수 십개의 타사 라이브러리에서 모두 사용되었다.\n* alias_method_chain는 그저 Around Alias의 캡슐화일 뿐이고 [예전 챕터](https://blog.seongjun.kr/metaprogramming-ruby-5)에서의 문제점을 그대로 갖고있다.\n* 설상가상으로 alias_method_chain많이 사용되면서 실제 메서드의 버전 추적이 어려워진다.\n* 그러나 alias_method_chain의 가장 치명적인 문제는 대부분의 경우 불필요하다는 것,\n* 객체 지향 적인 관점에서 기존 메서드 주위에 기능을 래핑하는 보다 우아하고 내장된 방법을 제공한다.\n\n```ruby\nmodule Greetings\n  def greet\n   \"hello\"\n  end \nend\nclass MyClass\n  include Greetings\nend\nMyClass.new.greet  # => \"hello\"\n\nmodule EnthusiasticGreetings\n  def greet\n    \"Hey, #{super}!\"\n  end\nend\nclass MyClass\n  include EnthusiasticGreetings\nend\nMyClass.ancestors[0..2]  # => [MyClass, EnthusiasticGreetings, Object]\nMyClass.new.greet        # => \"hello\"\n```\n\n* `EnthusiasticGreetings` 을 포함할 때 해당 모듈이 클래스의 조상 체인에 있는 클래스보다 더 높아진다.\n* 따라서 greet 함수는 모듈의 greet를 재정의한다.\n* `EnthusiasticGreetings` 같은 중개 모듈을 삽입하고 오버라이드 및 super를 호출할 수 있다\n* 하지만 만약 클래스가 Rails같은 라이브러리의 일부이며 소스코드에서 직접 작업하지 않고 해당 라이브러리를 확장하므로 모든 경우에 그럴 수 있는게 아니다\n* 이 제한으로 인해 alias_metho_chain을 쓰는 것\n\n```ruby\nmodule EnthusiasticGreetings\n  def greet\n    \"Hey, #{super}!\"\n  end\nend\nclass MyClass\n  prepend EnthusiasticGreetings\nend\nMyClass.ancestors[0..2]  # => [EnthusiasticGreetings, MyClass, Object]\nMyClass.new.greet        # => \"Hey, hello!\"\n\n```\n\n* Arounded Aliases에 대한 현대적인 대안인 prepended wrapper를 사용\n* MyClass의 조상 체인에서 MyClass#greet보다 낮아서 재정의가 잘 된다.\n\n## 교훈\n\n* 이 책을 통해 메타프로그래밍이 얼마나 편리하고 우아하고 멋진지에 대해 배웠다\n\n* 하지만 alias_method_chain에 대한 이야기는 경고에 가깝다.\n\n* 메타프로그래밍 코드는 때때로 복잡해질 수 있으며 심지어 더 전통적이고 단순한 기술을 간과하게 만들 수 있다.\n\n* 메타프로그래밍을 피하고 평범한 구식 OOP을 사용할 수 있다.\n\n* 코드를 너무 똑똑하게 만드려는 유혹에 저항하라는 교훈\n\n* 메타프로그래밍보다 목표를 달성하는 더 간단한 방법이 있는지 자문해본다.\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"excerpt":"이전 장에서 모듈을 포함하면 인스턴스와 클래스 메서드 모두를 얻는 것을 알게되었다. Active Support 라이브러리에 있는 Concern 덕분에 가능 한 것 이전에 어떻게 되어있었고 어떤식으로 진화하는지 알아보자 Concern 이전의 레일즈 레일즈는 수년동안 많이 변경되었지만 기본 아이디어는 크게 변경되지 않았다 그 중 하나가 ActiveRecord…","fields":{"slug":"/metaprogramming-ruby-10/"},"frontmatter":{"date":"May 16, 2021","title":"M Ruby - 10. Active Support's Concern Module","tags":["ruby","book"]},"rawMarkdownBody":"\n- 이전 장에서 모듈을 포함하면 인스턴스와 클래스 메서드 모두를 얻는 것을 알게되었다.\n- Active Support 라이브러리에 있는 Concern 덕분에 가능 한 것\n- 이전에 어떻게 되어있었고 어떤식으로 진화하는지 알아보자\n\n## Concern 이전의 레일즈\n\n- 레일즈는 수년동안 많이 변경되었지만 기본 아이디어는 크게 변경되지 않았다\n- 그 중 하나가 ActiveRecord::Base 개념이다.\n- 이 클래스는 인스턴스 메서드와 클래스 메서드를 모두 정의하는 수십 개의 모듈로 이뤄져있다.\n- 이러한 메서드를 Base에 넣는 메커니즘이 변경되었다.\n\n### Include, Extend 사용\n\n- Rails2에서의 유효성 검사는 `ActiveRecord::Validations` 에 정의되어있다 ( 그때는 Active Model 없었음 )\n- Validation은 독특한 트릭 사용\n\n```ruby\nmodule ActiveRecord\n  module Validations\n# ...\n    def self.included(base)\n      base.extend ClassMethods\n      # ...\n    end\n    module ClassMethods\n      def validates_length_of(*attrs) # ...\n      # ...\n      end\n      def valid?\n      # ...\n      end\n      # ...\n  end\nend\n```\n\n- 낯익지 않나? VCR 예제에서 본 것 ( HTTP call )\n\n1. valid? 같은 Validation의 인스턴스 메서드는 Base의 인스턴스 메서드가 된다.\n2. Ruby는 hook method를 호출해서 base를 인수로 전달한다.\n3. Validations::ClassMethod를 이용하여 base를 extend 한다.\n\n결과적으로 Base는 인스턴스 메서드와 클래스 메서드 모두 다 갖고올 수 있다.\n\n- include-and-extend 트릭이라고 부르도록 하겠다..\n\n- 수 많은 ruby, rails 프로젝트에서 이렇게 사용했다....\n\n- 편리하지만 몇 개의 문제가 있다.\n\n  - 클래스 메서드를 정의하는 각각의 모든 모듈은 해당 includer를 확장하는 훅도 정의해야한다.\n\n  - 해당 훅이 수십 개의 모듈에 걸쳐 복제된다. 결과적으로 사람들이 이럴 가치가 있나? ..흠 한 줄 더 추가해서 해결이 가능..\n\n    ```ruby\n    include Validations\n    extend Validations::ClassMethods\n    ```\n\n  - 하지만 더 깊은 문제가 있다!\n\n### The Problem of Chained Inclusions\n\n- 다른 모듈을 포함하는 모듈을 포함한다고 가정해보자.\n- ActiveRecord::Validations는 ActiveModel::Validations 을 include한다.\n\n```ruby\nmodule SecondLevelModule\n  def self.included(base)\n    base.extend ClassMethods\n  end\n  def second_level_instance_method; 'ok'; end\n  module ClassMethods\n    def second_level_class_method; 'ok'; end\n  end\nend\nmodule FirstLevelModule\n  def self.included(base)\n    base.extend ClassMethods\n  end\n  def first_level_instance_method; 'ok'; end\n\n  module ClassMethods\n    def first_level_class_method; 'ok'; end\n  end\n  include SecondLevelModule\nend\nclass BaseClass\n  include FirstLevelModule\nend\n\n```\n\n- 두 모듈 모두 BaseClass의 조상에 있으니 두 모듈의 인스턴스 메서드를 모두 호출 가능하다.\n\n- include와 extend 덕분에 클래스 메서드도 사용 가능하다.\n\n- 하지만...\n\n  `BaseClass.second_level_class_method # => NoMethodError`\n\n- SecondLevelModule.included를 호출할 때 기본 매개변수는 BaseClass가 아니라 FirstLevelModule\n\n- 결과적으로 SecondLevelModule::ClassMethods의 메서드는 FirstLevelModule의 클래스 메서드..\n\n```ruby\nmodule FirstLevelModule\n  def self.included(base)\n    base.extend ClassMethods\n    base.send :include, SecondLevelModule\nend\n```\n\n- 이러한 구현은 덜 유연하다..\n- 다른 모듈과 첫 번째 레벨의 모듈을 구별해야하고, 각 모듈은 그것이 첫 번째 레벨인지 알아야한다..\n- 그리고 이 시대에는 Module#include가 프라이빗 메서드라 호출 못했음 ( Dynamic Dispatch 를 사용해야함) , 최근엔 Public\n\n## ActiveSupport::Concern\n\n- `ActiveSupport::Concern`은 included-and-extend 트릭을 을 캡슐화하고 연결된 include문제를 수정한다.\n\n```ruby\nrequire 'active_support'\nmodule MyConcern\n  extend ActiveSupport::Concern\n  def an_instance_method; \"an instance method\"; end\n  module ClassMethods\n    def a_class_method; \"a class method\"; end\n  end\nend\nclass MyClass\n  include MyConcern\nend\nMyClass.new.an_instance_method  # => \"an instance method\"\nMyClass.a_class_method          # => \"a class method\"\n```\n\n- 어떻게 이게 되는걸까?\n\n### Concern 코드 보기\n\n```ruby\nmodule ActiveSupport\n  module Concern\n    class MultipleIncludedBlocks < StandardError #:nodoc:\n      def initialize\n        super \"Cannot define multiple 'included' blocks for a Concern\"\n      end\n    end\n    def self.extended(base)\n      base.instance_variable_set(:@_dependencies, [])\n    end\n    #...\n```\n\n- Concern의 코드는 짧지만 복잡하다.\n- excended및 append_features 메서드만 정의한다.\n\n#### Module#append_features\n\n```ruby\nmodule M\n  def self.append_features(base); end\nend\nclass C\n  include M\nend\nC.ancestors\n# => [C, Object, Kernel, BasicObject]\n```\n\n- included는 일반적으로 비어있는 Hook 메서드였고 재정의 하려는 경우에만 존재했다.\n- append_features는 실제 include가 일어나는 곳에 있다.\n- append_features는 포함된 모듈이 이미 포함하는 모듈의 조상체인에 있는지 확인하고 그렇지 않으면 체인에 추가한다.\n- 일반적으로는 included를 재정의하지만 append_features를 재정의..해버리면 모듈이 전혀 포함 안 되게 할 수 있다.\n\n#### Concern#append_features\n\n```ruby\nmodule ActiveSupport\n  module Concern\n    def append_features(base)\n```\n\n- Extension이 기억 나나?\n- append_features는 Concern의 인스턴스 메서드이므로 Concern을 확장하는 모듈의 클래스 메서드가 된다.\n- 즉 Validations라는 모듈이 Concern을 확장하면 Validations.append_features 클래스 메서드를 얻지\n  - 싱글톤 클래스들이 갖던거 기억하나?\n  - 아뇨.. ㅜㅜ\n- Concern을 확장하는 모듈은 @\\_dependencies 클래스 변수를 얻는다.\n- append_features의 재정의를 얻는다.\n\n#### Inside Concern#append_features\n\n```ruby\nmodule ActiveSupport\n  module Concern\n    def append_features(base)\n      if base.instance_variable_defined?(:@_dependencies)\n        base.instance_variable_get(:@_dependencies) << self\n        return false\n      else\n        return false if base < self\n        @_dependencies.each { |dep| base.send(:include, dep) }\n        super\n        base.extend const_get(:ClassMethods) \\\n          if const_defined?(:ClassMethods)\n        # ...\nend end\n\n```\n\n- 어렵지만 기본 아이디어는 간단하다.\n- 다른 concern에 concern을 include하지마!\n- 대신 concern이 서로를 include 하려할 때 종속성 그래프에 연결하기만 하면 된다.\n- 스스로 include하는 것이 아닌, 모든 종속성을 한번에 includer로 돌아서 include한다.\n- self는 concern이다, 클래스 메서드로 실행이 되고, base는 관심사거나 이를 포함하는 모듈이다.\n- 맨 처음 concern을 include하려고하면?\n  - @\\_dependencies 클래스 변수가 있는 것이 문제\n  - 이를 조상 체인에 자신을 추가하는 대신 dependencies에 자신을 추가하고 include가 실제로 안 되었음을 알리기 위해 false\n  - 예를들어 ActiveModel::Validations 이고, ActiveRecord::Validations에 포함되는 경우임!\n- 만약 Concern이 아닌 경우 -\n\n  - 이미 이 포함자의 조상인지 확인한다. ( base < self )\n  - 아닌 경우 종속성을 포함시킨다.\n  - 예를들어 ActiveRecord::Validations이고, ActiveRecord::Base에 포함되는 경우임!\n\n- 모든 종속성을 포함자의 조상 체인으로 롤링한 후에도 super으로 표준 append_features를 호출하여 조상 체인에 자신을 추가해야한다.\n- ClassMethod 모듈로 includer를 확장해야한다. 이에대한 참조를 얻으려면 Kernel#const_get이 필요함\n- Concern의 모듈 범위가 아닌 self의 범위에서 상수를 읽기 위함\n\n### Concern Wrap Up\n\n- ActiveSupport::Concern은 몇 줄의 코드로 단일 모듈로 래핑된 최소한의 종속성 관리 시스템\n- 그 코드는 복잡하지만, Active Model의 소스를 보면 알 수 있듯이 Concern을 사용하는 것은 쉽다\n\n```ruby\nmodule ActiveModel\n  module Validations\n    extend ActiveSupport::Concern\n      # ...\n    module ClassMethods\n      def validate(*args, &block)\n      # ...\n```\n\n- 일부는 이런 호출들 뒤에 숨겨진 너무 많은 마법들이 있고, 이런 숨겨진 복잡성엔 숨겨진 비용이 따른다고 한다.\n- 또 다른 일부는 Concern이 Rails 모듈을 최대한 슬림하고 단순하게 유지하는 데 도움을 준 것에.... 굿굿..\n\n## 교훈\n\n- 대부분의 언어에서는 구성 요소를 함께 묶는 방법이 많지 않다\n- 클래스에서 상속하거나 객체에 위임할 수 있다.\n  - 멋지게 만들고 싶다면 종속성 관리를 전문으로 하는 라이브러리 또는 전체 프레임워크를 사용할 수 있다.\n- Rails의 개발자의 프레임워크의 일부를 함께 묶는 방법...\n  - 처음에는 아마도 모듈을 포함하고 확장했을 것이고\n  - 나중에는 코드에 메타프로그래밍의 마법의 가루를 뿌리고 include-and-extend 트릭을 사용\n  - 나중에 Rails가 계속 성장하면서 이 관용구가 가장자리에서 삐걱거리기 시작했고..\n  - include-and-extend를 메타프로그래밍이 많은 ActiveSupport::Concern으로 대체했습니다.\n  - 그들은 한 번에 한 단계씩 자체 종속성 관리 시스템을 발전시켰습니다.\n- 수년에 걸쳐 우리는 소프트웨어 설계가 \"처음부터 제대로 하는\" 일이 아니라는 것을 배웠다.\n- 이것은 모듈이 상호 작용하는 방식과 같이 근본적인 것을 변경하기 위해 메타프로그래밍을 사용할 수 있는 Ruby와 같은 가단성 언어에서 특히 그렇다..\n- 메타프로그래밍은 영리해지는 것이 아니라 융통성에 관한 것\n  - 코드를 작성할 때 처음부터 완벽한 디자인을 위해 애쓰지 않고 복잡한 메타프로그래밍 트릭이 필요할 때까지 사용하지 않는다.\n  - 대신 작업을 수행하는 가장 확실한 기술을 사용하여 코드를 단순하게 유지하려고 한다.\n  - 어쩌면 어느 시점에서 내 코드가 엉키거나 완고한 중복을 발견할 수 있다..\n  - 그 때 메타프로그래밍과 같은 더 좋은 방법을 찾게된다.\n  - 이 책은 메타프로그래밍 성공 사례로 가득 차 있으며 ActiveSupport::Concern도 그 중 하나이다,....\n  - 그러나 Concern의 복잡한 코드와 약간 논쟁의 여지가 있는 성격은 메타프로그래밍의 어두운 면을 암시한다...\n  - 이것은 Rails의 가장 악명 높은 메소드에 대한 이야기를 살펴볼 다음 장의 주제\n"},{"excerpt":"ActiveRecord는 루비의 객체를 데이터베이스 레코드에 매칭하는 Rails 라이브러리이다. 이러한 기능을 object relational mapping이라고 하고, 관계형 데이터베이스와 객체지향 프로그래밍을 모두 잘 활용 가능하다. 액티브 레코드가 하는 일 보다는 어떻게 하는지에 대해 관심있게 확인! 짧은 예시  는 데이터베이스 연결같은 클래스 메서…","fields":{"slug":"/metaprogramming-ruby-9/"},"frontmatter":{"date":"May 10, 2021","title":"M Ruby - 9. The Design of Active Record","tags":["ruby","book"]},"rawMarkdownBody":"\n- ActiveRecord는 루비의 객체를 데이터베이스 레코드에 매칭하는 Rails 라이브러리이다.\n- 이러한 기능을 object relational mapping이라고 하고, 관계형 데이터베이스와 객체지향 프로그래밍을 모두 잘 활용 가능하다.\n- 액티브 레코드가 하는 일 보다는 어떻게 하는지에 대해 관심있게 확인!\n\n## 짧은 예시\n\n```ruby\nrequire 'active_record'\nActiveRecord::Base.establish_connection :adapter => \"sqlite3\",\n                                        :database => \"dbfile\"\nclass Duck < ActiveRecord::Base\n  validate do\n    errors.add(:base, \"Illegal duck name.\") unless name[0] == 'D'\n  end\nend\n```\n\n- `ActiveRecord::Base` 는 데이터베이스 연결같은 클래스 메서드 뿐만 아니라 매핑되는 모든 클래스의 슈퍼 클래스이다.\n\n```ruby\nclass Duck < ActiveRecord::Base\n  validate do\n    errors.add(:base, \"Illegal duck name.\") unless name[0] == 'D'\n  end\nend\n```\n\n- 유효성 검사를 하는 클래스 매크로이다.\n  - Duck의 이름은 D로 시작해야한다!\n  - 만약 다른 이름을 저장하려 하면 예외\n- convention에 따라서 Duck은 ducks 테이블애 매핑된다.\n  - ActiveRecord는 데이터베이스 스키마를 봐서 ducks에 name이 있다는 것을 알고, 그 필드에 접근 가능한 Ghost Method를 정의한다.\n\n```ruby\nmy_duck = Duck.new\nmy_duck.name = \"Donald\"\nmy_duck.valid?         # => true\nmy_duck.save!\n\nduck_from_database = Duck.first\nduck_from_database.name         # => \"Donald\"\nduck_from_database.delete\n\n```\n\n## ActiveRecord의 매커니즘\n\n- 앞의 예는 간단하지만 사실 더 많은 것들을 할 수 있다.\n- 하지만 ActiveRecord::Base 에서는 그런 메서드들에 대한 추적이 없다.\n- 따라서 초보자에겐 어떤 메서드가 어디서왔고 어떻게 들어오는지 이해하기 어렵다\n\n### Autoloading 매커니즘\n\n```ruby\nrequire 'active_support'\nrequire 'active_model'\n# ...\nmodule ActiveRecord\n  extend ActiveSupport::Autoload\n  autoload :Base\n  autoload :NoTouching\n  autoload :Persistence\n  autoload :QueryCache\n  autoload :Querying\n  autoload :Validations\n  # ...\n```\n\n- ActiveRecord는 두 개의 라이브러리에 크게 의존한다.\n  - ActiveSupport, ActiveModel\n- `autoload` 는 ActiveSupport의 메서드임\n- `ActiveSupport::Autoload` 를 extend 하고 autoload는 ActiveRecord의 클래스 메서드가 된다.\n- ActiveRecord는 autoload 클래스 매크로를 통해 수십개의 모듈을 등록한다.\n\n### ActiveRecord::Base\n\n```ruby\nmodule ActiveRecord\n  class Base\n    extend ActiveModel::Naming\n    extend ActiveSupport::Benchmarkable\n    extend ActiveSupport::DescendantsTracker\n    extend ConnectionHandling\n    extend QueryCache::ClassMethods\n    extend Querying\n    extend Translation\n    extend DynamicMatchers\n    extend Explain\n    extend Enum\n    extend Delegation::DelegateCache\n    include Core\n    include Persistence\n    include NoTouching\n    include ReadonlyAttributes\n    include ModelSchema\n    include Inheritance\n    include Scoping\n    include Sanitization\n    include AttributeAssignment\n    include ActiveModel::Conversion\n    include Integration\n    include Validations\n    include CounterCache\n    include Locking::Optimistic\n    include Locking::Pessimistic\n    include AttributeMethods\n    include Callbacks\n    include Timestamp\n    include Associations\n    include ActiveModel::SecurePassword\n    include AutosaveAssociation\n    include NestedAttributes\n    include Aggregations\n    include Transactions\n    include Reflection\n    include Serialization\n    include Store\n    include Core\n  end\n  ActiveSupport.run_load_hooks(:active_record, Base)\nend\n```\n\n- 모듈을 통해 기능들을 조립하는 클래스는 흔하지 않지만 ActiveRecord::Base는 이 작업을 대규모로 수행한다.\n- 그냥 수십 개의 모듈을 확장하거나 포함할 뿐이다.\n- `run_load_hooks` 코드를 통해 이러한 모듈 일부가 로드된 후 자체 configuration코드를 실행 가능\n- 모듈의 소스코드가 필요하지 않고 그냥 Include를 한다, 이 덕분에 최소한의 코드로 많은 모듈을 사용 가능하다.\n\n```ruby\nmodule ActiveRecord\n  module Persistence\n    def save(*)  # ...\n    def save!(*) # ...\n    def delete   # ...\n```\n\n- Base의 특정 메서드가 어디서 왔는지 그리 어렵지 않을 수 있다\n- 저장과 같은 persistence 메서드는 위와 같은 코드에서 확인이 가능하다.\n\n### 유효성 검증 모듈\n\n`ActiveRecord::Validations` - 관련 모듈인가...?\n\n```ruby\nmodule ActiveRecord\n  module Validations\n    include ActiveModel::Validations\n    # ...\n    def valid?(context = nil) #\n```\n\n- 하지만 실제로 validate 메서드는 없음\n- `ActiveModel::validations` 에 있다~\n\n이런 모듈을 포함하여 조금 헷갈리는 세부사항이 있다.\n\n일반적으로 클래스는 모듈을 포함함으로써 인스턴스 메서드를 얻는다.\n\n하지만 validate는 ActiveRecord의 클래스 메서드이다. 어떻게 Base는 클래스 메서드를 얻을 수 있지?\n\nActiveModel, ActiveRecord는 왜 두 모듈로 나뉘었나?\n\n크게 두 가지 작업\n\n1. 저장 및 로드와 같은 데이터베이스 작업을 처리\n2. 객체 모델을 다루는 것, 객체 속성을 관리하거나 유효한지 추적하는 것\n\n라이브러리의 저자들은 두개의 분리된 라이브러리로 분할하기로 결정해서 active_model이 탄생한 것\n\n특히 `valid?` 는 나름 데이터베이스쪽에 관계가 있어서 남았고,\n\n`validate` 는 데이터베이스와 관계 없이 객체의 속성에만 관심이 있으므로 ActiveModel로 갔다\n\n## 교훈\n\n- 수많은 모듈을 포함해서 굉장히 큰 클래스가 된다.\n- Base는 300개 이상의 인스턴스 메서드와 550개 이상의 클래스 메서드를 갖고있다..\n- ActiveRecord::Base는 궁극의 오픈클래스\n\n수백개의 메서드를 가진 거대한 클래스? 이해하기 힘들고 어렵지 않나?\n\n- 액티브 레코드의 대부분의 메서드는 궁극적으로 하나의 클래스 안으로 굴러들어간다.\n- 일부 모듈은 메타프로그래밍을 사용하여 더 많은 메서드를 정의하는 것을 고민하지 않고..\n- 엎친 데 덮친 격으로 액티브 레코드로 작업하는 추가 라이브러리도 액티브 레코드를 확장함..\n\n스파게티 덩어리가 되지 않을까? ~~하지만 그렇지 않다...?~~ -\n\n- 많은 사람들이 자신의 목적을 위해 액티브 레코드를 몽키패치하고,..\n- 엑레의 소스코드는 빠르게 진화한다...\n- 안정적이게 유지가 되고 프로덕션에서 만족하며 사용중...\n\n액티브 레코드에서 배운 중요한 가이드라인...\n\n- design techniques는... 상대적이고 사용하는 언어에 따라 다르다,\n- 루비에서는 다른 언어들과 다른 관용구를 사용한다.\n- 오래된 좋은 규칙들이 갑자기 쓸모없어지는 것이 아니다,\n- 루비에서도 다른 언어와 마찬가지로 디자인의 기본 원칙( 디커플링, simplicity, 중복 없음)이 적용된다.\n- 하지만 이를 달성하기 위한 기술이 매우 다르다.\n- ActiveRecord::Base를 보면 매우 큰 클래스지만 소스코드에는 복잡한 코드가 없다\n- 대신 느슨하게 결합되고 테스트하기 쉬우며 재사용하기 쉬운 모듈을 조합하여 런타임에 구성된다.\n\n```ruby\nrequire 'active_model'\nclass User\n  include ActiveModel::Validations\n  attr_accessor :password\n  validate do\n    errors.add(:base, \"Don't let dad choose the password.\") if password == '1234'\n  end\nend\n\nuser = User.new\nuser.password = '12345'\nuser.valid?        # => true\nuser.password = '1234'\nuser.valid?        # => false\n\n```\n\n- 위처럼 필요한 경우만 포함도 가능함\n"},{"excerpt":"메타프로그래밍은 단문장으로 정의할 수 있는 접근법이 아니다. 여태 배운 트릭들을 잘 조합해서 어떻게 문제들을 해결하는지에 대한 장  과제 attraccessor 처럼 클래스 매크로 `attrchecked` 모든 클래스에서 사용하여 더럽게 만드는 것 보단... CheckedAttributes모듈을 포함하는 경우에 클래스가 사용 가능 계획 addchecked…","fields":{"slug":"/metaprogramming-ruby-6/"},"frontmatter":{"date":"May 02, 2021","title":"M Ruby - 6. Code That Writes Code","tags":["ruby","book"]},"rawMarkdownBody":"\n- 메타프로그래밍은 단문장으로 정의할 수 있는 접근법이 아니다.\n- 여태 배운 트릭들을 잘 조합해서 어떻게 문제들을 해결하는지에 대한 장\n\n##\n\n## 과제\n\n```ruby\nclass Person\n >> include CheckedAttributes\n  attr_checked :age do |v|\n    v >= 18\n  end\nend\nme = Person.new\nme.age = 39# OK\nme.age = 12# Exception\n```\n\n- attr_accessor 처럼 클래스 매크로 `attr_checked`\n- 모든 클래스에서 사용하여 더럽게 만드는 것 보단...\n  - CheckedAttributes모듈을 포함하는 경우에 클래스가 사용 가능\n\n## 계획\n\n1. add_checked_attribute라는 Kernel method 메서드를 eval을 통해 추가한다. - 단순한 유효성 검사 어트리뷰트를 클래스에 추가\n2. eval을 제거하기 위해 add_checked_attribute를 리펙터링한다\n3. 블록을 통해 속성을 유효성 검증 한다.\n4. add_checked_attributes를 attr_checked라는 클래스 매크로로 변경한다. 모든 클래스에서 사용 가능\n5. 모듈을 추가해서 선택된 클래스만 사용 가능하게 한다.\n\n## Kernel#eval\n\n- instance_eval, class_eval을 이전에 배웠지? Kernel#eval 도 있다\n\n```ruby\narray = [10, 20]\nel = 30\neval(\"array << el\") # => [10,20,30]\n```\n\n- 위의 예시는 의미가 없지만 코드 문자열을 즉시 evaluate하는건 의미가 있다\n\n### REST client 예시\n\n- `gem install rest-client`\n- REST Client는 간단한 http 클라이언트 라이브러리이다.\n- http 메서드와 함께 일반 루비 명령을 실행할 수 있는 인터프리터가 포함\n\n```ruby\nrestclient http://www.twitter.com\n   > html_first_chars = get(\"/\")[0..14]\n   => \"<!DOCTYPE html>\"\n\n\nmodule RestClient\n  class Resource\n    def get(additional_headers={}, &block) # ...\n    def post(payload, additional_headers={}, &block) # ...\n    def put(payload, additional_headers={}, &block) # ...\n    def delete(additional_headers={}, &block) # ...\n```\n\n- 소스를 보면 네 가지의 기본 HTTP 메서드가 리소스 클래스에 정의되어 있다.\n- 인터프리터에서 이 메서드들을 사용할 수 있도록 특정 url의 리소스 메서드에 위임하는 최상위 메서드를 정의한다.\n\n```ruby\ndef  get(path, *args, &b)\n  r[path].get(*args, &b)\nend\n```\n\n- 하지만 이런 것들을 일일이 정의하는 것이 아닌\n\n```ruby\nPOSSIBLE_VERBS = ['get', 'put', 'post', 'delete']\nPOSSIBLE_VERBS.each do |m|\n  eval <<-end_eval\n    def  #{m}(path, *args, &b)\n        r[path].#{m}(*args, &b)\n    end\n  end_eval\nend\n```\n\n- here document - heredoc 이라고 알려진 구문을 사용\n- <<- 시퀀스로 시작하여 end_eval로 끝나는데\n- <<- end_eval 은 end_eval이라는 문구가 나오면 끝난다는 것\n\n### Binding Objects\n\n- 바인딩은 객체로 패키지된 전체 스코프이다.\n- 바인딩을 생성해서 로컬 스코프를 캠쳐하고, 이동할 수 있다는 아이디어\n- 나중에 바인딩 객체를 eval과 함께 사용하여 해당 스코프에서 코드를 실행할 수 있다.\n\n```ruby\nclass MyClass\n  def my_method\n    @x = 1\n    binding\n  end\nend\nb = MyClass.new.my_method\n```\n\n- 바인딩 객체는 스코프를 포함하지만 코드는 포함하지 않는다, 따라서 블록보다 순수한 형태의 클로저라고 생각할 수 있다.\n- 바인딩을 evaluate할 추가 인수로 전달하여 캡쳐된 스코프의 코드를 eval 가능\n\n```ruby\neval \"@x\", b       # => 1\n```\n\n- TOPLEVEL_BINDING이라는 미리 정의된 상수, 최상위 스코프의 바인딩\n\n```ruby\nclass AnotherClass\n  def my_method\n    eval \"self\", TOPLEVEL_BINDING\n  end\nend\nAnotherClass.new.my_method    # => main\n```\n\n- 이런 바인딩 오브젝트를 유용하게 쓴 잼이 Pry\n- Object#pry 를 정의하고, 이 함수를 디버거로 사용할 수 있다.\n- 중단점을 설정하는 대신 현재 바인딩을 호출하는 줄을 코드에 추가한다.\n\n```ruby\n# code...\nrequire \"pry\"; binding.pry\n# more code...\n```\n\n- ruby interpreter를 현재 바인딩에서 열고 ~\n\n#### IRB 예시\n\n- irb는 표준 입력이나 파일을 파싱하고 각 줄을 통과시켜 eval하는 단순한 프로그램\n\n```ruby\neval(statements, @binding, file, line)\n```\n\n- irb 소스코드의 깊은 곳에 있는 eval 호출\n- statements는 그냥 루비 코드\n- binding - 다른 맥락에서 코드를 eval하기 위해 이 인수를 변경 가능하다.\n  - 특정 객체에서 중첩된 irb세션을 열 때 기존 irb 세션의 객체 이름 뒤에 irb를 입력함\n  - 해당 객체 맥락에서 eval 될 것\n- file, line은 예외가 났을 때 스택을 주적하는데 사용됨\n\n```ruby\nx=1/0\nZeroDivisionError: divided by 0\nfrom exception.rb:2:in `/'\n```\n\n#### String of Code vs Block\n\n- 문자열의 코드는 결국 블록과 다를바가 없다.\n- 하지만 되도록 블록으로..\n\n#### eval()의 문제\n\n- 꿀이지만 그만큼 위험이 따름\n  - ide에서 하이라이팅이 잘 안 될 수도 있다.\n  - 정적 분석으로 에러를 찾기가 아려워서 ide에서도 워닝을 못뱉음\n- 위의 에러들은 사실 보안 이슈에 비하면 사소하지\n\n#### 코드 인젝션\n\n```ruby\ndef explore_array(method)\n  code = \"['a', 'b', 'c'].#{method}\"\n  puts \"Evaluating: #{code}\"\n  eval code\nend\nloop { p explore_array(gets()) }\n```\n\n- 마지막 줄의 무한 루프는 표준 입력에서 문자열을 받아다가 expect_array의 메서드로 넣는다.\n- code를 eval하고 print\n\n```ruby\n➾ find_index(\"b\")\n❮ Evaluating: ['a', 'b', 'c'].find_index(\"b\")\n1\n\n➾ map! {|e| e.next }\n❮ Evaluating: ['a', 'b', 'c'].map! {|e| e.next }\n   [\"b\", \"c\", \"d\"]\n```\n\n- 이 코드를 사용자가 입력한다면\n\n```ruby\n➾ object_id; Dir.glob(\"*\")\n❮ ['a', 'b', 'c'].object_id; Dir.glob(\"*\") => [your own private information here]\n```\n\n- 악의적인 사용자가 컴퓨터에서 임의 코드를 실행할 수 있다.\n- code injection attack\n\n##### 코드 인젝션 막기\n\n- 구문을 분석할 수도 있겠지만 악성 코드 작성 방법은 많으니까 효과적이지 않을 수 있다.\n- 사용자가 직접 작성한 문자열만 악성 코드를 포함할 수 있으므로 사용자가 작성한 문자열에 대한 eval을 금지할 수도 있다.\n  - 많이 복잡한 경우는 문자열이 어디서 왔는지 알기 어려울지도... 추적 계속 해야하니\n- 이런 어려움 때문에 어떤 프로그래머들은 eval을 전면 금지하자고 하기도 함\n  - 이는 꽤 인기 있는 선택\n  - 잘못될 수 잇는 것에 대해 편집증적인 경향\n- eval을 안쓰면 사례별로 대체 기법을 찾아야 한다.\n  - 동적 메서드와 동적 디스패치로 대체 가능\n\n```ruby\nPOSSIBLE_VERBS.each do |m|\n  define_method m do |path, *args, &b|\n    r[path].send(m, *args, &b)\n  end\nend\n\ndef explore_array(method, *arguments)\n  ['a', 'b', 'c'].send(method, *arguments)\nend\n```\n\n- 하지만 사용자가 block을 못씀, 임의의 문자열을 코드로 삽입하도록 해야한다..\n- eval과 eval을 안쓰는 방식에서 선택이 어렵지....\n- 이하 eval을 그나마 안전하게 쓰는 기능을 제공\n\n#### Tainted Objects and Safe Levels\n\n- 루비는 잠재적으로 안전하지 않은 객체에 대해 - 특히 외부 소스에서 온 객체를 tainted로 자동 표시한다.\n- tainted ( 오염된 ) 객체는 프로그램이 web form, file, command line, 혹은 시스템 변수에서 읽는 문자열\n\n```ruby\n# read user input\nuser_input = \"User input: #{gets()}\"\nputs user_input.tainted?\n➾x=1 ❮ true\n```\n\n- 루비는 오염된 객체를 잘 보완해주는 safe level이라는 개념을 제공한다\n- $SAFE 전역 변수로 안전 수준을 설정하면, 잠재적인 위험한 작업을 허용하지 않는다.\n  - 0 - 3 까지\n  - 1이상이면 tainted 문자열을 eval 못함\n  - 2이면 대부분의 파일 관련 작업을 수행할 수 없음\n\n```ruby\n$SAFE = 1\nuser_input = \"User input: #{gets()}\"\neval user_input\n```\n\n- 안전 수준에 의존하여 디스크 액세스 같은 위험한 작업을 허용하지 않도록 할 수 있다.\n\n#### ERB 예시\n\n- ERB는 루비 기본 템플릿 시스템임\n- HTML에 ruby code를 내장하여 사용하는 코드 프로세서\n\n```erb\n<p><strong>Wake up!</strong> It's a nice sunny <%= Time.new.strftime(\"%A\") %>.</p>\n```\n\n`<%= .. %>` 안에 ruby code를 넣어두면 evaluate\n\n```ruby\nrequire 'erb'\nerb = ERB.new(File.read('template.rhtml'))\nerb.run\n❮ <p><strong>Wake up!</strong> It's a nice sunny Friday.</p>\n```\n\n```ruby\n  class ERB\n    def result(b=new_toplevel)\n      if @safe_level\n        proc {\n          $SAFE = @safe_level\n          eval(@src, b, (@filename || '(erb)'), 0)\n        }.call\n      else\n        eval(@src, b, (@filename || '(erb)'), 0)\n      end\n    end\n#...\n```\n\n- new_toplevel은 TOPLEVEL_BINDING의 복사본을 반환하는 메서드\n- 안전수준이 설정 되어있으면 포함\n  - 샌드박스를 구축한다.\n  - 별도의 범위에서 코드를 실행하기 위해 clean room을 사용함\n  - 안전 수준은 proc 안에서만 적용이 됨\n  -\n- 아니면 바로 eval\n\n## 1단계 일단 간단하게 eval로\n\nchecked_attribute를 만들 계획을 세웠던 대로 진행!\n\n1. eval을 사용하여 add_checked_attribute라는 커널 메서드를 작성\n2. eval을 제거\n\n```ruby\nrequire 'test/unit'\nclass Person; end\nclass TestCheckedAttribute < Test::Unit::TestCase\n  def setup\n    add_checked_attribute(Person, :age)\n    @bob = Person.new\n  end\n  def test_accepts_valid_values\n    @bob.age = 20\n    assert_equal 20, @bob.age\n  end\n  def test_refuses_nil_values\n    assert_raises RuntimeError, 'Invalid attribute' do\n      @bob.age = nil\n    end\n  end\n  def test_refuses_false_values\n    assert_raises RuntimeError, 'Invalid attribute' do\n      @bob.age = false\n    end\n  end\nend\n# Here is the method that you should implement.\ndef add_checked_attribute(klass, attribute)\n  # ...\nend\n```\n\n```ruby\ndef add_checked_attribute(klass, attribute)\n  eval \"class #{klass}\n        def #{attribute}=(value)\n          raise 'Invalid attribute' unless value\n          @#{attribute} = value\n        end\n        def #{attribute}()\n          @#{attribute}\n        end\n  end\"\nend\n```\n\n- `add_checked_attribute` 를 한 뒤 String클래스\n\n```ruby\nclass String\n  def my_attr=(value)\n    raise 'Invalid attribute' unless value\n    @my_attr = value\n  end\n  def my_attr()\n    @my_attr\n  end\nend\n```\n\n- Open Class로 처리가 되고, 두 새로운 메서드를 가지게 된다.\n\n## 2단계 Eval 빼기\n\n- eval을 뿌시자\n- 일반 루비 메서드로 대체!\n- 왜 eval을 뿌셔야하는 강박관념이 생겼을까... ?\n  - 팀원들만 사용하는데 코드 인젝션의 표적이 되나? 아니지\n  - 하지만 이 메서드가 나중에 세상에 드러날 수 있으니...?\n  - Strings of Code를 안 쓰고 만들면 더 명확하고 우아하게 제공 가능하고 하이라이터들이 덜 홀란스러워 할 것이다.\n- 플랫 스코프 기억하니?\n\n```ruby\ndef add_checked_attribute(klass, attribute)\n  klass.class_eval do\n    define_method \"#{attribute}=\" do |value|\n      raise 'Invalid attribute' unless value\n      instance_variable_set(\"@#{attribute}\", value)\n    end\n    define_method attribute do\n      instance_variable_get \"@#{attribute}\"\n    end\n  end\nend\n```\n\n- 해단 클래스의 스코프에 들어가야 한다.\n- eval을 제거하면 클래스 키워드를 사용할 수 없으므로 class_eval을 사용하여 스코프에 들어간다.\n- 런타임에서 메서드의 이름을 알 수 없으니 define_method를 사용해야한다.\n\n## 3단계 블록으로 검증\n\n- 블록으로 속성 검증이 가능해야한다, - 유연하게\n- 하지만 지금은 0혹은 false 할당시 예외\n- 새로운 테스트 필요함\n\n```ruby\nrequire 'test/unit'\nclass Person; end\nclass TestCheckedAttribute < Test::Unit::TestCase\n  def setup\n    add_checked_attribute(Person, :age) {|v| v >= 18 }\n    @bob = Person.new\n  end\n  def test_accepts_valid_values\n    @bob.age = 20\n    assert_equal 20, @bob.age\n  end\n  def test_refuses_invalid_values\n    assert_raises RuntimeError, 'Invalid attribute' do\n      @bob.age = 17\n    end\n  end\nend\ndef add_checked_attribute(klass, attribute, &validation)\n  # ... (The code here doesn't pass the test. Modify it.)\nend\n```\n\n```ruby\n\ndef add_checked_attribute(klass, attribute, &validation)\n  klass.class_eval do\n    define_method \"#{attribute}=\" do |value|\n      raise 'Invalid attribute' unless validation.call(value)\n      instance_variable_set(\"@#{attribute}\", value)\n    end\n    define_method attribute do\n      instance_variable_get \"@#{attribute}\"\n    end\n  end\nend\n\n```\n\n## 4단계 클래스 매크로!\n\n- 일단 테스트 케이스를 변경\n\n```ruby\nclass Person\n  attr_checked :age do |v|\n   v >= 18\n  end\nend\nclass TestCheckedAttributes < Test::Unit::TestCase\n  def setup\n    @bob = Person.new\n  end\n  def test_accepts_valid_values\n    @bob.age = 20\n    assert_equal 20, @bob.age\n  end\n  def test_refuses_invalid_values\n    assert_raises RuntimeError, 'Invalid attribute' do\n      @bob.age = 17\n    end\n   end\nend\n```\n\n- Class 클래스에서 정의한다!\n\n```ruby\nclass Class\n  def attr_checked(attribute, &validation)\n    define_method \"#{attribute}=\" do |value|\n      raise 'Invalid attribute' unless validation.call(value)\n      instance_variable_set(\"@#{attribute}\", value)\n    end\n    define_method attribute do\n      instance_variable_get \"@#{attribute}\"\n    end\n  end\nend\n```\n\n## Hook Methods\n\n- 클래스가 상속될 때 코드를 실행 할 수 있다!\n\n```ruby\nclass String\n  def self.inherited(subclass)\n    puts \"#{self} was inherited by #{subclass}\"\n  end\nend\nclass MyString < String; end\nString was inherited by MyString\n```\n\n- 상속 메서드는 클래스의 인스턴스 메서드\n- 원래는 아무런 작업도 수행하지 않지만 재정의 가능\n\n### More Hooks\n\n- 라이프 사이클에 연결이 가능하도록 모듈에서도 제공!\n\n```ruby\nmodule M1\n  def self.included(othermod)\n    puts \"M1 was included into #{othermod}\"\n  end\nend\nmodule M2\n  def self.prepended(othermod)\n    puts \"M2 was prepended to #{othermod}\"\n  end\nend\nclass C\n  include M1\n  prepend M2\nend\n❮ M1 was included into C M2 was prepended to C\n\n\nmodule M\n  def self.method_added(method)\n    puts \"New method: M##{method}\"\n  end\n  def my_method; end\nend\n❮ New method: M#my_method\n```\n\n- include/prepend시 실행 가능\n- 모듈을 재정의하여 객체를 확장할 때 코드 실행 가능\n\n이런 훅들은..\n\n- singleton method에서는 못쓴다\n\n```ruby\nmodule M; end\nclass C\n  def self.include(*modules)\n    puts \"Called: C.include(#{modules})\"\n    super\n  end\n  include M\nend\n\n```\n\n- 다른 쪽에서 동일한 이벤트에 연결 가능함!\n- Module#included 을 오버라이딩 하는 것과, Module#include를 오버라이딩 하는 것은 차이가 있음\n- include에는 실제 작업이 있으므로 super를 포함 꼭 시켜야함\n\n### VCR 예시\n\n- VCR 잼은 HTTP 요청을 녹화하고 리플레이하는 잼이다.\n- VCR의 Request 클래스에 Normalizers:Body가 포함되어있다.\n- Body 모듈은 body_from 같이 http message body를 다루는 클래스 메서드를 추가한다.\n- 하지만 클래스는 일반적으로 클래스 메서드가 아닌 모듈을 포함해서 인스턴스 메서드를 갖고오지 않는가?\n- 어떻게 얘는 mixin할까\n\n```ruby\nmodule VCR\n  module Normalizers\n    module Body\n      def self.included(klass)\n        klass.extend ClassMethods\n      end\n      module ClassMethods\n        def body_from(hash_or_string)\n          #...\n```\n\n- include를 시키면 Body의 included 훅을 호출\n- Request을 ClassMethods 모듈로 확장한다.\n- 확장 메서드는 요청의 싱글톤 클래스에 ClassMethods의 메서드를 포함시킨다.\n\nClassMethods - plus - hook 관용구는 꽤 흔하고 레일즈 코드에서 광범위하게 썼다.\n\n하지만 다른 매커니즘으로 지금 변경되었고 VCR이나 다른 잼에서 이 예를 찾을 수 있다.\n\n## 5단계 필요한 클래스에서만!\n\n- checkedAttributes라는 모듈을 포함한 클래스에서만 사용할 수 있도록 변경\n\n```ruby\nrequire 'test/unit'\nclass Person\n  include CheckedAttributes\n  attr_checked :age do |v|\n    v >= 18\n  end\nend\nclass TestCheckedAttributes < Test::Unit::TestCase\n  def setup\n    @bob = Person.new\n  end\n  def test_accepts_valid_values\n    @bob.age = 18\n    assert_equal 18, @bob.age\n  end\n  def test_refuses_invalid_values\n    assert_raises RuntimeError, 'Invalid attribute' do\n      @bob.age = 17\n    end\n  end\nend\n```\n\n```ruby\nmodule CheckedAttributes\n  def self.included(base)\n    base.extend ClassMethods\n  end\n  module ClassMethods\n    def attr_checked(attribute, &validation)\n      define_method \"#{attribute}=\" do |value|\n          raise 'Invalid attribute' unless validation.call(value)\n          instance_variable_set(\"@#{attribute}\", value)\n      end\n      define_method attribute do\n        instance_variable_get \"@#{attribute}\"\n      end\n    end\n  end\nend\n```\n\n굿!\n\n## 정리\n\n- 메타프로그래밍 문제를 풀었다. 그 과정에서 eval과 이에 대한 문제점 및 해결 방안을 배움\n- hook methods를 알게되었다.\n"},{"excerpt":"Class Definitions 일반적인 프로그래밍 언어에서의 클래스는 클래스의 객체를 만든 다음 해당 객체의 메서드를 호출할 때까지 실제로 아무 일도 일어나지 않는다. 루비에서는 다르다, 객체의 향후 동작 방식만 지시하는 것이 아닌 코드를 실제로 싱행한다. 클래스 매크로와 별칭에 대한 것을 배울 예정 싱글톤 클래스에 대해서도 설명 클래스 정의 이해하기 …","fields":{"slug":"/metaprogramming-ruby-5/"},"frontmatter":{"date":"April 29, 2021","title":"M Ruby - 5. Class Definitions","tags":["ruby","book"]},"rawMarkdownBody":"\n# Class Definitions\n\n- 일반적인 프로그래밍 언어에서의 클래스는 클래스의 객체를 만든 다음 해당 객체의 메서드를 호출할 때까지 실제로 아무 일도 일어나지 않는다.\n- 루비에서는 다르다, 객체의 향후 동작 방식만 지시하는 것이 아닌 코드를 실제로 싱행한다.\n- 클래스 매크로와 별칭에 대한 것을 배울 예정\n- 싱글톤 클래스에 대해서도 설명\n\n## 클래스 정의 이해하기\n\n### 클래스 정의 내부\n\n```ruby\nclass MyClass\n  puts 'Hello'\nend\n❮ Hello\n```\n\n- 클래스 정의에 원하는 코드를 넣을 수 있다.\n\n```ruby\nresult = class MyClass\n    self\nend\nresult # => MyClass\n\n```\n\n- 클래스 정의도 메서드처럼 마지막 라인을 반환한다.\n- 클래스 정의에서 클래스 자체는 현재 객체로써 역할을 수행함\n- 클래스와 모듈은 객체일 뿐인데 왜 self가 될 수 없나?\n- 일단 킵\n\n### The Current Class\n\n- 알다시피 루비에서는 어디든 self를 갖고있다. 마찬가지로 항상 **current class**가 있다.\n- 메서드를 정의하면 해당 메서드가 현재 클래스의 인스턴스 메서드가 된다.\n- self로 현재 객체에 대한 참조를 가져올 수 있지만 **current class**에 대한 참조를 갖고 오는 키워드는 없다.\n  - 최상위 레벨에서의 current class는 Object이다. 따라서 최상위에서 메서드를 정의하면 Object의 인스턴스 메서드가 된다.\n  - 메서드에서 current class는 오브젝트의 클래스이다.\n  - 클래스 키워드가 있는 클래스를 열면 해당 클래스가 current class가 된다\n- 클래스 키워드는 클래스 이름이 필요하다는 한계\n\n```ruby\ndef add_method_to(a_class)\n  # TODO: define method m() on a_class\nend\n```\n\n- 현재 클래스를 변경하려면 클래스 키워드 이외의 방법이 필요하다.\n\n#### class_eval()\n\n`Module#class_eval` 은 기존 클래스의 컨텍스트에서 블록은 evaluate한다.\n\n```ruby\ndef add_method_to(a_class)\n  a_class.class_eval do\n    def m; 'Hello!'; end\n  end\nend\nadd_method_to String\n\"abc\".m   # => \"Hello!\"\n```\n\n- `instance_eval` 하고는 매우 다름 얘는 object만 변경, class_eval은 전부 변경\n  - 펙트는 아닌데 일단 뒤에서 더 설명\n- class_eval은 current class를 변경하여 클래스 키워드처럼 클래스를 다시 연다.\n- class 보다 더 유연하다\n  - class는 상수를 필요하지만 class_eval은 모든 변수에 사용 가능\n  - class는 current binding을 볼 수 없지만 class eval은 플랫 스코프를 가짐 - 외부 스코프의 변수 참조 가능\n  - class_exec 메서드도 있다.\n\n### Current class Wrap-up\n\n- 루비 인터프리터는 항상 current class에 대한 참조를 유지한다. def로 정의된 메서드는 current class의 인스턴스 메서드가 된다.\n- 클래스 정의에서 현재 객체 self와 current class는 동일하다.\n- 클래스에 대한 참조가 있으면 class_eval로 클래스를 열 수 있다.\n\n### 클래스 인스턴스 변수\n\n- 루비 인터프리터는 모든 인스턴스 변수가 현재 객체 self에 속한다고 가정한다, 클래스에서도 마찬가지\n\n```ruby\nclass MyClass\n  @my_var = 1\n  def self.read; @my_var; end\n  def write; @my_var = 2; end\n  def read; @my_var; end\nend\nobj = MyClass.new\nobj.read # => nil\nobj.write\nobj.read # => 2\nMyClass.read # => 1\n```\n\n- self는 클래스 자체이니까 인스턴스 변수 `@my_var` 는 클래스에 속한다.\n- 클래스의 인스턴스 변수는, 클래스 객체의 인스턴스 변수와 다르다\n- 두 개의 인스턴스 변수를 정의한 것 같은 이름이지만 서로 다른 범위, 서로 다른 객체\n- 클래스는 단지 객체임을 기억하고, self를 트래킹 해야함\n- obj을 self로 두느냐, MyClass를 self로 두느냐.\n- static field같은거임\n\n```ruby\nclass C\n  @@v = 1\nend\n\nclass D < C\n  def my_method; @@v; end\nend\nD.new.my_method # => 1\n```\n\n- 이게 더 스태틱변수같긴한데, 서브 클래스에서 접근 가능함\n\n```ruby\n@@v = 1\nclass MyClass\n  @@v = 2\nend\n@@v #=>2\n```\n\n- 하지만 쫌 ..\n\n- 클래스 변수가 클래스에 속하는 것이 아닌 클래스 계층에 속하기 때문\n- @@v는 main context에서 정의가 되므로 Object에 속한다.\n- 그리고 모든 Object의 후손들에게 ... MyClass는 Object를 상속하므로 동일한 클래스 변수를 공유\n- 그래서 대부분 클래스 변수를 피함, 최상위에서는 클래스 변수를 못쓰게 함\n\n### bookworm\n\n```ruby\nclass Loan\n  def initialize(book)\n    @book = book\n    @time = Time.now\n  end\n  def to_s\n    \"#{@book.upcase} loaned on #{@time}\"\n  end\nend\n```\n\n- Loan은 책 제목과 대출된 시간을 저장\n- to_s의 테스트를 작성하려면 객체가 생성된 정확한 시간을 알아야한다.\n- 하지만 매번 다른 결과이므로 ...\n\n```ruby\nclass Loan\n  def initialize(book)\n    @book = book\n    @time = Loan.time_class.now\n  end\n  def self.time_class\n    @time_class || Time\n  end\ndef to_s\n# ...\n```\n\n- time_class는 클래스를 반환하고 해당 클래스로 현재 시간을 갖고온다.\n- nil gurad로 인해 @time_class가 없으면 Time을 기본값으로 반환\n- 단위 테스트에선 항상 동일한 값을 반환하는 가짜 시간 클래스에 의존할 수 있다.\n\n```ruby\nclass FakeTime\n  def self.now; 'Mon Apr 06 12:15:50'; end\nend\n\nrequire 'test/unit'\nclass TestLoan < Test::Unit::TestCase\n  def test_conversion_to_string\n    Loan.instance_eval { @time_class = FakeTime }\n    loan = Loan.new('War and Peace')\n    assert_equal 'WAR AND PEACE loaned on Mon Apr 06 12:15:50', loan.to_s\n  end\nend\n```\n\n## 싱글톤 메서드\n\n- Paragraph 클래스는 문자열을 줄 바꿈한 다음 모든 호출을 줄 바꿈 문자열에 위임한다.\n  - title?은 문단이 모두 대문자이면 트루\n\n```ruby\nclass Paragraph\n  def initialize(text)\n    @text = text\n  end\n  def title?; @text.upcase == @text; end\n  def reverse; @text.reverse; end\n  def upcase; @text.upcase; end\n  #...\n\nend\n# ...\ndef index(paragraph)\n  add_to_index(paragraph) if paragraph.title?\nend\n# ...\n```\n\n- Paragraph는 한 곳에서 생성되고 title? 메서드는 인덱스라는 메서드에서 한 번만 호출된다\n- 이게 필요한가? 그냥 스트링 클래스를 몽키패치해서 title? 메서드를 추가?\n- 하지만 paragraph을 나타내는 문자열에서만 의미가 있고 다른 문자열에서는 의미가 없다.\n\n- 하나의 객체에 메서드를 추가하기\n\n```ruby\nstr = \"just a regular string\"\ndef str.title?\n  self.upcase == self\nend\nstr.title? # => false\nstr.methods.grep(/title?/) # => [:title?]\nstr.singleton_methods# => [:title?]\n```\n\n- `Object#define_singleton_method` 를 통해서 싱글톤 메서드를 정의할 수 있다.\n\n```ruby\nparagraph = \"any string can be a paragraph\"\ndef paragraph.title?\n  self.upcase == self\nend\nindex(paragraph)\n```\n\n### 클래스 메서드의 진실\n\n- Object Model에서 배운 내용을 기억하나? 클래스는 객체이고 클래스 이름은 상수이다.\n  - 클래스에서 메서드를 호출하는 것과 객체에서 호출이 같다라는 것을 알 수 있다.\n\n```ruby\nan_object.a_method\nAClass.a_class_method\n```\n\n- 하지만 싱글톤 메서드? 그게 바로 클래스 메서드!! - 클래스의 싱글톤 메서드이다.\n\n```ruby\ndef obj.a_singleton_method; end\ndef MyClass.another_class_method; end\n```\n\n- 앞의 정의에서 객체는 객체 참조, 상수 클래스 이름, 또는 그 자체일 수 있다. 구문은 다를 수 있지만 기본 메커니즘은 동일하다.\n\n### 클래스 매크로\n\n#### attr_accessor() example\n\n```ruby\nclass MyClass\n  def my_attribute=(value)\n    @my_attribute = value\n  end\n   def my_attribute\n    @my_attribute\n  end\nend\nobj = MyClass.new\nobj.my_attribute = 'x'\nobj.my_attribute\n```\n\n- 루비의 객체에는 속성이 없다.\n- 모방 메서드인 reader, writer를 정의 해야한다.\n- 위와 같은 정의는 금방 지루하다.\n\n```ruby\nclass MyClass\n  attr_accessor :my_attribute\nend\n```\n\n- attr_accessor은 w/r\n- attr_reader는 r\n- attr_writer 는 w를 생성\n- attr\\_\\*은 모듈 class에 정의되어 있으므로 모듈 또는 클래스일 때 사용 가능하다.\n- 이러한 메서드를 클래스 매크로라고 한다.\n- 키워드 처럼 보이지만 클래스 정의에 사용되는 메서드 일 뿐이다.\n\n#### Class Macros Applied\n\n- 북 클래스에는 몇가지 메서드가 있다, 이 메서드 이름을 바꾸면 호출자가 끊어지므로...\n- GetTitle -> title, LEND_TO_USER -> lend_to, title2 -> subtitle\n- 이전 이름을 deprecate 클래스 매크로로 메서드 이름을 바꿀 수 있다\n\n```ruby\nclass Book\n  def title # ...\n  def subtitle # ...\n  def lend_to(user)\n    puts \"Lending to #{user}\"\n    # ...\n  end\n  def self.deprecate(old_method, new_method)\n     define_method(old_method) do |*args, &block|\n      warn \"Warning: #{old_method}() is deprecated. Use #{new_method}().\"\n      send(new_method, *args, &block)\n  end\n  end\n    deprecate :GetTitle, :title\n    deprecate :LEND_TO_USER, :lend_to\n    deprecate :title2, :subtitle\nend\nb = Book.new\nb.LEND_TO_USER(\"Bill\")\n❮ Warning: LEND_TO_USER() is deprecated. Use lend_to(). Lending to Bill\n```\n\n- 이전 이름에 대한 호출을 탐지하는 동적 메서드를 정의\n- 경고창을 정의\n- 클래스 매크로를 사용하는 기발한 방법\n\n## 싱글톤 클래스\n\n### 싱글톤 메서드의 미스테리\n\n- Method Lookup에서 수신자의 클래스로 이동한 다음 클래스 계층 위로 올라가서 메서드를 찾는 방법을 배웠다.\n\n```ruby\nclass MyClass\n    def my_method; end\nend\nobj = MyClass.new\nobj.my_method\n\ndef obj.my_singleton_method; end\n\n```\n\n- 싱글톤 메서드에서는?\n- obj는 클래스가 아니므로 obj에서 살 수 없다.\n- MyClass나 Object에서도 마찬가지, 모든 클래스에 적용이 되어버리므로\n- 보이는 클래스 대신 객체는 자신만의 특수한 숨겨진 클래스를 가질 수 있다 -\n  - 이를 싱글톤 클래스라고 한다 ( 메타클래스 혹은 고유 클래스라고 부르기도 한다.)\n\n```ruby\nclass << an_object\n  # your code here\nend\n```\n\n- 싱글톤 클래스에 대한 참조를 가져오려면 스코프에서 자체적으로 반환 가능하다.\n\n```ruby\nobj = Object.new\nsingleton_class = class << obj\n  self\nend\nsingleton_class.class   # => Class\n\n\"abc\".singleton_class    # => #<Class:#<String:0x331df0>>\n```\n\n- `Object#singleton_class` 로도 얻을 수 있다.\n- 싱글톤 클래스는 << 구문 혹은 singleton_class 메서드를 사용 전에는 볼 수 없음\n- 단일 인스턴스에만 있고 상속될 수 없다.\n- 싱글톤 클래스는 객체의 싱글톤 메서드가 존재하는 곳이다.\n\n```ruby\ndef obj.my_singleton_method; end\nsingleton_class.instance_methods.grep(/my_/)  # => [:my_singleton_method]\n```\n\n### 메서드 조회 다시 보기\n\n- 예전 장에서 메서드 호출 시 발생하는 현상에서는 루비 객체 모델과 메서드 조회에 대해 배웠다.\n\n#### 메서드 조회 리뷰\n\n```ruby\nclass C\n  def a_method\n    'C#a_method()'\n  end\nend\nclass D < C; end\nobj = D.new\nobj.a_method    # => \"C#a_method()\"\n```\n\n![class](class.jpeg)\n\n#### 싱글톤 클래스와 매서드의 조회\n\n```ruby\nobj = Object.new\nobj.singleton_class  # => #<Class:#<Object:0x007fd96909b588>>\n```\n\n- #이 붙어있으면 싱글톤 클래스를 의미한다고 해보자\n  - #obj은 obj의 싱글톤 클래스 #C는 C의 싱글톤 클래스\n\n```RUBY\nclass << obj\n  def a_singleton_method\n    'obj#a_singleton_method()'\n  end\nend\n```\n\n- 싱글톤 클래스도 클래스이니 슈퍼 클래스가 있어야지?\n\n```ruby\nobj.singleton_class.superclass   # => D\n```\n\n![single.jpeg](single.jpeg)\n\n#### 싱글톤 클래스 및 상속\n\n```ruby\nclass C\n  class << self\n    def a_class_method\n      'C.a_class_method()'\n    end\n  end\nend\nC.singleton_class# => #<Class:C>\nD.singleton_class# => #<Class:D>\nD.singleton_class.superclass# => #<Class:C>\nC.singleton_class.superclass# => #<Class:Object>\n\n```\n\n![single.jpeg](singleton.jpeg)\n\n- C는 싱글톤클래스\n- S는 슈퍼클래스\n- 이 다이어그램은 모듈이 포함되어있지 않다. 완전히 그리려면 Object와 BasicObject사이에 Kernel모듈을 그릴 수 있지만 굳이,\n- 모듈들은 다른 객체들처럼 싱글톤 클래스를 가질 수 있지만 커널의 싱글톤 클래스는 obj나 #D의 상위 체인의 일부가 아니다.\n- 싱글톤의 슈퍼클래스는 싱글톤클래스\n- 이런 배열 덕분에 하위 클래스에서 클래스 메서드 호출이 가능한 것\n\n```ruby\nD.a_class_method # => \"C.a_class_method()\"\n```\n\n- a_class_method 가 C에 정의되어 있더라도 D에도 호출이 가능하다.\n- 메서드 조회가 #D에서 시작하여 #D의 #C로 올라가서 메서드를 찾기 때문에 가능하다.\n\n#### The Great Unified Theory\n\n- 클래스, 싱글톤 클래스, 모듈이 있다.\n- 인스턴스 메서드, 클래스 메서드, 싱글톤 메서드가 있다.\n- 싱글톤 클래스를 클래스와 모듈과 함께 사용하면 루비 객체 모델의 7가지 규칙이 나온다.\n\n1. 객체는 한 가지 종류만 있다. 일반 객체 혹은 모듈\n2. 모듈은 한가지 종류만 있다. 일반 모듈, 클래스 또는 싱글톤 클래스\n3. 한 가지 종류의 메서드가 있다. - 모듈에서 살고 대부분 클래스 안에 있다.\n4. 모든 객체, 클래스는 실제 클래스를 가진다 - 일반 클래스 혹은 싱글톤 클래스\n5. BasicObject를 제외한 모든 클래스에는 정확히 하나의 상위 클래스가 있다. - 즉 모든 클래스의 상위 항목부터 BasicObject까지의 체인을 가짐\n6. 객체의 싱글톤 클래스의 슈퍼클래스는 객체의 클래스이다. 한 클래스의 싱글톤 슈퍼클래스는 그 클래스의 싱글톤 클래스이다.\n7. 메서드를 호출하면 오른쪽으로 클래스로, 이동한 다음 조상 체인을 올라간다.\n\n#### Class Methods Syntaxes\n\n- 클래스 메서드는 클래스의 싱글톤 클래스에 있는 싱글톤 메서드이므로 이제 세 가지 방법을 사용 가능\n\n```ruby\ndef MyClass.a_class_method; end\nclass MyClass\n  def self.another_class_method; end\nend\nclass MyClass\n  class << self\n    def yet_another_class_method; end\n  end\nend\n```\n\n- 첫 번째는 클래스 이름이 중복되어 래팩터링이 어려우므로 ..\n- 세 번째는 trickiest , 싱글톤 클래스를 열고 메서드를 정의,\n  - 싱글톤 클래스를 명시적으로 인정하므로 쫌 치는 느낌이 난다.\n\n#### 싱글톤 클래스와 instance_eval()\n\n- instance_eval은 객체만 변화하고 class_eval은 자신과 current class 모두 변화한다고 배웠다.\n- 하지만 instance_eval은 current class도 변경한다 - 수신자의 싱글톤 클래스도 변경한다.\n\n```ruby\ns1, s2 = \"abc\", \"def\"\ns1.instance_eval do\n  def swoosh!; reverse; end\nend\ns1.swoosh!                # => \"cba\"\ns2.respond_to?(:swoosh!)  # => false\n```\n\n#### 클래스 속성\n\n- attr\\_\\*을 기억하는가?\n\n```ruby\nclass MyClass\n  attr_accessor :a\nend\nobj = MyClass.new\nobj.a = 2\nobj.a\n```\n\n- 대신 클래스에 속성을 정의하려면?\n\n```ruby\nclass MyClass; end\nclass Class\n  attr_accessor :b\nend\nMyClass.b = 42\nMyClass.b      # => 42\n```\n\n- 동작이야 하겠지만 모든 클래스에 속성이 추가됨, MyClass에 특화된 속성을 원한다면..\n\n```ruby\nclass MyClass\n  class << self\n    attr_accessor :c\n  end\nend\nMyClass.c = 'It works!'\nMyClass.c\n```\n\n- attribute는 단지 한쌍의 메서드이다.\n- 이런 메서드를 정의하면 클래스 메서드가 되는 것\n\n```ruby\ndef MyClass.c=(value)\n  @c = value\nend\ndef MyClass.c\n  @c\nend\n```\n\n## Method Wrappers\n\n```ruby\ndef deserves_a_look?(book)\n  amazon = Amazon.new\n  amazon.reviews_of(book).size > 20\nend\n```\n\n- 라이브러리 사용 예시\n- 대부분 작동하지만 예외 관리가 안된다.\n- Amazon이 원격 호출이 실패하면 이 문제를 기록하고 진행해야한다.\n- 라이브러리를 직접 수정하고 싶지 않다 라는 문제\n- 모든 클라이언트가 자동으로 추가 기능을 사용할 수 있도록 메서드를 사용하여 추가 기능을 래핑하려고 한다.\n\n### Around Aliases\n\n- 별칭 사용이 가능하다\n\n```ruby\nclass MyClass\n  def my_method; 'my_method()'; end\n  alias_method :m, :my_method\nend\nobj = MyClass.new\nobj.my_method   # => \"my_method()\"\nobj.m           # => \"my_method()\"\n\nclass MyClass\n  alias_method :m2, :m\nend\nobj.m2           # => \"my_method()\"\n```\n\n- 흔한 예시임, String#size, String#length, Integer클래스는 5개 이상의 다른 이름을 가진 메서드를 갖고있다.\n\n```ruby\nclass String\n  alias_method :real_length, :length\n  def length\n    real_length > 5 ? 'long' : 'short'\n  end\nend\n\"War and Peace\".length      # => \"long\"\n\"War and Peace\".real_length # => 13\n```\n\n- method를 재정의하지만 별칭은 여전히 원래 메서드를 참조한다.\n- 재정의 시 메서드는 실제로 변경되지 않는다. 기존 이름을 해당 새 메서드에 연결할 뿐\n- 흥미로운 예시임\n\n### The Thor Example\n\n- cli utilities를 만드는 잼임\n- Rake2thor라는 프로그램이 포함되어 있는데 이 프로그램은 빌드 파일을 토르 스크립트로 변환함\n- Rake2thor는 레이크 파일을 로드하고 해당 레이크 파일에 필요한 모든 파일의 이름을 저장해야한다.\n\n```ruby\ninput  = ARGV[0] || 'Rakefile'\n$requires = []\nmodule Kernel\n  def require_with_record(file)\n    $requires << file if caller[1] =~ /rake2thor:/\n    require_without_record file\n  end\n  alias_method :require_without_record, :require\n  alias_method :require, :require_with_record\nend\nload input\n```\n\n- 필요한 파일의 이름을 저장할 글로벌 어레이를 준비하고, 커널 모듈을 열고 메서드 별칭으로 몇 가지 트릭을 쓴다.\n- 그러고 마지막으로 rakefile을 로드한다.\n\n```ruby\nmodule Kernel\n  alias_method :require_without_record, :require\n  def require(file)\n    $requires << file if caller[1] =~ /rake2thor:/\n    require_without_record file\n  end\nend\n```\n\n- 단순화된 버전임\n- 위의 오픈클래스는 세 가지 일을 함\n  1. Kernel#require 을 다른 이름으로 별칭화\n  2. Monkeypatch는 rakefile에 필요한 require하는 이름들을 저장한다.\n  3. 마지막으로 원래 요구사항으로 돌아가고, 걔는 require_without_record라고 불리는 메서드로 별칭\n- 이 속임수를 around alias로 부름\n\n- Around Alias 작성법\n  1. Alias a method\n  2. Redefine it\n  3. Call the old method from the new method\n- additional method name으로 클래스를 오염시킨다.\n  - 구 버전의 메서드를 별칭으로 지정한 후 비공개로 만들면 해결 가능\n- 로딩과 관련된 잠재적인 문제, around method를 두 번 로드하면 안된다.\n- Monkey patch의 한 형태이다..... 따라서 이런 추가적인 기능을 래핑하는 두 가지 방법을 추가로 도입\n\n### More Method Wrappers\n\n```ruby\nmodule StringRefinement\n  refine String do\n    def length\n      super > 5 ? 'long' : 'short'\n    end\n  end\nend\nusing StringRefinement\n\"War and Peace\".length      # => \"long\"\n```\n\n- around alias보다는 일반적으로 안전하다.\n- 파일 끝, 혹은 모듈 정의 까지만 정의됨\n\n```ruby\nmodule ExplicitString\n  def length\n    super > 5 ? 'long' : 'short'\n  end\nend\nString.class_eval do\n  prepend ExplicitString\nend\n\"War and Peace\".length      # => \"long\"\n```\n\n- prepend wrapper로 사용 가능함\n- 로컬적이지는 않지만 refine이나 어라운드 별칭보다 더 깨끗하고 명확하다고 여겨진다.\n\n### Solving the Amazon Problem\n\n```ruby\nmodule AmazonWrapper\n  def reviews_of(book)\n    start = Time.now\n    result = super\n    time_taken = Time.now - start\n    puts \"reviews_of() took more than #{time_taken} seconds\" if time_taken > 2\n    result\n  rescue\n    puts \"reviews_of() failed\"\n    []\n  end\nend\nAmazon.class_eval do\n  prepend AmazonWrapper\nend\n```\n\n## Wrap-Up\n\n- 클래스 정의에서의 self ( 메서드 호출의 기본 수신기 ) 및 current class ( 정의하는 메서드의 기본 홈 ) 에 미치는 영향\n- signle tone method 및 signleton 클래스를 통해 객체 모델 및 메서드 검색에 대한 새로운 인사이트\n- 클래스 인스턴스 변수, 클래스 매크로 및 래퍼를 포함한 여러가지 트릭\n- 클래스에 대해 배운 모든 것을 모듈에 적용 가능함 - 클래스 인스턴스 변수는 모듈 인스턴스 변수일 수 있음\n"},{"excerpt":"Blocks 블록은 스코프를 제어하기 위한 강력한 도구 블록은 단지 호출 가능한 객체의 큰 구성원 블록을 저장하고 나중에 실행하는 등 이런 객체와 다른 호출 가능한 객체를 최대한 활용하는 방법 설명 예정 The Day of the Blocks Roadmap 블록 기초 범위 개요 및 블록 클로져를 사용한 변수의 범위 이동 블록을 호출 가능한 객체로 변환하여…","fields":{"slug":"/metaprogramming-ruby-4/"},"frontmatter":{"date":"April 22, 2021","title":"M Ruby - 4. Blocks","tags":["ruby","book"]},"rawMarkdownBody":"\n# Blocks\n\n- 블록은 스코프를 제어하기 위한 강력한 도구\n- 블록은 단지 호출 가능한 객체의 큰 구성원\n- 블록을 저장하고 나중에 실행하는 등 이런 객체와 다른 호출 가능한 객체를 최대한 활용하는 방법 설명 예정\n\n## The Day of the Blocks\n\n### Roadmap\n\n- 블록 기초\n- 범위 개요 및 블록 클로져를 사용한 변수의 범위 이동\n- 블록을 호출 가능한 객체로 변환하여 따로 두는 방법, Procs나 람다처럼 나중에 호출\n\n### The Basics of Blocks\n\n```ruby\ndef a_method(a, b)\n  a + yield(a, b)\nend\n\na_method(1, 2){ |x, y| (x+y)*3} #=> 3\n```\n\n- 중괄호나 `do..end` 로 정의할 수 있다.\n- 메서드를 호출할 때만 블록을 정의 가능\n- 블록은 메서드로 바로 전달되며 메소드는 `yield` 키워드로 블록을 다시 호출 가능\n- 블록은 인수를 가질수도 있다. 예시처럼 인수를 제공 가능\n- 블록은 메서드처럼 마지막 줄을 반환\n- `Kernel#block_given?` 으로 블록이 포함되어 있는지 확인 가능\n\n```ruby\ndef a_method\n  return yield if block_given?\n  'no block'\nend\na_method\na_method { \"here's a block!\" }\n# => \"no block\"\n# => \"here's a block!\"\n```\n\n## Blocks Are Closures\n\n- 코드가 실행할 때 지역변수, 인스턴스 변수, 셀프등이 필요..\n- 코드와 바인딩으로 이뤄져서 뭔가 실행되는 것\n- 이런 엔티티들은 객체에 바인딩된 것이므로 바인딩이라고 부르겠다?\n- 블록이 어디서 바인딩을 주워오는지....\n- 블록을 정의하는 순간 바인딩을 잡은 다음 블록을 메서드로 전달할 때... 함께 바인딩을 전달한다..\n\n```ruby\ndef my_method\n  x = \"Goodbye\"\n  yield(\"cruel\")\nend\nx = \"Hello\"\nmy_method {|y| \"#{x}, #{y} world\" } # => \"Hello, cruel world\"\n```\n\n- 블록을 생성할 때 x같은 로컬 바인딩을 캡쳐한다.\n- 블록을 별도의 바인딩 집합이 있는 메서드로 전달한다.\n- 여전히 블록의 코드는 블록에서 아예 안보이는 메서드의 x가 아닌 블록이 정의되었을 떄 있었던 x를 본다.\n\n```ruby\ndef just_yield\n  yield\nend\ntop_level_variable = 1\njust_yield do\n  top_level_variable += 1\n  local_to_block = 1\nend\ntop_level_variable  # => 2\nlocal_to_block      # => Error!\n```\n\n- 블록 내에서 추가 바인딩 정의도 가능하지만 블록 이후에 사라짐\n- 이런 특성때문에 블록을 클로져라고 하기도 하는듯\n- 다른 사람들은 블록이 로컬바인딩을 캡쳐하여 옮긴다고 함\n- 클로져를 실제로 어떻게 쓸까? 이를 이해하려면 바인딩의 위치, 즉 범위를 자세히 쌀펴야한다.\n\n### Scope\n\n#### Changing Scope\n\n- `Kernel#local_variables` 를 통해 바인딩의 이름을 추적하여 스코프 보는 예시\n\n```ruby\nv1 = 1\nclass MyClass\n  v2 = 2\n  local_variables # => [:v2]\n  def my_method\n    v3 = 3\n    local_variables\n  end\n  local_variables # => [:v2]\nend\nobj = MyClass.new\nobj.my_method # => [:v3]\nobj.my_method # => [:v3]\nlocal_variables # => [:v1, :obj]\n\n```\n\n- 루비에서는 자바나 C#처럼 내부의 스코프에서 외부의 스코프를 볼수있게 하지 않음, 즉 뚜력하게 구분됨\n- 새로운 범위를 들어가자마자 새로운 바인딩으로 대체됨\n- 클래스 내에서 v1이 다시 표시 안되는 것 처럼\n- 정의 끝날때까지.... 스코프 닫히고 다시 최상위로...\n- 만약 my_method를 재정의? 당연히 새 바인딩 세트\n\n### Scope Gates\n\n- 이전 스코프를 버리고 새 스코프를 여는 위치\n  - Class definitions\n  - Module definitions\n  - Methods\n\n```ruby\nv1 = 1\nclass MyClass # SCOPE GATE: entering class\n  v2 = 2\n  local_variables # => [\"v2\"]\n  def my_method # SCOPE GATE: entering def\n    v3 = 3\n    local_variables\n  end# SCOPE GATE: leaving def\n  local_variables # => [\"v2\"]\nend # SCOPE GATE: leaving class\nobj = MyClass.new\nobj.my_method # => [:v3]\nlocal_variables # => [:v1, :obj]\n```\n\n- 클래스나 모듈은 즉시 코드가 실행 됨\n- 메서드는 메서드 호출 시 실행됨\n- 바인딩이 변하는 위치를 알았는데 만약 변수를 하나 넘기고싶다면?\n\n### Flattening the Scope\n\n```ruby\nmy_var = \"Success\"\n  class MyClass\n    # We want to print my_var here...\n    def my_method\n      # ..and here\n    end\n  end\n\n```\n\n- my_var을 두 개의 장벽을 거쳐서 어떻게 전달하지..?\n\n```ruby\n my_var = \"Success\"\n➤ MyClass = Class.new do\n➤ # Now we can print my_var here...\n➤ puts \"#{my_var} in the class definition!\"\n    def my_method\n      # ...but how can we print it here?\n    end\nend\n```\n\n- Class를 Scope Gate가 아닌 메서드 호출로 바꿔서 전달한다면?\n- 이제 메서드에 전달하려면..?\n\n```ruby\nmy_var = \"Success\"\nMyClass = Class.new do\n  \"#{my_var} in the class definition\"\n  define_method :my_method do\n    \"#{my_var} in the method\"\n  end\nend\nMyClass.new.my_method\n\nrequire_relative \"../test/assertions\"\nassert_equals \"Success in the method\", MyClass.new.my_method\n\nSuccess in the class definition\nSuccess in the method\n```\n\n- Scope Gate를 메서드호출로 변경하면 한 스코프가 다른 스코프의 변수를 볼 수 있다.\n- 엄밀히 말하면 이걸 nested lexical scopes라고 부르고, 루비 코더들은 flattening the scope라고 함\n- flat scope\n\n#### Sharing the scope\n\n- 저거 알면 이제 스코프로 하고싶은거 다 할 수 있다.\n- 만약 몇 가지 메서드 간에 변수를 공유, 다른 사람이 해당 변수를 못하도록\n\n```ruby\ndef define_methods\n  shared = 0\n  Kernel.send :define_method, :counter do\n    shared\n  end\n  Kernel.send :define_method, :inc do |x|\n    shared += x\n  end\nend\n\ndefine_methods\n\ncounter       # => 0\ninc(4)\ncounter       # => 4\n```\n\n- 두개의 커널 메서드를 정의함\n- `Kernel#counter`, inc는 공유변수를 사용 가능\n- 하지만 다른 메서드에서는 확인 불가능\n- 이 공유 스코프는 실제로 많이 사용되지 않지만, 강력한 트릭이자 스코프으 ㅣ힘을 보여주는 에시\n- 스코프게이트, 플랫 스코프 및 공유 스코프를 함께 쓰면 스코프를 비틀거나 구부려서 원하는 위치에서 필요한 변수를 정확하게 확인 가능\n\n### Clousure Wrap Up\n\n- 각 스코프에는 여러 바인딩이 포함, 스코프는 스코프 게이트로 구분 된다 - class module def\n- 만약 Scope Gate를 통해 바인딩된 변수를 전달하려면 블록을 쓸 수 있다.\n- 블록은 클로져다, 블록을 정의하면 현재 환경에서 바인딩을 캡쳐하여 이동한다.\n- 따라서 Scope Gate를 메서드 호출로 바꾸고 클로저의 현재 바인딩을 캡쳐하고 클로져를 메서드로 전달 가능\n- Class.new, Module,new def를 Module define_method로 변경 가능\n- 기본적인 클로저 관련 매쥑 플랫 스코프\n- 스코프 게이트로 보호되는 동일한 플랫 스코프에서 여러 메서드를 정의하는 경우 이런 메서드가 바인딩 공유 가능 - 공유 스코프\n\n## instance_eval()\n\n- 컨텍스트에서 블록을 eval하는 `BasicObject#instance_eval`\n\n```ruby\nclass MyClass\n  def initialize\n    @v = 1\n  end\nend\nobj = MyClass.new\nobj.instance_eval do\n  self        # => #<MyClass:0x3340dc @v=1>\n  @v          # => 1\nend\n```\n\n- 블록은 리시버를 self로 해서 같이 evaluated 하므로 private method, instance variables에 접근이 가능하다.\n\n```ruby\nv=2\nobj.instance_eval { @v = v }\nobj.instance_eval { @v } # => 2\n```\n\n- instance_eval로 전달된 블록은 다른 블록처럼 해당 위치에서의 바인딩.\n- Flat Scope에서 evaluated되므로 .... v도 접근되고 @v도 접근이 가능\n- instance_eval로 전달되는 블록을 context probe라고 함?!\n  - 코드 조각이 객체 내부에서 동작....하는것...같이...\n\n### Breaking Encapsulation\n\n- Context Probe를 쓰면 캡슐화에 큰 피해\n- 실용적으로는 캡슐화가 방해되는 상황이 있다...?\n- 캡슐화를 깨는 또 다른 납든할 수 있는 이유는 거의 테스트!\n\n#### The Padrino Example\n\n- Padrino 는 Logger class를 정의함\n- Logger는 설정을 인스턴스 변수에 저장함\n- Padrino의 테스트는 응용프로그램의 로거 구성을 변경해야한다.\n- 새 로거를 만들고 구성하는 문제를 겪지 않고 context probe를 사용하여 구성을 변경한다.\n\n```ruby\ndescribe \"PadrinoLogger\" do\n  context 'for logger functionality' do\n    context \"static asset logging\" do\n      should 'not log static assets by default' do\n        # ...\n        get \"/images/something.png\"\n        assert_equal \"Foo\", body\n        assert_match \"\", Padrino.logger.log.string\n      end\n      should 'allow turning on static assets logging' do\n        Padrino.logger.instance_eval{ @log_static = true }\n        # ...\n        get \"/images/something.png\"\n        assert_equal \"Foo\", body\n        assert_match /GET/, Padrino.logger.log.string\n        Padrino.logger.instance_eval{ @log_static = false }\n      end\n    end\n    # ...\n```\n\n- 첫 테스트는 아무것도 기록하지 않는 것을 확인\n- 두 번째 테스트에서는 instance_eval로 로거의 구성을 변경하고 정적 파일 로깅을 활성화\n- 기록을 확인하고, 다시 비활성화\n- 루비의 다른 많은 것들과 마찬가지로 캡슐화는 무시할 수 있는 유연한 도구이며 이러한 위험을 받아들일지... 는 우리에게 달려있다.\n\n### Clean Rooms\n\n- 단지 객체를 생성한다 블록 안을 evaluate하기위해?\n- 이 객체는 Clean Room이라고 불린다.\n\n```ruby\nclass CleanRoom\n  def current_temperature\n   # ...\n  end\nend\nclean_room = CleanRoom.new\nclean_room.instance_eval do\n  if current_temperature < 20\n    # TODO: wear jacket\n  end\nend\n```\n\n- 클린 룸은 클록을 eval 할 수 있는 환경일 뿐\n- 이상적인 클린룸은 메서드 및 인스턴스 변수가 많지 않음 - 블록과 충돌때문에..?\n- BasicObject의 인스턴스는 Blank Slates이므로 좋은 클린룸을 제공한다.\n  - 너무 깨끗해서 String같은 표준 루비 상수도 없음. 절대경로 써야함 ::String 처럼\n\n## Callable Objects\n\n- 블록 사용은 두 단계의 과정\n  - 일부 코드를 따로 두고\n  - 블록을 호출하여 실행\n- \"코드 패키지 우선, 나중에 호출\"은 블록에만 국한된 게 아니다\n- proc 블록은 객체로 변경된 블록\n- lambda proc을 약간 변형한 것\n- methods\n\n### Proc Objects\n\n- 루비의 대부분은 객체지만 블록은 아니다?\n- 뭔 상관? -> 블록을 저장하고 나중에 쓰려한다. 그러려면 객체가 필요함\n- 이 문제를 해결하기위해 Proc, 객체로 변환된 블록임\n\n```ruby\ninc = Proc.new {|x| x + 1 }\n# more code...\ninc.call(2) # => 3\n```\n\n- Deferred Evaluation이라 함\n- 몇 가지 방법이 더 있음\n- lambda 로 만드는 것은 조금 차이가 있지만 대부분 원하는 것을 얻을 수 있다.\n\n```ruby\ndec = lambda {|x| x - 1 }\ndec.class # => Proc\ndec.call(2) # => 1\np = ->(x) { x+ 1 } #=> called stabby lambda operator\n```\n\n### The & Operator\n\n- 메서드로 블록을 넘겨서 사용하는 경우 대부분 yield로 충분하지만, 아닌 경우도 있음\n  - 블록을 다른 메서드에게 넘기고 싶다거나\n  - 블록을 Rroc로 변환하고싶다거나\n- 둘다 모두 블록을 사용하겠다고 말 해줘야함, - 블록을 바인딩하기 위해서는 \"&\" 가 필요함\n- 인수 목록의 마지막이여야 하고 &기호를 사용해야함\n\n```ruby\ndef math(a, b)\n  yield(a, b)\nend\ndef do_math(a, b, &operation)\n  math(a, b, &operation)\nend\ndo_math(2,3){|x,y|x*y} #=>6\n```\n\n- & 의 뜻은 \"나는 이 메서드로 전달되는 블록을 Proc으로 바꾸고 싶다\" 라는 뜻이다.\n\n```ruby\ndef my_method(&the_proc)\n  the_proc\nend\np = my_method {|name| \"Hello, #{name}!\" }\np.class         # => Proc\np.call(\"Bill\")  # => \"Hello, Bill!\"\n```\n\n- 바로 리턴해보면 Proc임\n- 다시 Proc을 블록으로 변경하고 싶다면? &를 또 쓰면 댐?\n\n```ruby\ndef my_method(greeting)\n  \"#{greeting}, #{yield}!\"\nend\nmy_proc = proc { \"Bill\" }\nmy_method(\"Hello\", &my_proc)\n```\n\n- &는 my_proc을 블록으로 변환하고 그 블록을 메서드로 전달한다.\n\n### The Higline example\n\n- 콘솔 입력 및 출력을 자동화 하는 잼\n- 쉼표로 구분된 사용자 입력을 수집하여 배열로 분할 가능\n\n```ruby\nrequire 'highline'\nhl = HighLine.new\nfriends = hl.ask(\"Friends?\", lambda {|s| s.split(',') })\nputs \"You're friends with: #{friends.inspect}\"\n❮ Friends?\n➾ Ivana, Roberto, Olaf\n❮ You're friends with: [\"Ivana\", \" Roberto\", \" Olaf\"]\n```\n\n- `HighLine#ask` 는 post processing 코드를 Proc으로 받아서 쓴다.\n- 왜 블록이 아닌 Proc이냐? - 다른 HighLine 메커니즘을 위해 예약되어있음\n\n```ruby\n name = hl.ask(\"Name?\", lambda {|s| s.capitalize })\n   puts \"Hello, #{name}\"\n❮ Name?\n➾ bill\n❮ Hello, Bill\n```\n\n### Procs vs Lambdas\n\n- 미묘하게 다른데 많이 혼란스러울 것 이다.\n- 대략적인 중요한 차이점 두가지\n  - 반환 키워드와 관련\n  - 인수 확인과 관련\n\n#### Procs, Lambdas and return\n\n- 리턴 키워드가 다른 것을 의미한다\n\n```ruby\ndef double(callable_object)\n  callable_object.call * 2\nend\nl = lambda { return 10 }\ndouble(l) # => 20\n\ndef another_double\n  p = Proc.new { return 10 }\n  result = p.call\n  puts result\n  return result * 2  # unreachable code!\nend\nanother_double # => 10\n```\n\n```ruby\np = Proc.new { return 10 }\ndouble(p)     # => LocalJumpError\np = Proc.new { 10 }\ndouble(p)     # => 20\n```\n\n- proc.call 하는 순간 그 리턴코드가 리턴 되어버리네...\n- 블록이 언랩되는 느낌인가?\n\n#### Procs, Lambdas, and Arity\n\n- 두 번째 차이점은 argument를 확인하는 것\n\n```ruby\np = Proc.new {|a, b| [a, b]}\np.call(1, 2, 3)   # => [1, 2]\np.call(1)         # => [1, nil]\nl = ->(a,b){ [a,b]}\nl.call(1,2,3) # => ArgumentError: wrong number of arguments (given 3, expected 2)\nl.call(1) # => ArgumentError: wrong number of arguments (given 1, expected 2)\n```\n\n- 람다는 에러, Proc은 초과인수 버림\n\n- 일반적으로 람다를 많이\n\n### Method Objects\n\n```ruby\nclass MyClass\n  def initialize(value)\n    @x = value\n  end\n  def my_method\n    @x\n  end\nend\nobject = MyClass.new(1)\nm = object.method :my_method\nm.call\n```\n\n- `Kernel#method` 로 메서드 자체를 메서드 객체로 얻을 수 있다.\n- 호출도 가능함.\n- ruby 2.1부터는 `Kernel#singleton_method` 라는 것도 있다는데..\n- Proc이랑 Lambda랑 유사 하지만... 중요한 차이\n- Lambda는 정의된 범위에서 eval\n- 메서드는 객체의 범위 에서 eval\n\n#### Unbound Methods\n\n- 클래스 또는 모듈에서 분리된 메서드\n- `Metdhod#unbind`를 통해서 메서드를 Unbound 메서드로 만들 수 있음\n- instance_method로도 만들 수 있음\n\n```ruby\nmodule MyModule\n  def my_method\n    42\n  end\nend\nunbound = MyModule.instance_method(:my_method)\nunbound.class              # => UnboundMethod\n```\n\n- unbound method를 호출할 순 없지만 호출할 수 있는 일반 메서드르 생성하는 데 사용 가능하다.\n- bind를 사용하여 객체에 바인딩 하면 된다.\n- 기존에는 클래스에서 가져온 동일한 클래스의 객체에만 바인딩 가능했지만 2.0부터는 다됨.\n\n```ruby\nString.class_eval do\n  define_method :another_method, unbound\nend\n\"abc\".another_method # => 42\n```\n\n- 매우 특이한 케이스에만 사용됨\n\n##### The Active Support Example\n\n- Active Support는 여러 유틸 중에서 해당 파일에 정의된 상수를 사용할 떄 자동으로 Ruby 파일을 로드하는 클래스 및 모듈 세트가 포함되어 있다.\n- 이 \"Autoloading\" 시스템은 `Kernel#load` 함수를 재정의 하는 Loadable이라는 모듈을 포함한다.\n- 클래스에 Loadable이 포함된 경우 Loadable#load는 상위 체인의 Kernel#load보다 낮아진다.\n- 따라서 Loadable#load가 호출 됨\n- 경우에 따라 Loadable#load를 제거하고 바닐라 Kernel#load를 사용하기도 하는데\n- 루비에는 언 인클루드가 없으므로 조상을 제거할 수 없다. 이럴떄..\n\n```ruby\nmodule Loadable\n  def self.exclude_from(base)\n    base.class_eval { define_method(:load, Kernel.instance_method(:load)) }\n  end\n\n  #...\n```\n\n- unboundmethod의 좋은 예고, 구체적인 문제에 대한 솔루션이기도 함\n- 즉 두 개의 로드 메서드가 동일하고 혼란스럽게 만드는 솔루션..\n\n## Callable Objects Wrap-Up\n\n- evaluate 가능한 코드 조각, 고유한 스코프를 가짐\n- Blocks - (objects는 아니지만 callable함 ) - 정의된 스코프 내에서 evaluated\n- Procs - Proc 클래스 객체임 블록과 마찬가지로 정의된 범위 내에서 eval\n- Lambdas - 똑같이 Procs의 객체지만 약간 다름, 똑같이 클로저고 정의되는 범위 안에서 eval\n- Method - 객체에 바인딩 된 메서드는 해당 객체의 범위 안에서 eval, 리바인드 가능,\n\n각 오브젝트 마다 미묘하게 다른 동작이 나타난다.\n\n메서드와 람다는 callable object로부터 반환하는 반면 Procs와 Block은 호출 가능한 객체의 원래 컨턱스트에서 반환을 한다.\n\n또한 다른 아리티를 가진 호출에 대해 다르게 반응한다.\n\n메서드가 더 엄격, 람다가 그만큼 엄격, 프록과 블록이 덜 엄격\n\n그럼에도 & 로 각 객체들이 변환 가능\n\n## Writing a Domain-Specific Language\n\n- RedFlag라는 영엄부 직원을 위한 모니터링 유틸리티\n- 주문이 늦을 때 총 매출이 너무 낮을 때 기본적으로 여러 가지 일이 발생할 때마다 메시지\n- DSL정도만 작성하면 된다.\n\n```ruby\nevent \"we're earning wads of money\" do\n    recent_orders = ...   # (read from database)\n    recent_orders > 1000\nend\n```\n\n- true 반환 시 메일, false는 패스\n- 시스템은 몇 분마다 모든 이벤트를 확인\n\n### Your First DSL\n\n```ruby\n def event(description)\n    puts \"ALERT: #{description}\" if yield\nend\nload 'events.rb'\n```\n\n```ruby\nevent \"an event that always happens\" do\n  true\nend\nevent \"an event that never happens\" do\n  false\nend\n```\n\n### Sharing Among Events\n\n- 이벤트를 작성하는 사람들은 이벤트 간에 데이터를 공유하고 싶어할 것이다...\n- DSL로 될까?두 개의 개별 이벤트가 동일한 변수에 액세스할 수 있나?\n\n```ruby\ndef monthly_sales\n  110   # TODO: read the real number from the database\nend\ntarget_sales = 100\nevent \"monthly sales are suspiciously high\" do\n    monthly_sales > target_sales\nend\n  event \"monthly sales are abysmally low\" do\n    monthly_sales < target_sales\nend\n\n```\n\n- flat scope가 있지~\n\n```ruby\n❮ ALERT: monthly sales are suspiciously high\n```\n\n- 하지만 변수들이 최상위 범위를 혼란스럽게 함.\n\n```ruby\nsetup do\n    puts \"Setting up sky\"\n    @sky_height = 100\nend\nsetup do\n    puts \"Setting up mountains\"\n    @mountains_height = 200\nend\nevent \"the sky is falling\" do\n    @sky_height < 300\nend\nevent \"it's getting closer\" do\n    @sky_height < @mountains_height\nend\nevent \"whoops... too late\" do\n    @sky_height < 0\nend\n\n# Setting up sky\n#Setting up mountains\n#ALERT: the sky is falling\n#Setting up sky\n#Setting up mountains\n#ALERT: it's getting closer\n#Setting up sky\n#Setting up mountains\n\n```\n\n- 세 이벤트 각각 이전의 모든 설정을 실행한다.\n- @변수로 , 이벤트가 변수를 읽을 수 있음\n- 모든 공유변수는 설정에서 초기화되고 이벤트에서 사용되므로 변수를 쉽게 추적 가능\n\n```ruby\ndef event(description, &block)\n  @events << {:description => description, :condition => block}\nend\n@events = []\nload 'events.rb'\n```\n\n- 새 이벤트 메서드는 이벤트 조건을 블록해서 Proc으로 변환,\n- 이벤트의 설명과 proc을 해시에 래핑하고 이벤트 배열에 저장\n- 배열은 글로벌 변수 및 최상위 인스턴스 변수이므로 이벤트 메서드 외부에서 초기화할 수 있다.\n\n```ruby\ndef setup(&block)\n  @setups << block\nend\ndef event(description, &block)\n  @events << {:description => description, :condition => block}\nend\n@setups = []\n@events = []\nload 'events.rb'\n@events.each do |event|\n  @setups.each do |setup|\n    setup.call\n  end\n  puts \"ALERT: #{event[:description]}\" if event[:condition].call\nend\n```\n\n- 하지만 setups과 events는 글로벌 변수같다..\n\n### Removing the \"Global\" Varaibles\n\n- Shared scope?\n\n```ruby\nlambda {\n  setups = []\n  events = []\n  Kernel.send :define_method, :setup do |&block|\n    setups << block\nend\n  Kernel.send :define_method, :event do |description, &block|\n    events << {:description => description, :condition => block}\nend\n  Kernel.send :define_method, :each_setup do |&block|\n    setups.each do |setup|\n      block.call setup\nend end\n  Kernel.send :define_method, :each_event do |&block|\n    events.each do |event|\n      block.call event\nend end\n}.call\n\nload 'events.rb'\neach_event do |event|\n  each_setup do |setup|\nsetup.call\nend\n  puts \"ALERT: #{event[:description]}\" if event[:condition].call\nend\n```\n\n- 추악한 글로벌 변수들은 사라졌지만...\n- 예전처럼 간단하진 않다\n\n### Adding a Clean Room\n\n```ruby\n\nevent \"define a shared variable\" do\n  @x = 1\nend\nevent \"change the variable\" do\n  @x = @x + 1\nend\n\n```\n\n- 이벤트가 설정을 통해 변수를 공유하기를 원하지만 이벤트가 서로의 변수를 공유할 필요는 없다.\n- 기능인지 버그인지는 우리에게 달려있다.\n- 이벤트가 가능한 독립적으로 동작해야한다면 클린룸에서 실행 가능\n\n```ruby\neach_event do |event|\n  env = Object.new\n  each_setup do |setup|\n    env.instance_eval &setup\n  end\n  puts \"ALERT: #{event[:description]}\" if env.instance_eval &(event[:condition])\nend\n```\n\n- 이제 해당 설정은 클린룸 역할을 하는 오브젝트의 컨텍스트에서 eval된다\n- 설정 및 이벤트의 인스턴스 변수는 최상위 인스턴스 변수가 아니라 클린룸의 인스턴스 변수\n- 최상위 인스턴스 변수가 아닌 클린룸의 인스턴스 변수이므로 .. 이벤트는 인스턴스 변수를 공유 못함\n- BasicObject를 사용할 수도 있지만 일반적인 메서드가 없음.\n\n## Wrap Up\n\n- Scope Gate가 무엇인지\n- 플랫 스코프와 공유 스코프를 사용하여 범위를 통해 바인딩을 표시하는 방법\n- 객체의 범위 - instance_eval, instance_exec 또는 클린룸에서 코드를 실행하는 방법\n- 블록을 객체(Proc)로 반환하고 돌리는 방법\n- 메소드를 객체로 (Method, UnboundMethod)로 변환하는 방법 및 되돌리기\n- Callable Object 유형간의 차이\n-\n"},{"excerpt":"Methods 자바나 C처럼 강타입 언어는 컴파일러가 모든 메서드 호출에 대해 수신 객체가 일치하는 메서드를 갖고있는지 확인한다. 정적 유형 검사라고 하며 정적 타입 언어가 이를 채택해서 사용함 파이썬이나 루비같은 동적 언어들은 컴파일러가 확인하지 않음 루비에서는 boilerplate method가 문제가 안되는데 이에 대해 알아보자~ 중복 문제 99$를…","fields":{"slug":"/metaprogramming-ruby-3/"},"frontmatter":{"date":"April 15, 2021","title":"M Ruby - 3. Methods","tags":["ruby","book"]},"rawMarkdownBody":"\n# Methods\n\n- 자바나 C처럼 강타입 언어는 컴파일러가 모든 메서드 호출에 대해 수신 객체가 일치하는 메서드를 갖고있는지 확인한다.\n  - 정적 유형 검사라고 하며 정적 타입 언어가 이를 채택해서 사용함\n- 파이썬이나 루비같은 동적 언어들은 컴파일러가 확인하지 않음\n- 루비에서는 boilerplate method가 문제가 안되는데 이에 대해 알아보자~\n\n## 중복 문제\n\n- 99$를 이상을 쓰는 컴퓨터 장비를 찾기\n\n### 레거시 시스템\n\n- DS(Data Source)라는 이름의 클래스 뒤에 레거시 시스템에 데이터들이 저장되어있다\n\n```ruby\nclass DS\n  def initialize # connect to data source...\n  def get_cpu_info(workstation_id) # ...\n  def get_cpu_price(workstation_id) # ...\n  def get_mouse_info(workstation_id) # ...\n  def get_mouse_price(workstation_id) # ...\n  def get_keyboard_info(workstation_id) # ...\n  def get_keyboard_price(workstation_id) # ...\n  def get_display_info(workstation_id) # ...\n  def get_display_price(workstation_id) # ...\n  # ...and so on\n```\n\n- `DS#initialize` 새 DS object를 만들 때 디비와 연결 된다.\n- 다른 메서드들(수십 개의)은 워크스테이션 id를 갖고 컴퓨터 부품에 대한 설명과 가격을 반환한다.\n\n```ruby\nds = DS.new\nds.get_cpu_info(42) # => \"2.9 Ghz quad-core\"\nds.get_cpu_price(42) # => 120\nds.get_mouse_info(42) # => \"Wireless Touch\"\nds.get_mouse_price(42)  # => 60\n```\n\n### Double, Treble,... Trouble\n\n- 각 어플리케이션에 맞는 객체로 DB를 래핑해야한다.\n- 즉, 각 컴퓨터가 객체여야 한다.\n- 이 객체는 각 구성요소에 대해 단일 메서드를 갖고있고 해당 구성 요소의 가격을 모두 설명하는 문자열을 반환한다.\n- 100$이상이면 주의를 끌기위해 별을 붙인다.\n\n```ruby\n#methods/computer/duplicated.rb\n\nclass Computer\n  def initialize(computer_id, data_source)\n    @id = computer_id\n    @data_source = data_source\n  end\n  def mouse\n    info = @data_source.get_mouse_info(@id)\n    price = @data_source.get_mouse_price(@id)\n    result = \"Mouse: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n  def cpu\n    info = @data_source.get_cpu_info(@id)\n    price = @data_source.get_cpu_price(@id)\n    result = \"Cpu: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n  def keyboard\n    info = @data_source.get_keyboard_info(@id)\n    price = @data_source.get_keyboard_price(@id)\n    result = \"Keyboard: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n# ...\nend\n```\n\n- 중복이 많다.\n- 메서드가 많다\n- 각 메서드에 대한 테스트를 작성해야한다.\n\n## 동적 메서드\n\n동적으로 메서드를 호출하고 정의하는 방법과 중복 코드를 제거하는 방법\n\n### 함수 동적으로 호출하기\n\n```ruby\nclass MyClass\n  def my_method(my_arg)\n    my_arg * 2\n  end\nend\nobj = MyClass.new\nobj.my_method(3)  # => 6\n```\n\n- 다른 방법으로 `MyClass#my_method` 대신 `Object#send` 을 사용할 수 있다.\n\n```ruby\nobj.send(:my_method, 3)\n```\n\n- 똑같이 my_method를 호출하지만 send를 사용해서 호출된다.\n- send를 사용하면 호출할 메서드를 결정하기 위해 마지막까지 기다릴 수 있다.\n- 이를 동적 디스패치라고 한다.\n\n#### Pry 예시\n\n- Pry는 irb의 좋은 대안 ( command line interpreter )\n- Pry 객체는 인터프리터의 설정을 갖고있음 - memory_size나 quite같은\n\n```ruby\nrequire \"pry\"\npry = Pry.new\npry.memory_size = 101\npry.memory_size\npry.quiet = true\n# => 101\n\nPry.memory_size # 각 속성의 기본값을 반환하는 메서드도 있다.\n```\n\n- Pry 인스턴스를 설정하려면 `Pry#refresh` 라는 메서드를 호출하면 된다.\n- 속성 이름을 새 값에 매핑하는 해시를 사용\n\n```ruby\npry.refresh(:memory_size => 99, :quiet => false)\npry.memory_size       # => 99\npry.quiet             # => false\n```\n\n- refresh는 할 일이 많음\n  - 각 속성을 (self.memory_size 등) 검토하고 기본값으로 초기화해야하며\n  - 해시 인수에 동일한 특성에 대한 새 값이 있나 확인 후 있으면 설정\n\n```ruby\n\ndef refresh(options={})\n  defaults[:memory_size] = Pry.memory_size\n  self.memory_size = options[:memory_size] if options[:memory_size]\n  defaults[:quiet] = Pry.quiet\n  self.quiet = options[:quiet] if options[:quiet]\n  # same for all the other attributes...\nend\n\n```\n\n- 이 두 줄은 각 속성마다 반복되어야 한다.\n\n```ruby\ndef refresh(options={})\n  defaults   = {}\n  attributes = [ :input, :output, :commands, :print, :quiet,\n                 :exception_handler, :hooks, :custom_completions,\n                 :prompt, :memory_size, :extra_sticky_locals ]\n  attributes.each do |attribute|\n    defaults[attribute] = Pry.send attribute\n  end\n  # ...\n  defaults.merge!(options).each do |key, value|\n    send(\"#{key}=\", value) if respond_to?(\"#{key}=\")\n  end\n\n  true\nend\n```\n\n- send로 기본 값을 읽는다.\n- 옵션 해시와 merge한다\n- memory_size=value 꼴로 call attribute accessor을 사용\n- respond_to? 는 Pry#memory_size= 이 있으면 true를 반환\n\n#### Privacy Matters\n\n- `Object#send` 는 private method를 포함하여 모든 메서드를 쓸수 있다.\n- 이러한 종류의 캡슐화 위반.... 불편하면 `public_send` 를 사용한다.\n- 하지만 야생의 루비코드는 이러한 우려를 거의 신경쓰지않음....\n- 오히려 많은 루비 프로그래머들이 send를 private method쓰려고 씀...\n- 동적 호출 봤고 동적 정의 보자~\n\n### 메서드를 동적으로 정의하기\n\n```ruby\nclass MyClass\n  define_method :my_method do |my_arg|\n    my_arg * 3\n  end\nend\n\nobj = MyClass.new\nobj.my_method(2)  # => 6\n\nrequire_relative '../test/assertions'\nassert_equals 6, obj.my_method(2)\n```\n\n- `Module#define_method` 를 사용, method name 하고 block만 넘기면 된다.\n- `Myclass` 내에서 실행 되므로 MyClass의 인스턴스 메서드로 정의됨\n- 동적 메서드라고 한다\n- define_method 키워드를 쓰면 런타임에 정의된 메서드의 이름을 결정 가능\n\n#### Computer 클래스 리팩터링\n\n```ruby\nclass Computer\n  def initialize(computer_id, data_source)\n    @id = computer_id\n    @data_source = data_source\n  end\n  def mouse\n    info = @data_source.get_mouse_info(@id)\n    price = @data_source.get_mouse_price(@id)\n    result = \"Mouse: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n  def cpu\n    info = @data_source.get_cpu_info(@id)\n    price = @data_source.get_cpu_price(@id)\n    result = \"Cpu: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n  def keyboard\n    info = @data_source.get_keyboard_info(@id)\n    price = @data_source.get_keyboard_price(@id)\n    result = \"Keyboard: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\n# ...\nend\n```\n\n**Step 1: 다이나믹 디스패치 추가**\n\n```ruby\n  class Computer\n    def initialize(computer_id, data_source)\n      @id = computer_id\n      @data_source = data_source\n    end\n    def mouse\n      component :mouse\n    end\n    def cpu\n      component :cpu\n    end\n    def keyboard\n      component :keyboard\n    end\n    def component(name)\n      info = @data_source.send \"get_#{name}_info\", @id\n      price = @data_source.send \"get_#{name}_price\", @id\n      result = \"#{name.capitalize}: #{info} ($#{price})\"\n      return \"* #{result}\" if price >= 100\n      result\n    end\nend\n```\n\n- 각 메서드를 component 메서드에 위임한다.\n- 하지만 아직도 중복이 많다.\n\n**Step 2: 동적 메서드 정의**\n\n```ruby\nclass Computer\n  def initialize(computer_id, data_source)\n    @id = computer_id\n    @data_source = data_source\n  end\n  def self.define_component(name)\n    define_method(name) do\n      info = @data_source.send \"get_#{name}_info\", @id\n      price = @data_source.send \"get_#{name}_price\", @id\n      result = \"#{name.capitalize}: #{info} ($#{price})\"\n      return \"* #{result}\" if price >= 100\n      result\n    end\n  end\n  define_component :mouse\n  define_component :cpu\n  define_component :keyboard\nend\n\n```\n\n- 여기서 self는 Computer임\n- `define_component`는 클래스 메서드\n\n**Step 3: 인트로스펙션으로 뿌리기**\n\n- 최소한의 중복만 있지만 완전히 제거가 가능하다.\n- `define_component` 에 대한 호출을 다 지운다.\n- 인트로스펙션으로 모든 컴포넌트의 이름을 추출한다..\n\n```ruby\nclass Computer\n  def initialize(computer_id, data_source)\n    @id = computer_id\n    @data_source = data_source\n    data_source.methods.grep(/^get_(.*)_info$/) { Computer.define_component $1 }\n  end\n  def self.define_component(name)\n    define_method(name) do\n      #...\n    end\n  end\nend\n```\n\n- 블록을 grep에 `$1` 에 저장 된다.\n- 중복 코드가 다 사라졌다.\n- 요소를 추가하거나 유지 관리할 필요가 없으며 DS에 새 컴포넌트를 추가하면 컴퓨터 클래스에서 자동으로 지원한다\n\n## method_missing\n\n- Ghost Method와 Dynamic Proxies...\n- 루비에서는 컴파일러가 메서드 정의를 강제하지 않으니 없는 메서드를 호출할 수도있다.\n\n```ruby\nclass Lawyer; end\nnick = Lawyer.new\nnick.talk_simple\n❮ NoMethodError: undefined method `talk_simple' for #<Lawyer:0x007f801aa81938>\n```\n\n- 메서드 조회가 어떤식으로 진행되는지 기억하나?\n  - nick의 클래스로 들어가 인스턴스 메서드를 탐색\n  - Object로 이동한다음 ... BasicObject로 이동...\n  - method_missing..\n\n```ruby\nnick.send :method_missing, :my_method\n❮ NoMethodError: undefined method `my_method' for #<Lawyer:0x007f801b0f4978>\n```\n\n### Overriding method_missing\n\n- unknown messages를 인터셉트하여 override가 가능하다\n- 각 메시지는 `method_missing` 에서 함수 이름과 매개변수 그리고 호출시 불러진 블록을 포함한다.\n\n```ruby\nclass Lawyer\n    def method_missing(method, *args)\n      puts \"You called: #{method}(#{args.join(', ')})\"\n      puts \"(You also passed it a block)\" if block_given?\n    end\nend\n  bob = Lawyer.new\n  bob.talk_simple('a', 'b') do\n# a block\nend\n❮ You called: talk_simple(a, b)\n(You also passed it a block)\n```\n\n#### 고스트 메서드\n\n- 유사한 메서드를 많이 정의해야 할 경우 method_missing을 통해 직접 정의를 내리고 호출에 응답할 수 있다.\n- 만약 뭔가를 물었는데 이해 못하면 이렇게 하세요 라고 하는 것과 같다.\n- 호출자 쪽에선 method_missing에 의해 처리되는 일반 호출처럼 보인다.\n- 수신자에선 이에 상응하는 메서드가 없다..\n- 이를 고스트메서드라고 한다.\n\n##### The Hashie Example\n\n- Hashie Gem.... Hashie::Mash ..\n- Mash는 루비의 더 강력한 버전의 OpenStruct class\n  - 루비의 변수처럼 동작하는 hash같은 객체\n- 만약 새 속성이 필요하면 지정만 하면 사용이 가능함\n\n```ruby\nrequire 'hashie'\nicecream = Hashie::Mash.new\nicecream.flavor = \"strawberry\"\nicecream.flavor                 # => \"strawberry\"\n```\n\n```ruby\nmodule Hashie\n  class Mash < Hashie::Hash\n    def method_missing(method_name, *args, &blk)\n      return self.[](method_name, &blk) if key?(method_name)\n      match = method_name.to_s.match(/(.*?)([?=!]?)$/)\n      case match[2]\n      when \"=\"\n        self[match[1]] = args.first\n      # ...\n      else\n        default(method_name, *args, &blk)\n      end\n    end\n  # ...\n  end\nend\n```\n\n- method이름이 =으로 끝나면 method_missing은 속성의 값을 갖고오기 위해 '=' 을 잘라낸 다음 값을 저장.\n- 호출된 메서드의 이름이 일치하지 않으면 기본값만 반환한다.\n\n#### 다이나믹 프록시\n\n- 고스트 메서드는 좋긴 한데 어떤 객체들은 거의 전적으로 의존함\n- 이런 객체들은 다른 언어로 작성된 객체, 웹서비스 의 래퍼이기도 함\n- 메서드 호출을 method_missing을 통해 수집하여 래핑된 객체에 전달한다.\n\n##### The Ghee Example\n\n- Ghee를 통해 gist에 접근하는 방법\n\n```ruby\nrequire \"ghee\"\ngh = Ghee.basic_auth(\"usr\", \"pwd\")  # Your GitHub username and password\nall_gists = gh.users(\"nusco\").gists\na_gist = all_gists[20]\n\na_gist.url            # => \"https://api.github.com/gists/535077\"\na_gist.description    # => \"Spell: Dynamic Proxy\"\n\na_gist.star\n```\n\n- nusco의 gist를 찾아 측정 gist를 선택\n- url, desc를 찍고 star를 남김\n- github의 api는 gist 외에도 수십 가지 유형의 객체를 노출한다.\n- ghee는 이 모든 객체를 지원해야한다\n\n```ruby\nclass Ghee\n  class ResourceProxy\n  # ...\n    def method_missing(message, *args, &block)\n      subject.send(message, *args, &block)\n    end\n    def subject\n      @subject ||= connection.get(path_prefix){|req| req.params.merge!params }.body\n    end\n  end\nend\n\n```\n\n- 먼저 어떻게 사용하는지를 알아야함\n- github의 각 유형에 Ghee는 하위 클래스를 정의한다. ( `Ghee::ResourceProxy`)\n\n```ruby\nclass Ghee\n  module API\n    module Gists\n      class Proxy < ::Ghee::ResourceProxy\n        def star\n          connection.put(\"#{path_prefix}/star\").status == 204\n        end\n# ...\n      end\n    end\nend\n```\n\n- 만약 객체의 상태를 변경하는 메서드를 호출할 때 ( star처럼 ) Ghee는 해당 github url http 호출을 한다.\n- 하지만 url이나 desc같이 속성에서 읽기만 하는 호출은 `Ghee::ResourceProxy#method_missing`에서 끝난다.\n- missing_method는 메시지를 subject에게 포워드한다.\n- subject의 구현을 자세히 보면 이 메서드가 github api http 호출을 한다.\n- JSON형식의 github 객체를 받아서 해시 같은 객체로 변환함\n- 그럼 다시 method_missing에서 url attribute를 반환함\n\n음 우아하지만 메타프로그래밍이 너무 많이 들어가 있어서 헷갈린다.\n\n1. Ghee는 github 객체를 동적 해시로 저장한다. 액세스 할 수있다.\n2. Ghost Method를 호출하여 이러한 해시 특성을 확인할 수 있다.\n3. Ghee는 또한 이러한 해시를 프록시 객체 안에 래핑하여 추가적인 메소드를 통해 더욱 풍부하게 한다.\n   - 프록시는 특정 코드가 필요한 메소드를 구현 ( star 처럼 )\n   - url과 같이 데이터만 읽는 메서드를 래핑된 해시에 전달\n\n이러한 2단계 디자인 덕에 코드를 매우 압축적으로 유지한다.\n\ngithub api 의 변화에 자동 적응\n\n#### Refactoring the Computer Class (Again)\n\n```ruby\nclass Computer\n  def  initialize(computer_id, data_source)\n    @id = computer_id\n    @data_source = data_source\n  end\n  def method_missing(name)\n    super if !@data_source.respond_to?(\"get_#{name}_info\")\n    info = @data_source.send(\"get_#{name}_info\", @id)\n    price = @data_source.send(\"get_#{name}_price\", @id)\n    result = \"#{name.capitalize}: #{info} ($#{price})\"\n    return \"* #{result}\" if price >= 100\n    result\n  end\nend\n\n```\n\n#### respond_to_missing?\n\n- 만약 컴퓨터에 respond_to? 를 사용하면 ..\n\n```ruby\ncmp = Computer.new(0, DS.new)\ncmp.respond_to?(:mouse)       # => false\n```\n\n- 문제가 될 수 있음\n- 다행히 이를 위한 메커니즘\n\n```ruby\nclass Computer\n  def respond_to_missing?(method, include_private = false)\n    @data_source.respond_to?(\"get_#{method}_info\") || super\n  end\nend\n```\n\n### const_missing\n\n- Rake에서 충돌 가능성이 높은 클래스 이름을 모듈로 변경했다는 것..\n- 이름 변경 후 이전 버전, 현재 버전 몽키패치\n\n```ruby\nclass Module\n    def const_missing(const_name)\n      case const_name\n      when :Task\n        Rake.application.const_warning(const_name)\n        Rake::Task\n      when :FileTask\n        Rake.application.const_warning(const_name)\n        Rake::FileTask\n      when :FileCreationTask\n    end\n  end\nend\n```\n\n- 존재하지 않는 상수를 참조할 때 루비는 상수의 이름을 심볼로 전달\n- 클래스 이름은 상수이므로 ...\n- 더이상 사용되지 않는 클래스 이름을 사용중임을 경고\n\n```ruby\nrequire 'rake'\n  task_class = Task\n❮ WARNING: Deprecated reference to top-level constant 'Task' found [...] Use --classic-namespace on rake command\nor 'require \"rake/classic_namespace\"' in Rakefile\n\ntask_class # => Rake::Task\n\n```\n\n### 리팩터링 마무리\n\n- 두 가지 다른 방법으로 풀었다.\n- 동적 메서드와 동적 디스패치를 사용\n- 고스트 메서드를 사용\n\n## 빈 슬레이트\n\n- 디스플레이가 작동하지 않는다..\n\n```ruby\nmy_computer = Computer.new(42, DS.new).\nmy_computer.display # => 0\nObject.instance_method.grep /^d/ #=> [:dup, display, ...]\n```\n\n- 이미 있으므로 metho_missing에 도달하지 않는다.\n\n### BasicObject\n\n- 베이직오브젝트는 소수의 인스턴스 메서드만 있음\n\n```ruby\nim = BasicObject.instance_methods\nim # => [:==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]\n```\n\n- 슈퍼 클래스를 지정하지 않으면 Object에서 상속되며\n- 빈 슬레이트를 원하면 대신 BasicObject에서 직접 상속할 수 있다.\n- 하지만 특정 메서드를 제거하는게 더 빠를때도\n\n### Removing Methods\n\n- `Module#undef_method` 혹은 `Module#remove_method` 를 사용하여 클래스에서 메서드를 제거할 수 있음\n- `undef_method` 는 상속된 메서드를 모함한 모든 메서드를 제거함\n\n#### The Builder Example\n\n- Builder gem은 XML 제너레이터\n\n```ruby\nrequire 'builder'\n  xml = Builder::XmlMarkup.new(:target=>STDOUT, :indent=>2)\n  xml.coder {\n    xml.name 'Matsumoto', :nickname => 'Matz'\n    xml.language 'Ruby'\n}\n#This code produces the following snippet of XML:\n❮ <coder>\n<name nickname=\"Matz\">Matsumoto</name> <language>Ruby</language>\n</coder>\n```\n\n- 빌더는 중첩된 태그, 속성 등을 지원하기위해 ...\n- 핵심 아이디어는 이름과 언어와 같은 호출은 모든 호출에 대해 XML태그를 생성하는 `XmlMarkup#method_missing` 에 의해 처리됨\n\n```ruby\nxml.semester {\n  xml.class 'Egyptology'\n  xml.class 'Ornithology'\n}\n❮ <semester> <class>Egyptology</class> <class>Ornithology</class>\n</semester>\n```\n\nXmlMarkup이 Object의 하위 클래스인 경우 충돌하지만 메서드를 제거하는 Blank Slate를 상속함\n\n```ruby\n  class BlankSlate\n    # Hide the method named +name+ in the BlankSlate class.  Don't\n    # hide +instance_eval+ or any method beginning with \"__\".\n    def self.hide(name)\n      # ...\n      if instance_methods.include?(name._blankslate_as_name) &&\n          name !~ /^(__|instance_eval$)/\n        undef_method name\n      end\n    end\n# ...\n    instance_methods.each { |m| hide(m) }\nend\n```\n\n- 모든 메서드를 다 제거하진 않는다? instance_eval하고 루비에 의해 예약 메소드를 보관 - send\n- 제거는 가능하지만 제거 안함\n\n### Computer Class 고치기\n\n```ruby\nclass Computer < BasicObject\n```\n\nBasicObject에는 `response_to?` 가 없음\n\n`response_to_missing` 다시 제거\n\n## 마무리\n\n- 동적 메서드 및 독적 디스패치로 리팩토링 하였고\n- 고스트 메서드로도 수정함,\n- 고스트 메서드는 위험할 수 있음\n  - super를 항상 호출 하고, response_to_missing 재정의 를 하면 방지\n  - 가끔 버그를 일으킬 수 있음\n  - 메서드목록에서 반환 안됨\n- 하지만 고스트 메서드가 유일한 실행 가능한 선택일수도..\n- 메서드가 많거나 런타임에 필요한 메서드 호출을 모를때\n- Builder - XML 예제처럼\n- 스타일에 따라 다르긴 하겠지만 의심스러우면 동적 방법, 필요하면 고스트\n"},{"excerpt":"이제 시작이지만 재밌다. The Object Model 클래스, 모듈, 인스턴스 변수 등과 같은 언어의 구성 요소들은 Object Model이라는 시스템 모델에서 살아간다. Object Model에서 우린 \"이 메서드는 어떤 클래스의 것 인가요?\" 혹은 \"이 모듈을 포함하면 어떻게 되나요?\" 같은 답을 찾을 수 있다. 루비의 핵심인 Object Model…","fields":{"slug":"/metaprogramming-ruby-2/"},"frontmatter":{"date":"April 08, 2021","title":"M Ruby - 2. The Object Model","tags":["ruby","book"]},"rawMarkdownBody":"\n이제 시작이지만 재밌다.\n\n# The Object Model\n\n- 클래스, 모듈, 인스턴스 변수 등과 같은 언어의 구성 요소들은 Object Model이라는 시스템 모델에서 살아간다.\n- Object Model에서 우린 \"이 메서드는 어떤 클래스의 것 인가요?\" 혹은 \"이 모듈을 포함하면 어떻게 되나요?\" 같은 답을 찾을 수 있다.\n- 루비의 **핵심**인 Object Model !\n\n## 오픈 클래스 - Open Classes\n\n- 특수문자 및 숫자를 제거하는 메서드와 그의 테스트 코드를 생각해 보자.\n- `test/unit` 은 `gem install test-unit` 이나 `bundle add test-unit`\n\n```ruby\nrequire 'test/unit'\n\ndef to_alphanumeric(s)\n  s.gsub(/[^\\w\\s]/, '')\nend\n\nclass ToAlphanumericTest < Test::Unit::TestCase\n  def test_strip_non_alphanumeric\n    assert_equal 'qwer asdf 1234', to_alphanumeric('qwer !@#a.sdf 1@@23#4')\n  end\nend\n```\n\n- `to_alphanumeric` 은 객체 지향적이지 않다.\n- 외부 메서드를 사용하는 것 보다 문자열이 직접 바꿀 수 있다면 더 좋을 것이다.\n- 하지만 그냥 일반적인 문자열인데... 메서드를 추가하려면 `AlphanumericString` 이런식의 클래스를 새로 작성???\n\n**간단한 해결책**\n\n```ruby\nrequire 'test/unit'\n\nclass String\n  def to_alphanumeric\n    gsub(/[^\\w\\s]/, '')\n  end\nend\n\nclass StringExtensionsTest < Test::Unit::TestCase\n  def test_strip_non_alphanumeric\n    assert_equal 'qwer asdf 1234', 'qwer !@#a.sdf 1@@23#4'.to_alphanumeric\n  end\nend\n```\n\n### Inside Class Definitions\n\n- 루비에서는 클래스를 정의하는 코드와 다른 종류의 코드가 차이가 없다.\n- 클래스 정의에 아무 코드나 넣을 수 있다.\n\n```ruby\n# hello.rb\n3.times do\n    class Hello\n      puts \"Hello\"\n    end\nend\n```\n\n```sh\nruby hello.rb\nHello\nHello\nHello\n```\n\n- 다른 코드처럼 클래스 내에서 코드가 실행 되었다!\n- 그럼 위의 코드는 같은 이름으로 서로 다른 세 개의 클래스를 정의한 것일까?\n\n```ruby\nclass Hello\n  def a\n    'a'\n  end\nend\nclass Hello\n  def b; 'b'; end\nend\n\nhello = Hello.new\nhello.a # => \"a\"\nhello.b # => \"b\"\n```\n\n- 처음 `Hello` 를 정의할 때는 `Hello` 라는 이름의 클래스가 존재하지 않는다.\n- 따라서 루비는 클래스와 메서드 `a` 를 정의한다.\n- 두 번째 에서는 클래스 `Hello` 는 이미 존재하기 때문에 정의할 필요가 없다.\n- 기존 클래스를 열고 y라는 메서드를 정의한다.\n\n루비의 클래스 키워드는 클래스를 선언하는 것 보다는 스코프 연산자에 가깝다.\n\n메서드를 정의할 수 있는 곳이 클래스의 컨텍스트에서 사용자로 이동\n\n기존 클래스를 언제든지 다시 열고 표준 라이브러리 클래스도 즉시 수정할 수 있다.\n\n이를 **오픈 클래스**라고 부른다.\n\n다른 예시를 한번 보자!\n\n#### The Money Example\n\n- 통화 관련 유틸리티 라이브러리인 [**Monetize**](https://github.com/RubyMoney/monetize) Gem에서 오픈 클래스의 예를 찾을 수 있다.\n- `bundle add monetize`\n\n```ruby\nrequire \"monetize\"\n#I18n.config.available_locales = :en\n\nprice = Monetize.from_numeric(100, \"USD\")\nprice.format # => \"$10.00\"\n```\n\n- 이를 `Numeric#to_money` 을 통해서 숫자를 Money 로 만들 수 있다.\n\n```ruby\nrequire \"monetize\"\n#I18n.config.available_locales = :en\n\nprice = 10.to_money\nprice.format\n```\n\n- Numeric은 Ruby의 스탠다드 클래스이다. `Numeric#to_money` 는 어디서 온 걸까?\n\n[lib/monetize/core_extensions/numeric.rb](https://github.com/RubyMoney/monetize/blob/main/lib/monetize/core_extensions/numeric.rb)\n\n```ruby\nclass Numeric\n  def to_money(currency = nil)\n    Monetize.from_numeric(self, currency || Money.default_currency)\n  end\nend\n```\n\n- 라이브러리에서 Open Class를 이런 방식으로 사용하는 것은 매우 일반적이다!\n- 하지만 나쁜 케이스도 있다...\n\n### The Problem with Open Classes\n\n- 배열의 요소를 바꾸는 메서드를 생각해보자\n\n```ruby\nrequire 'test/unit'\ndef replace(array, original, replacement)\n  array.map {|e| e == original ? replacement : e }\nend\n\n# ...\n  def test_replace\n    original = ['one', 'two', 'one', 'three']\n    replaced = replace(original, 'one', 'zero')\n    assert_equal ['zero', 'two', 'zero', 'three'], replaced\n  end\n\n```\n\n- 메서드의 내부 동작보다 유닛 테스트를 통해 어떻게 사용되는지 확인이 가능하다.\n- 이번에도 `replace`라는 메서드를 Array 클래스에 새로 추가해도 되겠지?\n\n- 하지만... `irb` 를 실행하고 Array의 기본 메서드 목록을 받아보면\n\n```sh\n> irb\nirb(main):001:0> [].methods.grep /^replace/\n=> [:replace]\n```\n\n- 이미 `Array`는 `replace` 라는 메서드를 갖고있다.\n- 이를 overwrite해버리면 다른 코드에서 문제가 발생할 수 있다.\n- 이게 바로 **Open Classes의 어두운 면이다**\n- 이런식으로 클래스를 무모하게 Patching -> MonkeyPatch 라고 불린다..\n\n## Inside the Object Model\n\n루비의 클래스, 그리고 object model에 대한 몇몇 진실은 꽤 충격적!\n\n일단 기본부터 시작해보자.\n\n### What's in an Object\n\n```ruby\nclass MyClass\n  def my_method\n    @val = 1\n  end\nend\nobj = MyClass.new\nobj.class #=> Myclass\n```\n\n#### Instance Variables\n\n- 객체에는 인스턴스 변수가 포함되어있다.\n- `Object#instance_variables` 로 확인이 가능하다.\n\n```ruby\nobj.my_method\nobj.instance_variables\n```\n\n- 자바나 다른 정적 언어와 달리 루비에서는 클래스와 인스턴스 변수 사이의 연결이 없다.\n- 만약 `obj.my_method` 를 호출하지 않았다면 `obj` 는 인스턴스 변수가 없었을 것이다.\n\n#### Methods\n\n- `Object#methods` 를 통해 메서드의 리스트를 얻을 수 있다.\n- `obj.methods` 를 하면 `Object` 로부터 많은 메서드를 상속하므로 꽤나 길다!\n- `Array#grep` 으로 필터링해서 봐보면\n\n```ruby\nobj.methods.grep(/my/) #=> [:my_methods]\n```\n\n- `pry` 를 열고 `obj` 을 보면 실제로 메서드 목록을 갖고있지 않다는 것을 알 수 있다.\n- ![](2021-04-08-08-25-03.png)\n\n* 객체는 해당 인스턴스 변수와 클래스에 대한 참조만 있다.\n* 동일한 클래스를 공유하는 객체도 동일한 메서드를 공유하므로 메서드는 객체가 아닌 클래스에 저장되어야 한다.\n\n![](2021-04-08-09-25-03.png)\n\n- obj 는 my_methods를 갖고있다.\n- `MyClass` 에는 my_method라는 이름의 메서드가 있다 라고 하면 안된다.\n  - `MyClass.my_method` 를 클래스 메서드처럼 호출할 수 있다는 의미\n- 모호함을 없애기 위해 my_method가 MyClass의 인스턴스 메서드라고 해야한다.\n- 이 설명을 기억한다면 다음과 같은 introspective code를 작성할 때 혼동하지 않을 것이다.\n\n```ruby\nString.instance_methods == \"hello\".methods    # => true\nString.methods == \"hello\".methods             # => false\n```\n\n자 정리해보자, **객체**의 **인스턴스 변수는 객체**에 존재하고 객체의 **메서드는 클래스**에 존재한다. 따라서 같은 클래스의 객체는 메서드는 공유하지만 인스턴스 변수는 공유하지 않는다.\n\n### Thre Truth About Classes\n\n- 클래스는 오브젝트에 불과하다.\n- 클래스는 객체이므로 다른 객체에 적용되는 것들이 클래스에도 적용이 된다.\n- 클래스는 다른 객체와 마찬가지로 클래스라는 자체 클래스가 있다.\n\n```ruby\n\"hello\".class   # => String\nString.class    # => Class\n```\n\n- 다른 객체를 조작하는 것 처럼 조작이 가능하다!\n- [Chapter 5](/metaprogramming-ruby-5) 에서 처럼 `Class.new` 를 호출하여 프로그램이 실행되는 동안 새 클래스를 만들 수 있다.\n- 이런 유연성이 루비의 메타프로그래밍의 전형적인 특징\n- 클래스의 메서드는 클래스의 인스턴스 메서드!\n\n```ruby\nClass.instance_methods(false)   # => [:allocate, :new, :superclass]\n```\n\n- `new`는 항상 객체를 생성할 때 사용하니까 다들 알죠?\n- `superclass ` 는 상속과 관련있다. 루비의 클래스는 그 슈퍼클래스에서 상속된다.\n\n```ruby\nArray.superclass        # => Object\nObject.superclass       # => BasicObject\nBasicObject.superclass  # => nil\n```\n\n- `Array`는 `Object` 를 상속받고 `Object ` 에는 `to_s` 같은 객체에 일반적으로 유용한 메서드를 포함한다.\n- `Object` 는 `BasicObject` 에서 상속된다. 여기엔 몇가지 필수 메서드만 포함\n- `Class` 의 슈퍼클래스는 무엇일까?\n\n#### Modules\n\n```ruby\nClass.superclass        # => Module\n```\n\n- 클래스의 슈퍼클래스는 모듈이다.\n- 클래스는 객체를 만들거나 클래스를 계층 구조로 정렬할 수 있는 세 가지 인스턴스 메서드가 추가로 포함된 모듈이다.\n  - new, allocate, superclass\n- 모듈은 보통 어딘가에 포함되려고,\n- 클래스는 인스턴스화 되거나 상속되려면 클래스\n\n### Constants\n\n- 클래스 및 모듈의 이름을 포함하여 대문자로 시작하는 모든 참조는 상수이다.\n- 경고를 받긴 하겠지만 상수의 값을 변경할 수 있다.\n- 그럼 변수랑 상수가 뭐가 다른가? - 스코프가 다르다. 상수의 스코프는 고유한 특수 규칙이 있다.\n\n```ruby\nmodule MyModule\n  MyConstant = 'Outer constant'\n  class MyClass\n    MyConstant = 'Inner constant'\nend end\n```\n\n![](2021-04-08-10-11-34.png)\n\n- 모든 상수는 파일 시스템과 유사한 트리에 배열되어 있다\n- 모듈, 클래스는 디렉터리이고 상수는 파일임\n- 동일한 이름을 가진 여러 파일을 가질 수 있다\n- 파일 처럼 상수를 경로로 나타낼 수도 있다.\n\n#### The Paths of Constants\n\n```ruby\nX = 'a root-level constant'\nmodule M\n  class C\n    X = 'a constant'\n    p X # => \"a constant\"\n    p ::X  # => \"a root-level constant\"\n    p Module.nesting\n  end\n  C::X # => \"a constant\"\nend\nM::C::X # => \"a constant\"\n```\n\n- 모듈 클래스도 인스턴스 메서드 클래스 메서드를 제공하고 이 둘을 constants라고 부른다.\n- `Modules#constants` 는 현재 스코프의 모든 상수를 반환한다.\n- `Module.constants`는 최상위 상수들을 반환한다.\n\n```ruby\nM.constants                        # => [:C]\nModule.constants.include? :Object  # => true\nModule.constants.include? :Module  # => true\n```\n\n- `Module.nesting` 으로는 current path를 얻을 수 있다.\n\n루비의 상수와 파일 간의 유사성은 더 나아가 파일을 정리할 때 디렉토리를 사용하는 것과 마찬가지로 모듈을 사용하여 상수를 구성할 수 있다.\n\n#### The Rake Example\n\n- 루비의 빌드 시스템 `Rake` 의 초기 버전은 `Task`, `FileTask` 와 같이 명확한 이름의 클래스를 정의했다.\n- 다른 라이브러리들과 충돌 할 가능성이 높았다.\n- `Rake`내의 모듈에서 다음처럼 클래스를 정의하는 것으로 전환하였다.\n\n[lib/rake/task.rb](https://github.com/ruby/rake/blob/master/lib/rake/task.rb)\n\n```ruby\n#...\nmodule Rake\n  #...\n   class Task\n     #..\n\n```\n\n- 이제 Task의 이름은 `Rake::Task` 이고 이제 다른 라이브러리와 충돌하지 않을 것이다.\n- `Rake` 같은 모듈 중 상수의 구성 요소로만 존재하는 모듈을 **네임스페이스**라고 한다.\n- 이전 버전에 대한 대응\n\n```ruby\nTask = Rake::Task\nFileTask = Rake::FileTask\nFileCreationTask = Rake::FileCreationTask\n```\n\n- 위 처럼 대응하고 사용자가 모두 마이그레이션 했다고 생각 되었을 때 옵션을 나중에 제거\n\n### Objects and Classes Wrap-Up\n\n- 객체란 무엇인가? - 인스턴스 변수와 클래스에 대한 링크이다.\n- 클래스란 무엇인가? - 객체와 인스턴스 메소드 목록 및 슈퍼클래스에 대한 링크이다.\n  - 클래스는 모듈의 하위클래스이므로 클래스도 모듈이다.\n  - 다른 객체들과 마찬가지로 클래스에는 메서드가 있고, 클래스(클래스 이름!)에 대한 상수 참조가 이미 있다.\n\n### Using Namespaces\n\n```ruby\nclass Text\n  #...\n  # Type Error: Text is not a class\n```\n\n- `Action Mailer` 에서 `Text` 라는 모듈 이름을 쓰고있다.\n- 따라서 다음처럼 변경하여 사용\n\n```ruby\nmodule Hello\n  class Text\n```\n\n## What Happens When You Call a Method?\n\n### Method Lookup\n\n- 수신자 ( receiver ) 와 조상 ( ancestors )의 chain\n- 수신자는 메서드를 호출하는 객체이다.\n  - `my_string.reverse()` 라면 `my_string` 이 수신자\n- ancestors chain은 superclass로 타고 올라가는 경로\n\n```ruby\nclass MyClass\n  def my_method; 'my_method()'; end\nend\nclass MySubclass < MyClass\nend\nobj = MySubclass.new\nobj.my_method()       # => \"my_method()\"\n```\n\n- `my_method()`를 호출하면 수신자인 `obj` 에서 `MySubclass` 로 바로 들어간다.\n- `my_method()`를 찾을 수 없으므로 `MyClass` 로 올라가서 찾고 그곳에서 `my_method()` ㄹㅡㄹ 찾을 수 있다.\n- `MyClass` 는 superclass를 지정하지 않으므로 기본 superclass에서 암시적으로 상속된다.\n- 만약 `MyClass` 에서도 못찾았으면 `Object` , `BasicObject` 로 체인을 올려서 메서드를 찾을 것 이다.\n\n```ruby\nMySubclass.ancestors # => [MySubclass, MyClass, Object, Kernel, BasicObject]\n```\n\n- `Kernel` 은 모듈이겠지 뭐\n\n### Modules and Lookup\n\n- `include` 를 통해서 클래스를 모듈에 포함시킬 수 있다.\n\n```ruby\nmodule M1\n  def my_method\n    'M1#my_method()'\nend end\nclass C\n  include M1\nend\nclass D < C; end\nD.ancestors # => [D, C, M1, Object, Kernel, BasicObject]\n```\n\n- `prepend` 를 통해서 아래에 모듈을 포함 시킬수도 있다.\n\n```ruby\nclass C2\n  prepend M2\nend\nclass D2 < C2; end\nD2.ancestors # => [D2, M2, C2, Object, Kernel, BasicObject]\n```\n\n- 만약 모듈을 여러 번 동일한 조상 체인에 포함하려고 하면?\n\n```ruby\nmodule M1; end\nmodule M2\n  include M1\nend\nmodule M3\n  prepend M1\n  include M2\nend\nM3.ancestors # => [M1, M3, M2]\n```\n\n- `M3` 에서 prepend를 먼저 하고 이후에 M2를 추가하지만 이미 M1이 조상들의 사슬에 있기 때문에 포함되지 않는다.\n\n### The Kernel\n\n- 루비에는 print 같은 메서드가 있어 어느 곳에서나 호출이 가능하다.\n\n```ruby\nKernel.private_instance_methods.grep(/^pr/) # => [:printf, :print, :proc]\n```\n\n- `Object` 클래스가 `Kernel`을 포함하므로 커널은 모든 오브젝트의 상위 체인에 들어간다.\n- 따라서 Ruby의 모든 줄은 항상 `Object` 안에서 실행되므로 `Kernel` 의 인스턴스 메서드를 호출할 수 있다.\n- 므찌다, 이런 커널 메서드가 실제로 유용하다는 것을 증명하기 위해 일부 라이브러리 살펴보자\n\n#### The Awesome Print Example\n\n```ruby\nrequire \"awesome_print\"\n  local_time = {:city => \"Rome\", :now => Time.now }\n  ap local_time, :indent => 2\n```\n\n- 어디서든 `ap` 를 부를 수 있다.\n\n[lib/awesome_print/core_ext/kernel.rb](https://github.com/awesome-print/awesome_print/blob/master/lib/awesome_print/core_ext/kernel.rb)\n\n```ruby\nmodule Kernel\n #...\n def ap(object, options={})\n #...\n end\nend\n```\n\n### Method Execution\n\n- 메서드를 호출하면 루비든 두 가지 일을 한다.\n  1. 메서드 찾기\n  2. 실행하기\n- my_method를 실행했다고 해보자\n\n```ruby\ndef my_method\n  temp = @x + 1\n  my_other_method(temp)\nend\n```\n\n- 인스턴스 변수 @x가 속한 객체는 뭘까?\n- 어떤 객체의 my_other_method 를 불러야 할까?\n- 직관적으로 모두 수신자에 속한다는걸 알 수 있다.\n- 하지만 루비는 직관이 없으므로 수신자에 대한 참조를 넣어둔다.\n\n#### The Self Keyword\n\n- 루비 코드의 모든 줄은 오브젝트 안에서 실행된다. ( current object 라고 함)\n- current object는 또한 `self` 로 불리기도 한다. 우리가 `self` 로 접근이 가능함\n\n```ruby\nclass MyClass\n  def testing_self\n    @var = 10 # An instance variable of self\n    my_method() # Same as self.my_method()\n    self\nend\n  def my_method\n    @var = @var + 1\n  end\nend\nobj = MyClass.new\nobj.testing_self  # => #<MyClass:0x007f93ab08a728 @var=11>\n```\n\n- `testing_self` 를 호출하는 순간 obj는 self가 된다.\n- @var는 obj의 인스턴스 변수이며 my_method는 obj에서 호출 된다.\n- 마지막으로 self에 대한 참조를 반환한다.\n- 따라서 루비를 잘 쓰려면 주어진 순간에 어떤 객체가 self인지를 항상 알아야 한다.\n- 어떤 객체가 마지막 메서드 수신자인지 추적 하기만 하면 된다.\n- 하지만 두가지 특별한 경우가 있음!\n\n#### The Top Level\n\nirb를 열고 다음처럼 쳐보면?\n\n```ruby\nself        # => main\nself.class  # => Object\n```\n\n- 루비 프로그램을 시작하자 마자 루비의 인터프리터는 `Main`이라는 이름의 오브젝트 안에 우리를 위치시킨다.\n- 이 오브젝트를 최상위 컨텍스트라고 부른다.\n  - 콜 스텍의 최상위 레벨에 있는 오브젝트이므로\n  - 아직 메서드를 호출하지 않았거나 모든 메서드가 반환되었다.\n\n#### Class Definitions and self\n\n```ruby\nclass MyClass\n  self        # => MyClass\nend\n```\n\n요약하자면\n\n- 메서드를 호출하면 루비가 규칙에 따라 메소드를 조회한 뒤 수신자를 self로 두고 메서드를 실행한다.\n- 몇 가지 특별한\n- 경우( 모듈 포함 ) 가 있지만 예외는 없다. (하나를 제외하고)\n\n### Refinenments\n\n- 이번 장 초반의 부분을 기억하는가?\n\n```ruby\nclass String\n  def to_alphanumeric\n    gsub(/[^\\w\\s]/, '')\n  end\nend\n```\n\n- 이 변경사항은 전역적이라는 문제가 있다.\n- 모든 String 이 영향을 받고, 호환이 되지 않는 Monkeypatch라면 - `Array#replace` 과 같은\n- `Refindement` 를 통해 해결이 가능하다.\n\n```ruby\nmodule StringExtensions\n    refine String do\n      def to_alphanumeric\n        gsub(/[^\\w\\s]/, '')\n      end\n    end\nend\n```\n\n- `\"my *1st* refinement!\".to_alphanumeric`\n  - => `NoMethodError: undefined method 'to_alphanumeric' [...]`\n- using method를 사용해서 변경을 적용한다.\n- `using StringExtensions`\n\n```ruby\nmodule StringExtensions\n  refine String do\n    def reverse\n      \"esrever\"\n    end\n  end\nend\nmodule StringStuff\n  using StringExtensions\n  \"my_string\".reverse\nend\n\"my_string\".reverse\n# => \"esrever\"\n# => \"gnirts_ym\"\n```\n\n- Refinement는 Monkeypatches 같지만 전역적이진 않다.\n- 그러면서 일반적으로 오픈 클래스가 할 수 있는 모든 작업이 가능하다.\n\n#### Refinement Gotchas\n\n```ruby\nclass MyClass\n  def my_method\n    \"original my_method()\"\n  end\n  def another_method\n    my_method\n  end\nend\nmodule MyClassRefinement\n  refine MyClass do\n    def my_method\n      \"refined my_method()\"\n    end\n  end\nend\nusing MyClassRefinement\nMyClass.new.my_method # =>  \"refined my_method()\"\nMyClass.new.another_method  # =>  \"original my_method()\"\n\n```\n\n- `MyClass.new.my_method` 의 호출은 using 이후지만\n- `MyClass` 의 인스턴스 메서드 `my_method` 의 호출은 using 이전이므로 ...\n- 직관에 조금 어긋나는 것 같다..\n- 일반 모듈에서 refine을 사용할 수 있지만 클래스 자체가 모듈인 경우에 클래스에서 이를 호출할 수 없다.\n- 또한 메서드나 조상을 아예 무시해버린다.\n- 이런 동작은 타당한 기술적 정당성을 갖고 있지만 꽤나 어렵다..\n- refine은 몽키 패치를 제거할 수 있지만 잘 사용하는 방법을 이해하는 것은 시간이 걸린다.\n\n## Wrap Up!\n\n- 객체는 인스턴스 변수와 클래스에 대한 링크로 구성된다.\n- 객체의 메서드는 객체의 클래스에 존재한다.\n- 클래스는 Class클래스의 오브젝트일 뿐이다.\n  - 클래스의 이름은 그냥 상수임\n  - 클래스는 모듈을 상속받는다.\n- 상수는 파일 시스템과 유사하게 트리에 배열되어 있다.\n  - 모듈과 클래스의 이름은 디렉터리, 상수는 파일\n- 클래스에는 클래스에서 시작하여 BasicObject로 올라가는 조상 체인이 있음\n"},{"excerpt":"회사에서 조만간 루비를 안 쓰게 될 것 같다. 루비를 보내주는 마지막 공부..... 아니면 언젠가 이직하면 레일즈를 쓰는 회사로 이직을 하게될까? Metaprogramming Ruby 아무튼 Metaprogramming Ruby라는 책을 읽어 보려한다. 올리는 글은 챕터별 정리와 사견 되도록 우리나라에 출판된 번역본 책은 안 올리려고 하는데 이 책은 번역…","fields":{"slug":"/metaprogramming-ruby-1/"},"frontmatter":{"date":"April 01, 2021","title":"M Ruby - 1","tags":["ruby"]},"rawMarkdownBody":"\n회사에서 조만간 루비를 안 쓰게 될 것 같다.\n\n~~루비를 보내주는 마지막 공부.....~~\n\n아니면 언젠가 이직하면 레일즈를 쓰는 회사로 이직을 하게될까?\n\n## Metaprogramming Ruby\n\n아무튼 Metaprogramming Ruby라는 책을 읽어 보려한다. 올리는 글은 챕터별 정리와 사견\n\n되도록 우리나라에 출판된 번역본 책은 안 올리려고 하는데\n\n이 책은 번역본도 없고 깃헙에 pdf로 올라와 있어서 한번 해본다.\n\n## The M Word\n\n```\n메타 프로그래밍은 코드를 쓰는 코드이다.\n```\n\n일단은 이 정도가 제일 간단한 정의이다. 자세한 얘기 이전에 먼저 프로그래밍 언어 자체에 대해 살펴본다.\n\n## 유령 마을 vs 시끌시끌한 시장\n\n- 소스 코드를 변수, 클래스, 메서드 등의 활기찬 시민들로 가득 찬 세상으로 생각해 보자\n- 많은 프로그래밍 언어에서 이 시민들은 유령 같다\n  - C++를 예로 들면 컴파일러가 작업을 마치면 변수나 메서드 같은 것들은 형태를 잃는다.....!\n  - 런타임에서 다 사라지고 유령 같지\n- 루비와 같은 언어에서 런타임은 시끌시끌한 시장 같다.\n  - 대부분의 언어 구조들이 여전히 생생하게 살아있고\n  - 심지어 언어 구조까지 걸어갈 수 있고 그것에 관한 질문을 할 수도 있다.\n    - 이를 `Introspection`이라고 한다.\n\n```ruby\n# the_m_word/introspection.rb\nclass Greeting\n  def initialize(text)\n    @text = text\n  end\n  def welcome\n    @text\n  end\nend\n```\n\n```ruby\nmy_object = Greeting.new(\"Hello\")\n```\n\n- `Greeting` 클래스를 정의하고 객체를 만들었다.\n\n```ruby\nmy_object.class                             # => Greeting\n```\n\n- `my_object` 에게 클래스가 뭐냐고 물어보면 확실하게 `Greeting 이다~~~` 라고 답해줌\n- 그럼 이제 그 클래스로부터 인스턴스 메서드의 리스트를 물어볼 수 있다.\n\n```ruby\nmy_object.class.instance_methods(false)     # => [:welcome]\n```\n\n- 클래스는 메서드 이름을 포함하는 배열로 답을 해준다. `[:welcome]`\n- false 인수는 상속받은 메서드는 나열하지 않는다는 뜻\n- 그럼 객체를 보면서 인스턴스 변수에 대해 물어보자\n\n```ruby\nmy_object.instance_variables                # => [:@text]\n```\n\n- 잘~ 답해준다.\n- 루비에서 객체와 클래스는 일급 시민( FIrst-class citizens )이기 때문에 우리는 많은 정보들을 얻을 수 있다.\n\n### -\n\n우리는 루비에서 런타임에 언어의 구조를 읽을 수 있다 !\n\n하지만 작성하는 것은??? 프로그램이 실행되는 동안 Greeting에 새 인스턴스 메서드를 추가하려면???\n\n## 메타프로그래머 이야기\n\n- 데이터베이스에 객체를 저장하기 위한 간단한 라이브러리를 구축해보자\n\n### 첫 번째 시도\n\n- 각 클래스를 데이터베이스 테이블에 매핑하고 각 객체를 레코드에 매핑한다.\n- 객체를 생성하거나 그 속성에 액세스 할 때 객체는 SQL 문자열을 생성하여 데이터베이스로 보낸다.\n\n```ruby\n#the_m_word/orm.rb\nclass Entity\n  attr_reader :table, :ident\n  def initialize(table, ident)\n    @table = table\n    @ident = ident\n    Database.sql \"INSERT INTO #{@table} (id) VALUES (#{@ident})\"\n  end\n  def set(col, val)\n    Database.sql \"UPDATE #{@table} SET #{col}='#{val}' WHERE id=#{@ident}\"\n  end\n  def get(col)\n    Database.sql (\"SELECT #{col} FROM #{@table} WHERE id=#{@ident}\")[0][0]\n  end\nend\n```\n\n- SQL을 알고있다면 읽을 만 할 듯\n- `Entity`에서 id값, 테이블 이름을 갖고있고 `Entity`를 생성하고 나면 데이터베이스에 저장된다\n- `Entity#set`은 컬럼의 값을 업데이트, `Entity#get`은 컬럼의 값을 갖고 온다\n\n```ruby\nclass Movie < Entity\n  def initialize(ident)\n    super \"movies\", ident\n  end\n  def title\n    get \"title\"\n  end\n  def title=(value)\n    set \"title\", value\n  end\n  def director\n    get \"director\"\n  end\n  def director=(value)\n    set \"director\", value\n  end\nend\n\n```\n\n- `Entity`클래스로 `Movie`를 정의해봤다.\n\n- `Movie` 클래스는 `title`, `director` 에 대한 reader , writer를 갖고있다.\n\n- 다음과 같은 코드로 새 영화를 데이터베이스에 넣을 수 있다!\n\n  ```ruby\n  movie = Movie.new(1)\n  movie.title = \"Doctor Strangelove\"\n  movie.director = \"Stanley Kubrick\"\n  ```\n\n- 이제 데이터베이스에 id가 1인 영화가 생겼다!\n\n- ( `director = \"~~~\"` 이 꼴은 `director=(\"~~~\")` 이거랑 동일 )\n\n**하지만 중복이 많다.**\n\n데이터베이스의 컬럼에도 `title`을 갖고있고, `Movie`클래스에도 `@title` 필드를 갖고있다.\n\n그리고 `title` 메서드를 갖고있고 두개의 `\"title\"` 문자열 상수도 있다.\n\n## 메타프로그래밍 시작\n\n- 메타프로그래밍 기반의 솔루션을 찾아보자\n\n- 객체를 데이터베이스 테이블에 매핑하는 ActiveRecord 라이브러리를 사용해본다.\n\n```ruby\nclass Movie < ActiveRecord::Base\nend\n```\n\n```ruby\nmovie = Movie.create\nmovie.title = \"Doctor Strangelove\"\nmovie.title  # => \"Doctor Strangelove\"\n```\n\n- 이전 코드는 Movie에서 레코드를 매핑하는 객체를 만든 뒤 Movie의 title을 호출하여 접근했다.\n- 테이블에 대한 이름도 필요했다.\n- 하지만 이번 코드에선 이런 과정이 소스코드에 전혀 없다.\n- 정의하지 않은 `title`, `title=` 이 어떻게 존재하는 것일까?\n\n### ActiveRecord의 기본 작동 방식\n\n- 테이블 이름은 간단하게 클래스의 `introspection` 을 통해서 규칙을 정한다.\n  - 클래스의 이름이 `Movie`이므로 `ActiveRecord`는 이를 `Movie`라는 테이블에 매핑한다\n- 그렇다면 객체의 속성에 접근하는 `title=` , `title` 같은 메서드는?? - **여기서 메타 프로그래밍!**\n  - 데이터베이스 스키마에서 이름을 유추하고 자동으로 정의한다.\n  - 런타임에 스키마를 읽고 `Movie`테이블에 `title`, `director`라는 두 개의 컬럼을 발견\n  - 동일한 이름의 두 속성에 대한 접근자 메소드를 정의한다.\n\n#### 이게 바로 introspection의 음 양!! 단순히 언어의 구조를 읽는 것이 아니라 쓰기까지 하는 것\n\n- 메타 프로그래밍은 런타임에 언어 구조를 조작하는 코드를 작성하는 것이다\n- ActiveRecord는 이 컨셉을 적용했다.\n- 각 클래스의 특성에 대한 접근자 메소드를 작성하는 대신\n- 상속받는 클래스에 대해 런타임에 이런 메소드를 정의하는 코드를 작성했다.\n\n## 메타프로그래밍과 루비\n\n맨 처음 유령 마을과 시끌시끌한 시장에 대해 얘기했던 게 기억나는가?\n\n언어의 구문을 조작하려면 해당 구문이 런타임에 있어야한다.\n\n몇 가지 언어들은 런타임에서 제어기능을 제공하는데 이에대해 간략히 살펴보자.\n\n> Code Generators and Compilers\n>\n> 메타프로그래밍에서는 코드를 작성하는 코드를 작성한다. 하지만 그게 code generator와 컴파일러가 해주는 것 아닌가?\n>\n> 예를들어 Java code를 작성하고 코드 제너레이터로 XML 설정 파일을 만들 수 있다.\n> 넓은 의미에서 이 XML 생성은 메타프로그래밍의 한 예이다.\n>\n> 메타프로그래밍의 또 다른 의미로, 프로그램을 사용하여 두 번째 고유 프로그램을 생성하거나 조작한 다음 두 번째 프로그램을 실행한다는 것도 있다!\n> ( C++의 템플릿 )\n>\n> 하지만 이 책에서는 메타프로그래밍의 다른 의미, 런타임에 스스로 조작하는 코드에 초점을 맞춘다.\n> Code Generator 및 Compiler의 정적 메타 프로그래밍과 구별되는 동적 메타 프로그래밍이라고 생각하면 된다.\n>\n> 또한 많은 언어에서 동적 메타프로그래밍을 할 수 있지만 루비에서는 더 우아하고 원활하게 할 수 있다!\n\n- C로 작성된 프로그램은 런타임에 대부분의 정보가 손실되기 때문에 메타프로그래밍이나 Introspection을 지원하지 않는다.\n- C++에서 몇몇 언어들의 구문들은 컴파일에서 살아남기 때문에 객체와 클래스에서 사용이 가능\n- Java에서 컴파일과 런타임은 더 모호하다. 클래스 메서드를 나열하거나 슈퍼클래스까지 올라갈 수 있는 충분한 Introspection을 제공!\n\n**루비는 매우 메타프로그래밍 친화적인 언어다. 컴파일 타임이 없으며 대부분의 언어 문법을 런타임에 사용 가능하다.**\n\n**작성하는 코드와 런타임의 경계가 없다.**\n\n**루비의 메타프로그래밍은 그저 전문가를 위한 모호한 예술이 아니고, ActiveRecord처럼 정교한 것을 만드는 데만 유용한 기능도 아니다**\n\n**만약 고급 루비 코딩의 길을 가고싶다면 .... !**\n\n## 사견\n\n- 아직까진 쉬운 내용\n\n- 다른 orm들도 메타프로그래밍을 쓰는 것으로 알고 있다.\n"},{"excerpt":"레일즈 - postgres를 사용할떄 자주 본 에러이다. 맥북 사용 시 다른 맥북 유저에 비해 맥북을 잘 꺼두는 편이였는데, 끌 때 정상적으로 종료시키지 않아서 발생하는 문제 같았다. 프로세스를 제대로 종료하지 않고 노트북이 꺼지는 바람에 pid 파일을 제대로 지우지 못한 탓이다. 이미 pid파일이 있다면 postgres은 제대로 실행되지 못한다. 해결 …","fields":{"slug":"/4-pgconnectbad/"},"frontmatter":{"date":"March 24, 2021","title":"PG:ConnectionBad - could not connect to server: Connection refused","tags":["Rails","Postgresql","mac","linux","짧","팁"]},"rawMarkdownBody":"\n레일즈 - postgres를 사용할떄 자주 본 에러이다.\n\n```shell\nPG::ConnectionBad - could not connect to server: Connection refused\n```\n\n```shell\n...\nStarted GET \"/\" for 127.0.0.1 at 2020-01-06 03:12:32 +0900\n\nPG::ConnectionBad - could not connect to server: Connection refused\nIs the server running on host \"localhost\" (::1) and accepting\n...\n```\n\n맥북 사용 시 다른 맥북 유저에 비해 맥북을 잘 꺼두는 편이였는데, 끌 때 정상적으로 종료시키지 않아서 발생하는 문제 같았다.\n\n프로세스를 제대로 종료하지 않고 노트북이 꺼지는 바람에 pid 파일을 제대로 지우지 못한 탓이다.\n\n이미 pid파일이 있다면 postgres은 제대로 실행되지 못한다.\n\n### 해결 방법\n\n1.  `/usr/local/var/postgres` 혹은 `/usr/var/postgres` 에서 `postmaster.pid` 가 존재하는지 확인\n    있다면 지운다\n    <br/>\n    `rm postmaster.pid`\n\n2.  postgresql을 재 실행 한다.\n    mac : `brew services restart postgresql`\n    linux : `sudo service postgresql restart`\n"},{"excerpt":"요즘 회사가 바빠 일하느라.. 운동하느라... 따라서 quiver에 몇년 간 작성해놨던 팁 노트중 짧은걸 하나 옮겨야겠다.. 나는 따로 남는 노트북을 서버로 사용하고있다. 동영상 스트리밍 서버가 필요했고, 노트북의 용량은 그리 넉넉하지 못하며, 우분투에서 바로 동영상을 받기보단 윈도우에서 옮기는 경우가 더 많기에 외장하드를 노트북에 연결해서 스트리밍서버의…","fields":{"slug":"/3-mount/"},"frontmatter":{"date":"March 23, 2021","title":"Ubuntu 에서 (외장) 하드디스크 사용하기 ","tags":["ubuntu","linux","짧","팁"]},"rawMarkdownBody":"\n#### 요즘 회사가 바빠 일하느라.. 운동하느라...\n\n#### 따라서 quiver에 몇년 간 작성해놨던 팁 노트중 짧은걸 하나 옮겨야겠다..\n\n<br/>\n\n나는 따로 남는 노트북을 서버로 사용하고있다.\n\n동영상 스트리밍 서버가 필요했고, 노트북의 용량은 그리 넉넉하지 못하며, 우분투에서 바로 동영상을 받기보단 윈도우에서 옮기는 경우가 더 많기에\n\n외장하드를 노트북에 연결해서 스트리밍서버의 저장소로 사용하기로 했다.\n\n스트리밍서버는 따로 plex라는 서비스를 사용했는데 이건 나중에 시간이 나면 글을 작성하고 ...\n\n어쩃든 외장하드를 그냥 꽂는 것 만으로는 서버에서 바로 사용할 수 있는건 아니라서 디스크를 마운트 해줬어야 했다.\n\n```shell\nsudo fdisk -l\n```\n\n으로 먼저 외장하드가 마운트된 주소를 확인해본다.\n![image-20210324021023597](./1.png)\n\n아래 표시된 부분의 위치를 기억하고 ,\n\n```shell\nsudo mount -t ntfs-3g /dev/sdc1 ~/hdd\n```\n\n하면 끝!\n\n`-t ntfs-3g` 은 `--types` 인데 파일시스템 타입 관련한 옵션같다. 보통 mount 커멘드는 filesystem을 감지가 가능하다고 하니 .. 필요없는거같긴하다.\n\next2, ext3, ext4, xfs등 여러 옵션이 있다.\n\n또한, 파일시스템에 접근하는 것은 루트퍼미션이 필요하다\n\n자세한건 `man mount` ㄲ\n\n마운트 된걸 언마운트 하는건 더 쉽다.\n\n```shell\nsudo umount hdd\n```\n"}]}},"pageContext":{}},"staticQueryHashes":[]}