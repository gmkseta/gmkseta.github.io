{"componentChunkName":"component---src-templates-post-jsx","path":"/metaprogramming-ruby-10/","result":{"data":{"site":{"siteMetadata":{"title":"Seongjun Kim Blog"}},"markdownRemark":{"id":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","excerpt":"이전 장에서 모듈을 포함하면 인스턴스와 클래스 메서드 모두를 얻는 것을 알게되었다. Active Support 라이브러리에 있는 Concern 덕분에 가능 한 것 이전에 어떻게 되어있었고 어떤식으로 진화하는지 알아보자 Concern 이전의 레일즈 레일즈는 수년동안 많이 변경되었지만 기본 아이디어는 크게 변경되지 않았다 그 중 하나가 ActiveRecord…","html":"<ul>\n<li>이전 장에서 모듈을 포함하면 인스턴스와 클래스 메서드 모두를 얻는 것을 알게되었다.</li>\n<li>Active Support 라이브러리에 있는 Concern 덕분에 가능 한 것</li>\n<li>이전에 어떻게 되어있었고 어떤식으로 진화하는지 알아보자</li>\n</ul>\n<h2>Concern 이전의 레일즈</h2>\n<ul>\n<li>레일즈는 수년동안 많이 변경되었지만 기본 아이디어는 크게 변경되지 않았다</li>\n<li>그 중 하나가 ActiveRecord::Base 개념이다.</li>\n<li>이 클래스는 인스턴스 메서드와 클래스 메서드를 모두 정의하는 수십 개의 모듈로 이뤄져있다.</li>\n<li>이러한 메서드를 Base에 넣는 메커니즘이 변경되었다.</li>\n</ul>\n<h3>Include, Extend 사용</h3>\n<ul>\n<li>Rails2에서의 유효성 검사는 <code class=\"language-text\">ActiveRecord::Validations</code> 에 정의되어있다 ( 그때는 Active Model 없었음 )</li>\n<li>Validation은 독특한 트릭 사용</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveRecord</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Validations</span>\n<span class=\"token comment\"># ...</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n      base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n      <span class=\"token comment\"># ...</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">module</span> <span class=\"token constant\">ClassMethods</span>\n      <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">validates_length_of</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>attrs<span class=\"token punctuation\">)</span> <span class=\"token comment\"># ...</span>\n      <span class=\"token comment\"># ...</span>\n      <span class=\"token keyword\">end</span>\n      <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">valid</span></span><span class=\"token operator\">?</span>\n      <span class=\"token comment\"># ...</span>\n      <span class=\"token keyword\">end</span>\n      <span class=\"token comment\"># ...</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>낯익지 않나? VCR 예제에서 본 것 ( HTTP call )</li>\n<li>valid? 같은 Validation의 인스턴스 메서드는 Base의 인스턴스 메서드가 된다.</li>\n<li>Ruby는 hook method를 호출해서 base를 인수로 전달한다.</li>\n<li>Validations::ClassMethod를 이용하여 base를 extend 한다.</li>\n</ul>\n<p>결과적으로 Base는 인스턴스 메서드와 클래스 메서드 모두 다 갖고올 수 있다.</p>\n<ul>\n<li>include-and-extend 트릭이라고 부르도록 하겠다..</li>\n<li>수 많은 ruby, rails 프로젝트에서 이렇게 사용했다....</li>\n<li>\n<p>편리하지만 몇 개의 문제가 있다.</p>\n<ul>\n<li>클래스 메서드를 정의하는 각각의 모든 모듈은 해당 includer를 확장하는 훅도 정의해야한다.</li>\n<li>해당 훅이 수십 개의 모듈에 걸쳐 복제된다. 결과적으로 사람들이 이럴 가치가 있나? ..흠 한 줄 더 추가해서 해결이 가능..</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">include</span> <span class=\"token constant\">Validations</span>\n<span class=\"token keyword\">extend</span> <span class=\"token constant\">Validations</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">ClassMethods</span></code></pre></div>\n<ul>\n<li>하지만 더 깊은 문제가 있다!</li>\n</ul>\n</li>\n</ul>\n<h3>The Problem of Chained Inclusions</h3>\n<ul>\n<li>다른 모듈을 포함하는 모듈을 포함한다고 가정해보자.</li>\n<li>ActiveRecord::Validations는 ActiveModel::Validations 을 include한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">SecondLevelModule</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n    base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">second_level_instance_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'ok'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">ClassMethods</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">second_level_class_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'ok'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">FirstLevelModule</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n    base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">first_level_instance_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'ok'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">ClassMethods</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">first_level_class_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'ok'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">SecondLevelModule</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">BaseClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">FirstLevelModule</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>두 모듈 모두 BaseClass의 조상에 있으니 두 모듈의 인스턴스 메서드를 모두 호출 가능하다.</li>\n<li>include와 extend 덕분에 클래스 메서드도 사용 가능하다.</li>\n<li>\n<p>하지만...</p>\n<p><code class=\"language-text\">BaseClass.second_level_class_method # =&gt; NoMethodError</code></p>\n</li>\n<li>SecondLevelModule.included를 호출할 때 기본 매개변수는 BaseClass가 아니라 FirstLevelModule</li>\n<li>결과적으로 SecondLevelModule::ClassMethods의 메서드는 FirstLevelModule의 클래스 메서드..</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">FirstLevelModule</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">included</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n    base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> <span class=\"token constant\">ClassMethods</span>\n    base<span class=\"token punctuation\">.</span>send <span class=\"token symbol\">:include</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">SecondLevelModule</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>이러한 구현은 덜 유연하다..</li>\n<li>다른 모듈과 첫 번째 레벨의 모듈을 구별해야하고, 각 모듈은 그것이 첫 번째 레벨인지 알아야한다..</li>\n<li>그리고 이 시대에는 Module#include가 프라이빗 메서드라 호출 못했음 ( Dynamic Dispatch 를 사용해야함) , 최근엔 Public</li>\n</ul>\n<h2>ActiveSupport::Concern</h2>\n<ul>\n<li><code class=\"language-text\">ActiveSupport::Concern</code>은 included-and-extend 트릭을 을 캡슐화하고 연결된 include문제를 수정한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">'active_support'</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">MyConcern</span>\n  <span class=\"token keyword\">extend</span> <span class=\"token constant\">ActiveSupport</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Concern</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">an_instance_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">\"an instance method\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">ClassMethods</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">a_class_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">\"a class method\"</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">MyConcern</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>an_instance_method  <span class=\"token comment\"># => \"an instance method\"</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span>a_class_method          <span class=\"token comment\"># => \"a class method\"</span></code></pre></div>\n<ul>\n<li>어떻게 이게 되는걸까?</li>\n</ul>\n<h3>Concern 코드 보기</h3>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveSupport</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Concern</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">MultipleIncludedBlocks</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">StandardError</span> <span class=\"token comment\">#:nodoc:</span>\n      <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">initialize</span></span>\n        <span class=\"token keyword\">super</span> <span class=\"token string\">\"Cannot define multiple 'included' blocks for a Concern\"</span>\n      <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">extended</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n      base<span class=\"token punctuation\">.</span>instance_variable_set<span class=\"token punctuation\">(</span><span class=\"token punctuation\">:</span><span class=\"token variable\">@_dependencies</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">end</span>\n    <span class=\"token comment\">#...</span></code></pre></div>\n<ul>\n<li>Concern의 코드는 짧지만 복잡하다.</li>\n<li>excended및 append_features 메서드만 정의한다.</li>\n</ul>\n<h4>Module#append_features</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">M</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token function\">append_features</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">M</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">C</span><span class=\"token punctuation\">.</span>ancestors\n<span class=\"token comment\"># => [C, Object, Kernel, BasicObject]</span></code></pre></div>\n<ul>\n<li>included는 일반적으로 비어있는 Hook 메서드였고 재정의 하려는 경우에만 존재했다.</li>\n<li>append_features는 실제 include가 일어나는 곳에 있다.</li>\n<li>append_features는 포함된 모듈이 이미 포함하는 모듈의 조상체인에 있는지 확인하고 그렇지 않으면 체인에 추가한다.</li>\n<li>일반적으로는 included를 재정의하지만 append_features를 재정의..해버리면 모듈이 전혀 포함 안 되게 할 수 있다.</li>\n</ul>\n<h4>Concern#append_features</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveSupport</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Concern</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">append_features</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span></code></pre></div>\n<ul>\n<li>Extension이 기억 나나?</li>\n<li>append_features는 Concern의 인스턴스 메서드이므로 Concern을 확장하는 모듈의 클래스 메서드가 된다.</li>\n<li>\n<p>즉 Validations라는 모듈이 Concern을 확장하면 Validations.append_features 클래스 메서드를 얻지</p>\n<ul>\n<li>싱글톤 클래스들이 갖던거 기억하나?</li>\n<li>아뇨.. ㅜㅜ</li>\n</ul>\n</li>\n<li>Concern을 확장하는 모듈은 @_dependencies 클래스 변수를 얻는다.</li>\n<li>append_features의 재정의를 얻는다.</li>\n</ul>\n<h4>Inside Concern#append_features</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveSupport</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Concern</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">append_features</span></span><span class=\"token punctuation\">(</span>base<span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> base<span class=\"token punctuation\">.</span>instance_variable_defined<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">:</span><span class=\"token variable\">@_dependencies</span><span class=\"token punctuation\">)</span>\n        base<span class=\"token punctuation\">.</span>instance_variable_get<span class=\"token punctuation\">(</span><span class=\"token punctuation\">:</span><span class=\"token variable\">@_dependencies</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span><span class=\"token operator\">&lt;</span> <span class=\"token keyword\">self</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span>\n      <span class=\"token keyword\">else</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span> <span class=\"token keyword\">if</span> base <span class=\"token operator\">&lt;</span> <span class=\"token keyword\">self</span>\n        <span class=\"token variable\">@_dependencies</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">each</span> <span class=\"token punctuation\">{</span> <span class=\"token operator\">|</span>dep<span class=\"token operator\">|</span> base<span class=\"token punctuation\">.</span>send<span class=\"token punctuation\">(</span><span class=\"token symbol\">:include</span><span class=\"token punctuation\">,</span> dep<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">}</span>\n        <span class=\"token keyword\">super</span>\n        base<span class=\"token punctuation\">.</span><span class=\"token keyword\">extend</span> const_get<span class=\"token punctuation\">(</span><span class=\"token symbol\">:ClassMethods</span><span class=\"token punctuation\">)</span> \\\n          <span class=\"token keyword\">if</span> const_defined<span class=\"token operator\">?</span><span class=\"token punctuation\">(</span><span class=\"token symbol\">:ClassMethods</span><span class=\"token punctuation\">)</span>\n        <span class=\"token comment\"># ...</span>\n<span class=\"token keyword\">end</span> <span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>어렵지만 기본 아이디어는 간단하다.</li>\n<li>다른 concern에 concern을 include하지마!</li>\n<li>대신 concern이 서로를 include 하려할 때 종속성 그래프에 연결하기만 하면 된다.</li>\n<li>스스로 include하는 것이 아닌, 모든 종속성을 한번에 includer로 돌아서 include한다.</li>\n<li>self는 concern이다, 클래스 메서드로 실행이 되고, base는 관심사거나 이를 포함하는 모듈이다.</li>\n<li>\n<p>맨 처음 concern을 include하려고하면?</p>\n<ul>\n<li>@_dependencies 클래스 변수가 있는 것이 문제</li>\n<li>이를 조상 체인에 자신을 추가하는 대신 dependencies에 자신을 추가하고 include가 실제로 안 되었음을 알리기 위해 false</li>\n<li>예를들어 ActiveModel::Validations 이고, ActiveRecord::Validations에 포함되는 경우임!</li>\n</ul>\n</li>\n<li>\n<p>만약 Concern이 아닌 경우 -</p>\n<ul>\n<li>이미 이 포함자의 조상인지 확인한다. ( base &#x3C; self )</li>\n<li>아닌 경우 종속성을 포함시킨다.</li>\n<li>예를들어 ActiveRecord::Validations이고, ActiveRecord::Base에 포함되는 경우임!</li>\n</ul>\n</li>\n<li>모든 종속성을 포함자의 조상 체인으로 롤링한 후에도 super으로 표준 append_features를 호출하여 조상 체인에 자신을 추가해야한다.</li>\n<li>ClassMethod 모듈로 includer를 확장해야한다. 이에대한 참조를 얻으려면 Kernel#const_get이 필요함</li>\n<li>Concern의 모듈 범위가 아닌 self의 범위에서 상수를 읽기 위함</li>\n</ul>\n<h3>Concern Wrap Up</h3>\n<ul>\n<li>ActiveSupport::Concern은 몇 줄의 코드로 단일 모듈로 래핑된 최소한의 종속성 관리 시스템</li>\n<li>그 코드는 복잡하지만, Active Model의 소스를 보면 알 수 있듯이 Concern을 사용하는 것은 쉽다</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">ActiveModel</span>\n  <span class=\"token keyword\">module</span> <span class=\"token constant\">Validations</span>\n    <span class=\"token keyword\">extend</span> <span class=\"token constant\">ActiveSupport</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Concern</span>\n      <span class=\"token comment\"># ...</span>\n    <span class=\"token keyword\">module</span> <span class=\"token constant\">ClassMethods</span>\n      <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">validate</span></span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span>args<span class=\"token punctuation\">,</span> <span class=\"token operator\">&amp;</span>block<span class=\"token punctuation\">)</span>\n      <span class=\"token comment\"># ...</span></code></pre></div>\n<ul>\n<li>일부는 이런 호출들 뒤에 숨겨진 너무 많은 마법들이 있고, 이런 숨겨진 복잡성엔 숨겨진 비용이 따른다고 한다.</li>\n<li>또 다른 일부는 Concern이 Rails 모듈을 최대한 슬림하고 단순하게 유지하는 데 도움을 준 것에.... 굿굿..</li>\n</ul>\n<h2>교훈</h2>\n<ul>\n<li>대부분의 언어에서는 구성 요소를 함께 묶는 방법이 많지 않다</li>\n<li>\n<p>클래스에서 상속하거나 객체에 위임할 수 있다.</p>\n<ul>\n<li>멋지게 만들고 싶다면 종속성 관리를 전문으로 하는 라이브러리 또는 전체 프레임워크를 사용할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>Rails의 개발자의 프레임워크의 일부를 함께 묶는 방법...</p>\n<ul>\n<li>처음에는 아마도 모듈을 포함하고 확장했을 것이고</li>\n<li>나중에는 코드에 메타프로그래밍의 마법의 가루를 뿌리고 include-and-extend 트릭을 사용</li>\n<li>나중에 Rails가 계속 성장하면서 이 관용구가 가장자리에서 삐걱거리기 시작했고..</li>\n<li>include-and-extend를 메타프로그래밍이 많은 ActiveSupport::Concern으로 대체했습니다.</li>\n<li>그들은 한 번에 한 단계씩 자체 종속성 관리 시스템을 발전시켰습니다.</li>\n</ul>\n</li>\n<li>수년에 걸쳐 우리는 소프트웨어 설계가 \"처음부터 제대로 하는\" 일이 아니라는 것을 배웠다.</li>\n<li>이것은 모듈이 상호 작용하는 방식과 같이 근본적인 것을 변경하기 위해 메타프로그래밍을 사용할 수 있는 Ruby와 같은 가단성 언어에서 특히 그렇다..</li>\n<li>\n<p>메타프로그래밍은 영리해지는 것이 아니라 융통성에 관한 것</p>\n<ul>\n<li>코드를 작성할 때 처음부터 완벽한 디자인을 위해 애쓰지 않고 복잡한 메타프로그래밍 트릭이 필요할 때까지 사용하지 않는다.</li>\n<li>대신 작업을 수행하는 가장 확실한 기술을 사용하여 코드를 단순하게 유지하려고 한다.</li>\n<li>어쩌면 어느 시점에서 내 코드가 엉키거나 완고한 중복을 발견할 수 있다..</li>\n<li>그 때 메타프로그래밍과 같은 더 좋은 방법을 찾게된다.</li>\n<li>이 책은 메타프로그래밍 성공 사례로 가득 차 있으며 ActiveSupport::Concern도 그 중 하나이다,....</li>\n<li>그러나 Concern의 복잡한 코드와 약간 논쟁의 여지가 있는 성격은 메타프로그래밍의 어두운 면을 암시한다...</li>\n<li>이것은 Rails의 가장 악명 높은 메소드에 대한 이야기를 살펴볼 다음 장의 주제</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"M Ruby - 10. Active Support's Concern Module","date":"May 16, 2021","update":"May 16, 2021","tags":["ruby","book"],"series":"Metaprogramming Ruby"},"fields":{"slug":"/metaprogramming-ruby-10/","readingTime":{"minutes":5.49}}},"seriesList":{"edges":[{"node":{"id":"34257cb7-20bf-52a1-a751-44435c07aa96","fields":{"slug":"/metaprogramming-ruby-1/"},"frontmatter":{"title":"M Ruby - 1"}}},{"node":{"id":"3ab153c7-ef8e-5540-a0ec-ee7551892012","fields":{"slug":"/metaprogramming-ruby-2/"},"frontmatter":{"title":"M Ruby - 2. The Object Model"}}},{"node":{"id":"ab0c5e49-f893-5aaf-8315-c183e6f9df3c","fields":{"slug":"/metaprogramming-ruby-3/"},"frontmatter":{"title":"M Ruby - 3. Methods"}}},{"node":{"id":"ba539d0b-e3b6-507e-90b2-12083666ad46","fields":{"slug":"/metaprogramming-ruby-4/"},"frontmatter":{"title":"M Ruby - 4. Blocks"}}},{"node":{"id":"10646ae4-ced4-5411-87f6-7011a8f5c108","fields":{"slug":"/metaprogramming-ruby-5/"},"frontmatter":{"title":"M Ruby - 5. Class Definitions"}}},{"node":{"id":"9d128593-da43-521b-832e-ff48a726844c","fields":{"slug":"/metaprogramming-ruby-6/"},"frontmatter":{"title":"M Ruby - 6. Code That Writes Code"}}},{"node":{"id":"02c9824b-fff1-5517-bcd6-eb7690b1fc5a","fields":{"slug":"/metaprogramming-ruby-9/"},"frontmatter":{"title":"M Ruby - 9. The Design of Active Record"}}},{"node":{"id":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","fields":{"slug":"/metaprogramming-ruby-10/"},"frontmatter":{"title":"M Ruby - 10. Active Support's Concern Module"}}},{"node":{"id":"b76117b8-cdf6-5fdb-a207-d3bada809e8d","fields":{"slug":"/metaprogramming-ruby-11/"},"frontmatter":{"title":"M Ruby - 11.alias_method_chain의 흥망성쇠"}}},{"node":{"id":"6d902f10-0216-599c-8523-7c663a9a2027","fields":{"slug":"/metaprogramming-ruby-12/"},"frontmatter":{"title":"M Ruby - 12. Attribute Methods의 진화"}}}]},"previous":{"fields":{"slug":"/metaprogramming-ruby-9/"},"frontmatter":{"title":"M Ruby - 9. The Design of Active Record"}},"next":{"fields":{"slug":"/metaprogramming-ruby-11/"},"frontmatter":{"title":"M Ruby - 11.alias_method_chain의 흥망성쇠"}}},"pageContext":{"id":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","series":"Metaprogramming Ruby","previousPostId":"02c9824b-fff1-5517-bcd6-eb7690b1fc5a","nextPostId":"b76117b8-cdf6-5fdb-a207-d3bada809e8d"}},"staticQueryHashes":[]}