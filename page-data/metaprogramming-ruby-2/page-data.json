{"componentChunkName":"component---src-templates-post-jsx","path":"/metaprogramming-ruby-2/","result":{"data":{"site":{"siteMetadata":{"title":"Seongjun Kim Blog"}},"markdownRemark":{"id":"3ab153c7-ef8e-5540-a0ec-ee7551892012","excerpt":"이제 시작이지만 재밌다. The Object Model 클래스, 모듈, 인스턴스 변수 등과 같은 언어의 구성 요소들은 Object Model이라는 시스템 모델에서 살아간다. Object Model에서 우린 \"이 메서드는 어떤 클래스의 것 인가요?\" 혹은 \"이 모듈을 포함하면 어떻게 되나요?\" 같은 답을 찾을 수 있다. 루비의 핵심인 Object Model…","html":"<p>이제 시작이지만 재밌다.</p>\n<h1>The Object Model</h1>\n<ul>\n<li>클래스, 모듈, 인스턴스 변수 등과 같은 언어의 구성 요소들은 Object Model이라는 시스템 모델에서 살아간다.</li>\n<li>Object Model에서 우린 \"이 메서드는 어떤 클래스의 것 인가요?\" 혹은 \"이 모듈을 포함하면 어떻게 되나요?\" 같은 답을 찾을 수 있다.</li>\n<li>루비의 <strong>핵심</strong>인 Object Model !</li>\n</ul>\n<h2>오픈 클래스 - Open Classes</h2>\n<ul>\n<li>특수문자 및 숫자를 제거하는 메서드와 그의 테스트 코드를 생각해 보자.</li>\n<li><code class=\"language-text\">test/unit</code> 은 <code class=\"language-text\">gem install test-unit</code> 이나 <code class=\"language-text\">bundle add test-unit</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">'test/unit'</span>\n\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">to_alphanumeric</span></span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n  s<span class=\"token punctuation\">.</span>gsub<span class=\"token punctuation\">(</span><span class=\"token regex\">/[^\\w\\s]/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">ToAlphanumericTest</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Test</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Unit</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">TestCase</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_strip_non_alphanumeric</span></span>\n    assert_equal <span class=\"token string\">'qwer asdf 1234'</span><span class=\"token punctuation\">,</span> to_alphanumeric<span class=\"token punctuation\">(</span><span class=\"token string\">'qwer !@#a.sdf 1@@23#4'</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">to_alphanumeric</code> 은 객체 지향적이지 않다.</li>\n<li>외부 메서드를 사용하는 것 보다 문자열이 직접 바꿀 수 있다면 더 좋을 것이다.</li>\n<li>하지만 그냥 일반적인 문자열인데... 메서드를 추가하려면 <code class=\"language-text\">AlphanumericString</code> 이런식의 클래스를 새로 작성???</li>\n</ul>\n<p><strong>간단한 해결책</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">'test/unit'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">to_alphanumeric</span></span>\n    gsub<span class=\"token punctuation\">(</span><span class=\"token regex\">/[^\\w\\s]/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">StringExtensionsTest</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">Test</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Unit</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">TestCase</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_strip_non_alphanumeric</span></span>\n    assert_equal <span class=\"token string\">'qwer asdf 1234'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'qwer !@#a.sdf 1@@23#4'</span><span class=\"token punctuation\">.</span>to_alphanumeric\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<h3>Inside Class Definitions</h3>\n<ul>\n<li>루비에서는 클래스를 정의하는 코드와 다른 종류의 코드가 차이가 없다.</li>\n<li>클래스 정의에 아무 코드나 넣을 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token comment\"># hello.rb</span>\n<span class=\"token number\">3.</span>times <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">class</span> <span class=\"token class-name\">Hello</span>\n      puts <span class=\"token string\">\"Hello\"</span>\n    <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">ruby hello.rb\nHello\nHello\nHello</code></pre></div>\n<ul>\n<li>다른 코드처럼 클래스 내에서 코드가 실행 되었다!</li>\n<li>그럼 위의 코드는 같은 이름으로 서로 다른 세 개의 클래스를 정의한 것일까?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Hello</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">a</span></span>\n    <span class=\"token string\">'a'</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Hello</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">b</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n\nhello <span class=\"token operator\">=</span> <span class=\"token constant\">Hello</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nhello<span class=\"token punctuation\">.</span>a <span class=\"token comment\"># => \"a\"</span>\nhello<span class=\"token punctuation\">.</span>b <span class=\"token comment\"># => \"b\"</span></code></pre></div>\n<ul>\n<li>처음 <code class=\"language-text\">Hello</code> 를 정의할 때는 <code class=\"language-text\">Hello</code> 라는 이름의 클래스가 존재하지 않는다.</li>\n<li>따라서 루비는 클래스와 메서드 <code class=\"language-text\">a</code> 를 정의한다.</li>\n<li>두 번째 에서는 클래스 <code class=\"language-text\">Hello</code> 는 이미 존재하기 때문에 정의할 필요가 없다.</li>\n<li>기존 클래스를 열고 y라는 메서드를 정의한다.</li>\n</ul>\n<p>루비의 클래스 키워드는 클래스를 선언하는 것 보다는 스코프 연산자에 가깝다.</p>\n<p>메서드를 정의할 수 있는 곳이 클래스의 컨텍스트에서 사용자로 이동</p>\n<p>기존 클래스를 언제든지 다시 열고 표준 라이브러리 클래스도 즉시 수정할 수 있다.</p>\n<p>이를 <strong>오픈 클래스</strong>라고 부른다.</p>\n<p>다른 예시를 한번 보자!</p>\n<h4>The Money Example</h4>\n<ul>\n<li>통화 관련 유틸리티 라이브러리인 <a href=\"https://github.com/RubyMoney/monetize\"><strong>Monetize</strong></a> Gem에서 오픈 클래스의 예를 찾을 수 있다.</li>\n<li><code class=\"language-text\">bundle add monetize</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">\"monetize\"</span>\n<span class=\"token comment\">#I18n.config.available_locales = :en</span>\n\nprice <span class=\"token operator\">=</span> <span class=\"token constant\">Monetize</span><span class=\"token punctuation\">.</span>from_numeric<span class=\"token punctuation\">(</span><span class=\"token number\">100</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"USD\"</span><span class=\"token punctuation\">)</span>\nprice<span class=\"token punctuation\">.</span>format <span class=\"token comment\"># => \"$10.00\"</span></code></pre></div>\n<ul>\n<li>이를 <code class=\"language-text\">Numeric#to_money</code> 을 통해서 숫자를 Money 로 만들 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">\"monetize\"</span>\n<span class=\"token comment\">#I18n.config.available_locales = :en</span>\n\nprice <span class=\"token operator\">=</span> <span class=\"token number\">10.</span>to_money\nprice<span class=\"token punctuation\">.</span>format</code></pre></div>\n<ul>\n<li>Numeric은 Ruby의 스탠다드 클래스이다. <code class=\"language-text\">Numeric#to_money</code> 는 어디서 온 걸까?</li>\n</ul>\n<p><a href=\"https://github.com/RubyMoney/monetize/blob/main/lib/monetize/core_extensions/numeric.rb\">lib/monetize/core_extensions/numeric.rb</a></p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Numeric</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">to_money</span></span><span class=\"token punctuation\">(</span>currency <span class=\"token operator\">=</span> <span class=\"token keyword\">nil</span><span class=\"token punctuation\">)</span>\n    <span class=\"token constant\">Monetize</span><span class=\"token punctuation\">.</span>from_numeric<span class=\"token punctuation\">(</span><span class=\"token keyword\">self</span><span class=\"token punctuation\">,</span> currency <span class=\"token operator\">||</span> <span class=\"token constant\">Money</span><span class=\"token punctuation\">.</span>default_currency<span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>라이브러리에서 Open Class를 이런 방식으로 사용하는 것은 매우 일반적이다!</li>\n<li>하지만 나쁜 케이스도 있다...</li>\n</ul>\n<h3>The Problem with Open Classes</h3>\n<ul>\n<li>배열의 요소를 바꾸는 메서드를 생각해보자</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">'test/unit'</span>\n<span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">replace</span></span><span class=\"token punctuation\">(</span>array<span class=\"token punctuation\">,</span> original<span class=\"token punctuation\">,</span> replacement<span class=\"token punctuation\">)</span>\n  array<span class=\"token punctuation\">.</span>map <span class=\"token punctuation\">{</span><span class=\"token operator\">|</span>e<span class=\"token operator\">|</span> e <span class=\"token operator\">==</span> original <span class=\"token operator\">?</span> replacement <span class=\"token punctuation\">:</span> e <span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">end</span>\n\n<span class=\"token comment\"># ...</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">test_replace</span></span>\n    original <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token string\">'one'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'three'</span><span class=\"token punctuation\">]</span>\n    replaced <span class=\"token operator\">=</span> replace<span class=\"token punctuation\">(</span>original<span class=\"token punctuation\">,</span> <span class=\"token string\">'one'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'zero'</span><span class=\"token punctuation\">)</span>\n    assert_equal <span class=\"token punctuation\">[</span><span class=\"token string\">'zero'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'two'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'zero'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'three'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> replaced\n  <span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>메서드의 내부 동작보다 유닛 테스트를 통해 어떻게 사용되는지 확인이 가능하다.</li>\n<li>이번에도 <code class=\"language-text\">replace</code>라는 메서드를 Array 클래스에 새로 추가해도 되겠지?</li>\n<li>하지만... <code class=\"language-text\">irb</code> 를 실행하고 Array의 기본 메서드 목록을 받아보면</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sh\"><pre class=\"language-sh\"><code class=\"language-sh\">&gt; irb\nirb(main):001:0&gt; [].methods.grep /^replace/\n=&gt; [:replace]</code></pre></div>\n<ul>\n<li>이미 <code class=\"language-text\">Array</code>는 <code class=\"language-text\">replace</code> 라는 메서드를 갖고있다.</li>\n<li>이를 overwrite해버리면 다른 코드에서 문제가 발생할 수 있다.</li>\n<li>이게 바로 <strong>Open Classes의 어두운 면이다</strong></li>\n<li>이런식으로 클래스를 무모하게 Patching -> MonkeyPatch 라고 불린다..</li>\n</ul>\n<h2>Inside the Object Model</h2>\n<p>루비의 클래스, 그리고 object model에 대한 몇몇 진실은 꽤 충격적!</p>\n<p>일단 기본부터 시작해보자.</p>\n<h3>What's in an Object</h3>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n    <span class=\"token variable\">@val</span> <span class=\"token operator\">=</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nobj <span class=\"token operator\">=</span> <span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nobj<span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span> <span class=\"token comment\">#=> Myclass</span></code></pre></div>\n<h4>Instance Variables</h4>\n<ul>\n<li>객체에는 인스턴스 변수가 포함되어있다.</li>\n<li><code class=\"language-text\">Object#instance_variables</code> 로 확인이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">obj<span class=\"token punctuation\">.</span>my_method\nobj<span class=\"token punctuation\">.</span>instance_variables</code></pre></div>\n<ul>\n<li>자바나 다른 정적 언어와 달리 루비에서는 클래스와 인스턴스 변수 사이의 연결이 없다.</li>\n<li>만약 <code class=\"language-text\">obj.my_method</code> 를 호출하지 않았다면 <code class=\"language-text\">obj</code> 는 인스턴스 변수가 없었을 것이다.</li>\n</ul>\n<h4>Methods</h4>\n<ul>\n<li><code class=\"language-text\">Object#methods</code> 를 통해 메서드의 리스트를 얻을 수 있다.</li>\n<li><code class=\"language-text\">obj.methods</code> 를 하면 <code class=\"language-text\">Object</code> 로부터 많은 메서드를 상속하므로 꽤나 길다!</li>\n<li><code class=\"language-text\">Array#grep</code> 으로 필터링해서 봐보면</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\">obj<span class=\"token punctuation\">.</span>methods<span class=\"token punctuation\">.</span>grep<span class=\"token punctuation\">(</span><span class=\"token regex\">/my/</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">#=> [:my_methods]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">pry</code> 를 열고 <code class=\"language-text\">obj</code> 을 보면 실제로 메서드 목록을 갖고있지 않다는 것을 알 수 있다.</li>\n<li><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 675px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/66be913c61135307b8cd409884a66604/a0bb6/2021-04-08-08-25-03.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 14.705882352941178%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgklEQVQI133OyQrCMBgE4D5HtoOJ+ZugxC2JkGqRFoTeevD9H2XUHERwOXynYYZpYsoYxhH9ZUApBTlFaL2AlBJKqa+e2a+8WcYr6HRDW2bscoeUjyBqwRiDeJSEEC+c8+p9+GPQpAlmc4b2e6wPHWi1hbEE7x2stZVzrgohVP8e3gES8VY/iZsXfAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='2021 04 08 08 25 03' title='2021 04 08 08 25 03' src='/static/66be913c61135307b8cd409884a66604/a0bb6/2021-04-08-08-25-03.png' srcset='/static/66be913c61135307b8cd409884a66604/e7570/2021-04-08-08-25-03.png 170w,\n/static/66be913c61135307b8cd409884a66604/f46e7/2021-04-08-08-25-03.png 340w,\n/static/66be913c61135307b8cd409884a66604/a0bb6/2021-04-08-08-25-03.png 675w' sizes='(max-width: 675px) 100vw, 675px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></li>\n<li>객체는 해당 인스턴스 변수와 클래스에 대한 참조만 있다.</li>\n<li>동일한 클래스를 공유하는 객체도 동일한 메서드를 공유하므로 메서드는 객체가 아닌 클래스에 저장되어야 한다.</li>\n</ul>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/cc0d8/2021-04-08-09-25-03.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 40%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABNklEQVQoz1VRW5KDMAzj/jfs7EB55QUhECjp/mnlpHTbD2ESx7JkV89kIEinwUnsu8ayjgibynE/NFIquTWqdy5sIx6Pci/xQqUXi8Fb+M3g4IUPI+ZlwERI8RwGBEZpaOcerbqj0y3M1ONgs2Vj/WzROIeZ/5UJ5WAZp9WSoKiwfsjqhLgeG6ipy/eRDkTVFvkmmEwSD6rfi6AqnRq/ibZOnVWIOkMlnsocSUVxIVDQJBVl1vfoTVvIxfZDmuhiWT7HC1IoKprxjobWMuFaZvVMNhPWQ4NbV+PW1qwphF8z/DxIMvGR2HaLQqQt6Z5eg993qvSKTTTHob6I3oR5S9eGOQu1OPSzw+gdl+XwY0vM6qPNOYHn7K5G5/kPKhTvBQcJQ2ThVnD9r9G88ppzK2dZxGfthT9IK1oyUlTrsQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='2021 04 08 09 25 03' title='2021 04 08 09 25 03' src='/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/ca1dc/2021-04-08-09-25-03.png' srcset='/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/e7570/2021-04-08-09-25-03.png 170w,\n/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/f46e7/2021-04-08-09-25-03.png 340w,\n/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/ca1dc/2021-04-08-09-25-03.png 680w,\n/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/02d09/2021-04-08-09-25-03.png 1020w,\n/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/9d567/2021-04-08-09-25-03.png 1360w,\n/static/ecbc1ecacbf79bdaee7f1b82c54d1f66/cc0d8/2021-04-08-09-25-03.png 1647w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<ul>\n<li>obj 는 my_methods를 갖고있다.</li>\n<li>\n<p><code class=\"language-text\">MyClass</code> 에는 my_method라는 이름의 메서드가 있다 라고 하면 안된다.</p>\n<ul>\n<li><code class=\"language-text\">MyClass.my_method</code> 를 클래스 메서드처럼 호출할 수 있다는 의미</li>\n</ul>\n</li>\n<li>모호함을 없애기 위해 my_method가 MyClass의 인스턴스 메서드라고 해야한다.</li>\n<li>이 설명을 기억한다면 다음과 같은 introspective code를 작성할 때 혼동하지 않을 것이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">String</span><span class=\"token punctuation\">.</span>instance_methods <span class=\"token operator\">==</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">.</span>methods    <span class=\"token comment\"># => true</span>\n<span class=\"token builtin\">String</span><span class=\"token punctuation\">.</span>methods <span class=\"token operator\">==</span> <span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">.</span>methods             <span class=\"token comment\"># => false</span></code></pre></div>\n<p>자 정리해보자, <strong>객체</strong>의 <strong>인스턴스 변수는 객체</strong>에 존재하고 객체의 <strong>메서드는 클래스</strong>에 존재한다. 따라서 같은 클래스의 객체는 메서드는 공유하지만 인스턴스 변수는 공유하지 않는다.</p>\n<h3>Thre Truth About Classes</h3>\n<ul>\n<li>클래스는 오브젝트에 불과하다.</li>\n<li>클래스는 객체이므로 다른 객체에 적용되는 것들이 클래스에도 적용이 된다.</li>\n<li>클래스는 다른 객체와 마찬가지로 클래스라는 자체 클래스가 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span>   <span class=\"token comment\"># => String</span>\n<span class=\"token builtin\">String</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span>    <span class=\"token comment\"># => Class</span></code></pre></div>\n<ul>\n<li>다른 객체를 조작하는 것 처럼 조작이 가능하다!</li>\n<li><a href=\"/metaprogramming-ruby-5\">Chapter 5</a> 에서 처럼 <code class=\"language-text\">Class.new</code> 를 호출하여 프로그램이 실행되는 동안 새 클래스를 만들 수 있다.</li>\n<li>이런 유연성이 루비의 메타프로그래밍의 전형적인 특징</li>\n<li>클래스의 메서드는 클래스의 인스턴스 메서드!</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">Class</span><span class=\"token punctuation\">.</span>instance_methods<span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span>   <span class=\"token comment\"># => [:allocate, :new, :superclass]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">new</code>는 항상 객체를 생성할 때 사용하니까 다들 알죠?</li>\n<li><code class=\"language-text\">superclass</code> 는 상속과 관련있다. 루비의 클래스는 그 슈퍼클래스에서 상속된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">Array</span><span class=\"token punctuation\">.</span>superclass        <span class=\"token comment\"># => Object</span>\n<span class=\"token builtin\">Object</span><span class=\"token punctuation\">.</span>superclass       <span class=\"token comment\"># => BasicObject</span>\n<span class=\"token constant\">BasicObject</span><span class=\"token punctuation\">.</span>superclass  <span class=\"token comment\"># => nil</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Array</code>는 <code class=\"language-text\">Object</code> 를 상속받고 <code class=\"language-text\">Object</code> 에는 <code class=\"language-text\">to_s</code> 같은 객체에 일반적으로 유용한 메서드를 포함한다.</li>\n<li><code class=\"language-text\">Object</code> 는 <code class=\"language-text\">BasicObject</code> 에서 상속된다. 여기엔 몇가지 필수 메서드만 포함</li>\n<li><code class=\"language-text\">Class</code> 의 슈퍼클래스는 무엇일까?</li>\n</ul>\n<h4>Modules</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token builtin\">Class</span><span class=\"token punctuation\">.</span>superclass        <span class=\"token comment\"># => Module</span></code></pre></div>\n<ul>\n<li>클래스의 슈퍼클래스는 모듈이다.</li>\n<li>\n<p>클래스는 객체를 만들거나 클래스를 계층 구조로 정렬할 수 있는 세 가지 인스턴스 메서드가 추가로 포함된 모듈이다.</p>\n<ul>\n<li>new, allocate, superclass</li>\n</ul>\n</li>\n<li>모듈은 보통 어딘가에 포함되려고,</li>\n<li>클래스는 인스턴스화 되거나 상속되려면 클래스</li>\n</ul>\n<h3>Constants</h3>\n<ul>\n<li>클래스 및 모듈의 이름을 포함하여 대문자로 시작하는 모든 참조는 상수이다.</li>\n<li>경고를 받긴 하겠지만 상수의 값을 변경할 수 있다.</li>\n<li>그럼 변수랑 상수가 뭐가 다른가? - 스코프가 다르다. 상수의 스코프는 고유한 특수 규칙이 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">MyModule</span>\n  <span class=\"token constant\">MyConstant</span> <span class=\"token operator\">=</span> <span class=\"token string\">'Outer constant'</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n    <span class=\"token constant\">MyConstant</span> <span class=\"token operator\">=</span> <span class=\"token string\">'Inner constant'</span>\n<span class=\"token keyword\">end</span> <span class=\"token keyword\">end</span></code></pre></div>\n<p><span class='gatsby-resp-image-wrapper' style='position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; margin-bottom: 16px;'>\n      <a class='gatsby-resp-image-link' href='/static/7e27c1dc5d362721b95ae8f757a71196/a044f/2021-04-08-10-11-34.png' style='display: block' target='_blank' rel='noopener'>\n    <span class='gatsby-resp-image-background-image' style=\"padding-bottom: 53.529411764705884%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAlElEQVQoz72RuwoEIQxFx3EUH4ggCrvCymBlIVgKVv7/V21w2oHZNHuKgI/k3iTbdgchZPs3x3EYY5xzjDE47vuOcAFpKaVa63uRc1ZKwT3n/KHK9WytDSGAMsTX4rOglD6LCyG89yB7nmeMEWqRxa/modXLQmsNnXx9BatjjN77nLOUgl6hlBK6gJlprXFrw7nF8gXjzgqf1I9YkwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"></span>\n  <img class='gatsby-resp-image-image' alt='2021 04 08 10 11 34' title='2021 04 08 10 11 34' src='/static/7e27c1dc5d362721b95ae8f757a71196/ca1dc/2021-04-08-10-11-34.png' srcset='/static/7e27c1dc5d362721b95ae8f757a71196/e7570/2021-04-08-10-11-34.png 170w,\n/static/7e27c1dc5d362721b95ae8f757a71196/f46e7/2021-04-08-10-11-34.png 340w,\n/static/7e27c1dc5d362721b95ae8f757a71196/ca1dc/2021-04-08-10-11-34.png 680w,\n/static/7e27c1dc5d362721b95ae8f757a71196/02d09/2021-04-08-10-11-34.png 1020w,\n/static/7e27c1dc5d362721b95ae8f757a71196/9d567/2021-04-08-10-11-34.png 1360w,\n/static/7e27c1dc5d362721b95ae8f757a71196/a044f/2021-04-08-10-11-34.png 2527w' sizes='(max-width: 680px) 100vw, 680px' style='width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;' loading='lazy'>\n  </a>\n    </span></p>\n<ul>\n<li>모든 상수는 파일 시스템과 유사한 트리에 배열되어 있다</li>\n<li>모듈, 클래스는 디렉터리이고 상수는 파일임</li>\n<li>동일한 이름을 가진 여러 파일을 가질 수 있다</li>\n<li>파일 처럼 상수를 경로로 나타낼 수도 있다.</li>\n</ul>\n<h4>The Paths of Constants</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">X</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a root-level constant'</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">M</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span>\n    <span class=\"token constant\">X</span> <span class=\"token operator\">=</span> <span class=\"token string\">'a constant'</span>\n    p <span class=\"token constant\">X</span> <span class=\"token comment\"># => \"a constant\"</span>\n    p <span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">X</span>  <span class=\"token comment\"># => \"a root-level constant\"</span>\n    p <span class=\"token builtin\">Module</span><span class=\"token punctuation\">.</span>nesting\n  <span class=\"token keyword\">end</span>\n  <span class=\"token constant\">C</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">X</span> <span class=\"token comment\"># => \"a constant\"</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">M</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">C</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">X</span> <span class=\"token comment\"># => \"a constant\"</span></code></pre></div>\n<ul>\n<li>모듈 클래스도 인스턴스 메서드 클래스 메서드를 제공하고 이 둘을 constants라고 부른다.</li>\n<li><code class=\"language-text\">Modules#constants</code> 는 현재 스코프의 모든 상수를 반환한다.</li>\n<li><code class=\"language-text\">Module.constants</code>는 최상위 상수들을 반환한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">M</span><span class=\"token punctuation\">.</span>constants                        <span class=\"token comment\"># => [:C]</span>\n<span class=\"token builtin\">Module</span><span class=\"token punctuation\">.</span>constants<span class=\"token punctuation\">.</span><span class=\"token keyword\">include</span><span class=\"token operator\">?</span> <span class=\"token symbol\">:Object</span>  <span class=\"token comment\"># => true</span>\n<span class=\"token builtin\">Module</span><span class=\"token punctuation\">.</span>constants<span class=\"token punctuation\">.</span><span class=\"token keyword\">include</span><span class=\"token operator\">?</span> <span class=\"token symbol\">:Module</span>  <span class=\"token comment\"># => true</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Module.nesting</code> 으로는 current path를 얻을 수 있다.</li>\n</ul>\n<p>루비의 상수와 파일 간의 유사성은 더 나아가 파일을 정리할 때 디렉토리를 사용하는 것과 마찬가지로 모듈을 사용하여 상수를 구성할 수 있다.</p>\n<h4>The Rake Example</h4>\n<ul>\n<li>루비의 빌드 시스템 <code class=\"language-text\">Rake</code> 의 초기 버전은 <code class=\"language-text\">Task</code>, <code class=\"language-text\">FileTask</code> 와 같이 명확한 이름의 클래스를 정의했다.</li>\n<li>다른 라이브러리들과 충돌 할 가능성이 높았다.</li>\n<li><code class=\"language-text\">Rake</code>내의 모듈에서 다음처럼 클래스를 정의하는 것으로 전환하였다.</li>\n</ul>\n<p><a href=\"https://github.com/ruby/rake/blob/master/lib/rake/task.rb\">lib/rake/task.rb</a></p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token comment\">#...</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">Rake</span>\n  <span class=\"token comment\">#...</span>\n   <span class=\"token keyword\">class</span> <span class=\"token class-name\">Task</span>\n     <span class=\"token comment\">#..</span></code></pre></div>\n<ul>\n<li>이제 Task의 이름은 <code class=\"language-text\">Rake::Task</code> 이고 이제 다른 라이브러리와 충돌하지 않을 것이다.</li>\n<li><code class=\"language-text\">Rake</code> 같은 모듈 중 상수의 구성 요소로만 존재하는 모듈을 <strong>네임스페이스</strong>라고 한다.</li>\n<li>이전 버전에 대한 대응</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">Task</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Rake</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">Task</span>\n<span class=\"token constant\">FileTask</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Rake</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">FileTask</span>\n<span class=\"token constant\">FileCreationTask</span> <span class=\"token operator\">=</span> <span class=\"token constant\">Rake</span><span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token constant\">FileCreationTask</span></code></pre></div>\n<ul>\n<li>위 처럼 대응하고 사용자가 모두 마이그레이션 했다고 생각 되었을 때 옵션을 나중에 제거</li>\n</ul>\n<h3>Objects and Classes Wrap-Up</h3>\n<ul>\n<li>객체란 무엇인가? - 인스턴스 변수와 클래스에 대한 링크이다.</li>\n<li>\n<p>클래스란 무엇인가? - 객체와 인스턴스 메소드 목록 및 슈퍼클래스에 대한 링크이다.</p>\n<ul>\n<li>클래스는 모듈의 하위클래스이므로 클래스도 모듈이다.</li>\n<li>다른 객체들과 마찬가지로 클래스에는 메서드가 있고, 클래스(클래스 이름!)에 대한 상수 참조가 이미 있다.</li>\n</ul>\n</li>\n</ul>\n<h3>Using Namespaces</h3>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">Text</span>\n  <span class=\"token comment\">#...</span>\n  <span class=\"token comment\"># Type Error: Text is not a class</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Action Mailer</code> 에서 <code class=\"language-text\">Text</code> 라는 모듈 이름을 쓰고있다.</li>\n<li>따라서 다음처럼 변경하여 사용</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">Hello</span>\n  <span class=\"token keyword\">class</span> <span class=\"token class-name\">Text</span></code></pre></div>\n<h2>What Happens When You Call a Method?</h2>\n<h3>Method Lookup</h3>\n<ul>\n<li>수신자 ( receiver ) 와 조상 ( ancestors )의 chain</li>\n<li>\n<p>수신자는 메서드를 호출하는 객체이다.</p>\n<ul>\n<li><code class=\"language-text\">my_string.reverse()</code> 라면 <code class=\"language-text\">my_string</code> 이 수신자</li>\n</ul>\n</li>\n<li>ancestors chain은 superclass로 타고 올라가는 경로</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span><span class=\"token punctuation\">;</span> <span class=\"token string\">'my_method()'</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">MySubclass</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">MyClass</span>\n<span class=\"token keyword\">end</span>\nobj <span class=\"token operator\">=</span> <span class=\"token constant\">MySubclass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nobj<span class=\"token punctuation\">.</span>my_method<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>       <span class=\"token comment\"># => \"my_method()\"</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">my_method()</code>를 호출하면 수신자인 <code class=\"language-text\">obj</code> 에서 <code class=\"language-text\">MySubclass</code> 로 바로 들어간다.</li>\n<li><code class=\"language-text\">my_method()</code>를 찾을 수 없으므로 <code class=\"language-text\">MyClass</code> 로 올라가서 찾고 그곳에서 <code class=\"language-text\">my_method()</code> ㄹㅡㄹ 찾을 수 있다.</li>\n<li><code class=\"language-text\">MyClass</code> 는 superclass를 지정하지 않으므로 기본 superclass에서 암시적으로 상속된다.</li>\n<li>만약 <code class=\"language-text\">MyClass</code> 에서도 못찾았으면 <code class=\"language-text\">Object</code> , <code class=\"language-text\">BasicObject</code> 로 체인을 올려서 메서드를 찾을 것 이다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">MySubclass</span><span class=\"token punctuation\">.</span>ancestors <span class=\"token comment\"># => [MySubclass, MyClass, Object, Kernel, BasicObject]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Kernel</code> 은 모듈이겠지 뭐</li>\n</ul>\n<h3>Modules and Lookup</h3>\n<ul>\n<li><code class=\"language-text\">include</code> 를 통해서 클래스를 모듈에 포함시킬 수 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">M1</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n    <span class=\"token string\">'M1#my_method()'</span>\n<span class=\"token keyword\">end</span> <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">C</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">M1</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">D</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">C</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token constant\">D</span><span class=\"token punctuation\">.</span>ancestors <span class=\"token comment\"># => [D, C, M1, Object, Kernel, BasicObject]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">prepend</code> 를 통해서 아래에 모듈을 포함 시킬수도 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">C2</span>\n  <span class=\"token keyword\">prepend</span> <span class=\"token constant\">M2</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">D2</span> <span class=\"token operator\">&lt;</span> <span class=\"token constant\">C2</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token constant\">D2</span><span class=\"token punctuation\">.</span>ancestors <span class=\"token comment\"># => [D2, M2, C2, Object, Kernel, BasicObject]</span></code></pre></div>\n<ul>\n<li>만약 모듈을 여러 번 동일한 조상 체인에 포함하려고 하면?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">M1</span><span class=\"token punctuation\">;</span> <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">M2</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">M1</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">M3</span>\n  <span class=\"token keyword\">prepend</span> <span class=\"token constant\">M1</span>\n  <span class=\"token keyword\">include</span> <span class=\"token constant\">M2</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token constant\">M3</span><span class=\"token punctuation\">.</span>ancestors <span class=\"token comment\"># => [M1, M3, M2]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">M3</code> 에서 prepend를 먼저 하고 이후에 M2를 추가하지만 이미 M1이 조상들의 사슬에 있기 때문에 포함되지 않는다.</li>\n</ul>\n<h3>The Kernel</h3>\n<ul>\n<li>루비에는 print 같은 메서드가 있어 어느 곳에서나 호출이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token constant\">Kernel</span><span class=\"token punctuation\">.</span>private_instance_methods<span class=\"token punctuation\">.</span>grep<span class=\"token punctuation\">(</span><span class=\"token regex\">/^pr/</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># => [:printf, :print, :proc]</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">Object</code> 클래스가 <code class=\"language-text\">Kernel</code>을 포함하므로 커널은 모든 오브젝트의 상위 체인에 들어간다.</li>\n<li>따라서 Ruby의 모든 줄은 항상 <code class=\"language-text\">Object</code> 안에서 실행되므로 <code class=\"language-text\">Kernel</code> 의 인스턴스 메서드를 호출할 수 있다.</li>\n<li>므찌다, 이런 커널 메서드가 실제로 유용하다는 것을 증명하기 위해 일부 라이브러리 살펴보자</li>\n</ul>\n<h4>The Awesome Print Example</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">require</span> <span class=\"token string\">\"awesome_print\"</span>\n  local_time <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span><span class=\"token symbol\">:city</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token string\">\"Rome\"</span><span class=\"token punctuation\">,</span> <span class=\"token symbol\">:now</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token builtin\">Time</span><span class=\"token punctuation\">.</span>now <span class=\"token punctuation\">}</span>\n  ap local_time<span class=\"token punctuation\">,</span> <span class=\"token symbol\">:indent</span> <span class=\"token operator\">=</span><span class=\"token operator\">></span> <span class=\"token number\">2</span></code></pre></div>\n<ul>\n<li>어디서든 <code class=\"language-text\">ap</code> 를 부를 수 있다.</li>\n</ul>\n<p><a href=\"https://github.com/awesome-print/awesome_print/blob/master/lib/awesome_print/core_ext/kernel.rb\">lib/awesome<em>print/core</em>ext/kernel.rb</a></p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">Kernel</span>\n <span class=\"token comment\">#...</span>\n <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">ap</span></span><span class=\"token punctuation\">(</span>object<span class=\"token punctuation\">,</span> options<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n <span class=\"token comment\">#...</span>\n <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<h3>Method Execution</h3>\n<ul>\n<li>\n<p>메서드를 호출하면 루비든 두 가지 일을 한다.</p>\n<ol>\n<li>메서드 찾기</li>\n<li>실행하기</li>\n</ol>\n</li>\n<li>my_method를 실행했다고 해보자</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n  temp <span class=\"token operator\">=</span> <span class=\"token variable\">@x</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n  my_other_method<span class=\"token punctuation\">(</span>temp<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>인스턴스 변수 @x가 속한 객체는 뭘까?</li>\n<li>어떤 객체의 my<em>other</em>method 를 불러야 할까?</li>\n<li>직관적으로 모두 수신자에 속한다는걸 알 수 있다.</li>\n<li>하지만 루비는 직관이 없으므로 수신자에 대한 참조를 넣어둔다.</li>\n</ul>\n<h4>The Self Keyword</h4>\n<ul>\n<li>루비 코드의 모든 줄은 오브젝트 안에서 실행된다. ( current object 라고 함)</li>\n<li>current object는 또한 <code class=\"language-text\">self</code> 로 불리기도 한다. 우리가 <code class=\"language-text\">self</code> 로 접근이 가능함</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">testing_self</span></span>\n    <span class=\"token variable\">@var</span> <span class=\"token operator\">=</span> <span class=\"token number\">10</span> <span class=\"token comment\"># An instance variable of self</span>\n    my_method<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\"># Same as self.my_method()</span>\n    <span class=\"token keyword\">self</span>\n<span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n    <span class=\"token variable\">@var</span> <span class=\"token operator\">=</span> <span class=\"token variable\">@var</span> <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nobj <span class=\"token operator\">=</span> <span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span>\nobj<span class=\"token punctuation\">.</span>testing_self  <span class=\"token comment\"># => #&lt;MyClass:0x007f93ab08a728 @var=11></span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">testing_self</code> 를 호출하는 순간 obj는 self가 된다.</li>\n<li>@var는 obj의 인스턴스 변수이며 my_method는 obj에서 호출 된다.</li>\n<li>마지막으로 self에 대한 참조를 반환한다.</li>\n<li>따라서 루비를 잘 쓰려면 주어진 순간에 어떤 객체가 self인지를 항상 알아야 한다.</li>\n<li>어떤 객체가 마지막 메서드 수신자인지 추적 하기만 하면 된다.</li>\n<li>하지만 두가지 특별한 경우가 있음!</li>\n</ul>\n<h4>The Top Level</h4>\n<p>irb를 열고 다음처럼 쳐보면?</p>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">self</span>        <span class=\"token comment\"># => main</span>\n<span class=\"token keyword\">self</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span>  <span class=\"token comment\"># => Object</span></code></pre></div>\n<ul>\n<li>루비 프로그램을 시작하자 마자 루비의 인터프리터는 <code class=\"language-text\">Main</code>이라는 이름의 오브젝트 안에 우리를 위치시킨다.</li>\n<li>\n<p>이 오브젝트를 최상위 컨텍스트라고 부른다.</p>\n<ul>\n<li>콜 스텍의 최상위 레벨에 있는 오브젝트이므로</li>\n<li>아직 메서드를 호출하지 않았거나 모든 메서드가 반환되었다.</li>\n</ul>\n</li>\n</ul>\n<h4>Class Definitions and self</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">self</span>        <span class=\"token comment\"># => MyClass</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<p>요약하자면</p>\n<ul>\n<li>메서드를 호출하면 루비가 규칙에 따라 메소드를 조회한 뒤 수신자를 self로 두고 메서드를 실행한다.</li>\n<li>몇 가지 특별한</li>\n<li>경우( 모듈 포함 ) 가 있지만 예외는 없다. (하나를 제외하고)</li>\n</ul>\n<h3>Refinenments</h3>\n<ul>\n<li>이번 장 초반의 부분을 기억하는가?</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">String</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">to_alphanumeric</span></span>\n    gsub<span class=\"token punctuation\">(</span><span class=\"token regex\">/[^\\w\\s]/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>이 변경사항은 전역적이라는 문제가 있다.</li>\n<li>모든 String 이 영향을 받고, 호환이 되지 않는 Monkeypatch라면 - <code class=\"language-text\">Array#replace</code> 과 같은</li>\n<li><code class=\"language-text\">Refindement</code> 를 통해 해결이 가능하다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">StringExtensions</span>\n    refine <span class=\"token builtin\">String</span> <span class=\"token keyword\">do</span>\n      <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">to_alphanumeric</span></span>\n        gsub<span class=\"token punctuation\">(</span><span class=\"token regex\">/[^\\w\\s]/</span><span class=\"token punctuation\">,</span> <span class=\"token string\">''</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">end</span>\n    <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span></code></pre></div>\n<ul>\n<li>\n<p><code class=\"language-text\">&quot;my *1st* refinement!&quot;.to_alphanumeric</code></p>\n<ul>\n<li>=> <code class=\"language-text\">NoMethodError: undefined method &#39;to_alphanumeric&#39; [...]</code></li>\n</ul>\n</li>\n<li>using method를 사용해서 변경을 적용한다.</li>\n<li><code class=\"language-text\">using StringExtensions</code></li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">module</span> <span class=\"token constant\">StringExtensions</span>\n  refine <span class=\"token builtin\">String</span> <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">reverse</span></span>\n      <span class=\"token string\">\"esrever\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">StringStuff</span>\n  using <span class=\"token constant\">StringExtensions</span>\n  <span class=\"token string\">\"my_string\"</span><span class=\"token punctuation\">.</span>reverse\n<span class=\"token keyword\">end</span>\n<span class=\"token string\">\"my_string\"</span><span class=\"token punctuation\">.</span>reverse\n<span class=\"token comment\"># => \"esrever\"</span>\n<span class=\"token comment\"># => \"gnirts_ym\"</span></code></pre></div>\n<ul>\n<li>Refinement는 Monkeypatches 같지만 전역적이진 않다.</li>\n<li>그러면서 일반적으로 오픈 클래스가 할 수 있는 모든 작업이 가능하다.</li>\n</ul>\n<h4>Refinement Gotchas</h4>\n<div class=\"gatsby-highlight\" data-language=\"ruby\"><pre class=\"language-ruby\"><code class=\"language-ruby\"><span class=\"token keyword\">class</span> <span class=\"token class-name\">MyClass</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n    <span class=\"token string\">\"original my_method()\"</span>\n  <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">another_method</span></span>\n    my_method\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\n<span class=\"token keyword\">module</span> <span class=\"token constant\">MyClassRefinement</span>\n  refine <span class=\"token constant\">MyClass</span> <span class=\"token keyword\">do</span>\n    <span class=\"token keyword\">def</span> <span class=\"token method-definition\"><span class=\"token function\">my_method</span></span>\n      <span class=\"token string\">\"refined my_method()\"</span>\n    <span class=\"token keyword\">end</span>\n  <span class=\"token keyword\">end</span>\n<span class=\"token keyword\">end</span>\nusing <span class=\"token constant\">MyClassRefinement</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>my_method <span class=\"token comment\"># =>  \"refined my_method()\"</span>\n<span class=\"token constant\">MyClass</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">new</span><span class=\"token punctuation\">.</span>another_method  <span class=\"token comment\"># =>  \"original my_method()\"</span></code></pre></div>\n<ul>\n<li><code class=\"language-text\">MyClass.new.my_method</code> 의 호출은 using 이후지만</li>\n<li><code class=\"language-text\">MyClass</code> 의 인스턴스 메서드 <code class=\"language-text\">my_method</code> 의 호출은 using 이전이므로 ...</li>\n<li>직관에 조금 어긋나는 것 같다..</li>\n<li>일반 모듈에서 refine을 사용할 수 있지만 클래스 자체가 모듈인 경우에 클래스에서 이를 호출할 수 없다.</li>\n<li>또한 메서드나 조상을 아예 무시해버린다.</li>\n<li>이런 동작은 타당한 기술적 정당성을 갖고 있지만 꽤나 어렵다..</li>\n<li>refine은 몽키 패치를 제거할 수 있지만 잘 사용하는 방법을 이해하는 것은 시간이 걸린다.</li>\n</ul>\n<h2>Wrap Up!</h2>\n<ul>\n<li>객체는 인스턴스 변수와 클래스에 대한 링크로 구성된다.</li>\n<li>객체의 메서드는 객체의 클래스에 존재한다.</li>\n<li>\n<p>클래스는 Class클래스의 오브젝트일 뿐이다.</p>\n<ul>\n<li>클래스의 이름은 그냥 상수임</li>\n<li>클래스는 모듈을 상속받는다.</li>\n</ul>\n</li>\n<li>\n<p>상수는 파일 시스템과 유사하게 트리에 배열되어 있다.</p>\n<ul>\n<li>모듈과 클래스의 이름은 디렉터리, 상수는 파일</li>\n</ul>\n</li>\n<li>클래스에는 클래스에서 시작하여 BasicObject로 올라가는 조상 체인이 있음</li>\n</ul>","frontmatter":{"title":"M Ruby - 2. The Object Model","date":"April 08, 2021","update":"April 08, 2021","tags":["ruby","book"],"series":"Metaprogramming Ruby"},"fields":{"slug":"/metaprogramming-ruby-2/","readingTime":{"minutes":11.39}}},"seriesList":{"edges":[{"node":{"id":"34257cb7-20bf-52a1-a751-44435c07aa96","fields":{"slug":"/metaprogramming-ruby-1/"},"frontmatter":{"title":"M Ruby - 1"}}},{"node":{"id":"3ab153c7-ef8e-5540-a0ec-ee7551892012","fields":{"slug":"/metaprogramming-ruby-2/"},"frontmatter":{"title":"M Ruby - 2. The Object Model"}}},{"node":{"id":"ab0c5e49-f893-5aaf-8315-c183e6f9df3c","fields":{"slug":"/metaprogramming-ruby-3/"},"frontmatter":{"title":"M Ruby - 3. Methods"}}},{"node":{"id":"ba539d0b-e3b6-507e-90b2-12083666ad46","fields":{"slug":"/metaprogramming-ruby-4/"},"frontmatter":{"title":"M Ruby - 4. Blocks"}}},{"node":{"id":"10646ae4-ced4-5411-87f6-7011a8f5c108","fields":{"slug":"/metaprogramming-ruby-5/"},"frontmatter":{"title":"M Ruby - 5. Class Definitions"}}},{"node":{"id":"9d128593-da43-521b-832e-ff48a726844c","fields":{"slug":"/metaprogramming-ruby-6/"},"frontmatter":{"title":"M Ruby - 6. Code That Writes Code"}}},{"node":{"id":"02c9824b-fff1-5517-bcd6-eb7690b1fc5a","fields":{"slug":"/metaprogramming-ruby-9/"},"frontmatter":{"title":"M Ruby - 9. The Design of Active Record"}}},{"node":{"id":"a48856b7-f3f6-56ca-a8f2-bf55cd90c62f","fields":{"slug":"/metaprogramming-ruby-10/"},"frontmatter":{"title":"M Ruby - 10. Active Support's Concern Module"}}},{"node":{"id":"b76117b8-cdf6-5fdb-a207-d3bada809e8d","fields":{"slug":"/metaprogramming-ruby-11/"},"frontmatter":{"title":"M Ruby - 11.alias_method_chain의 흥망성쇠"}}},{"node":{"id":"6d902f10-0216-599c-8523-7c663a9a2027","fields":{"slug":"/metaprogramming-ruby-12/"},"frontmatter":{"title":"M Ruby - 12. Attribute Methods의 진화"}}}]},"previous":{"fields":{"slug":"/metaprogramming-ruby-1/"},"frontmatter":{"title":"M Ruby - 1"}},"next":{"fields":{"slug":"/metaprogramming-ruby-3/"},"frontmatter":{"title":"M Ruby - 3. Methods"}}},"pageContext":{"id":"3ab153c7-ef8e-5540-a0ec-ee7551892012","series":"Metaprogramming Ruby","previousPostId":"34257cb7-20bf-52a1-a751-44435c07aa96","nextPostId":"ab0c5e49-f893-5aaf-8315-c183e6f9df3c"}},"staticQueryHashes":[]}